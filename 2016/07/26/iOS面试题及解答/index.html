<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="闲谈最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。 基础设计模式是什么？你知道哪些设计模式，并简要叙述。设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情，常用常见到的设计模式有以下几种。1.MVC：Model View Controller，模型 视图 控制器解耦合。2.MVVM：Model View ViewModel，模型 视图">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS面试题及解答">
<meta property="og:url" content="http://htmlios.github.io/2016/07/26/iOS面试题及解答/index.html">
<meta property="og:site_name" content="沐凡的博客">
<meta property="og:description" content="闲谈最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。 基础设计模式是什么？你知道哪些设计模式，并简要叙述。设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情，常用常见到的设计模式有以下几种。1.MVC：Model View Controller，模型 视图 控制器解耦合。2.MVVM：Model View ViewModel，模型 视图">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-06-27T06:25:36.576Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS面试题及解答">
<meta name="twitter:description" content="闲谈最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。 基础设计模式是什么？你知道哪些设计模式，并简要叙述。设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情，常用常见到的设计模式有以下几种。1.MVC：Model View Controller，模型 视图 控制器解耦合。2.MVVM：Model View ViewModel，模型 视图">



  <link rel="alternate" href="/atom.xml" title="沐凡的博客" type="application/atom+xml" />




  <link rel="canonical" href="http://htmlios.github.io/2016/07/26/iOS面试题及解答/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS面试题及解答 | 沐凡的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沐凡的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://htmlios.github.io/2016/07/26/iOS面试题及解答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mufan">
      <meta itemprop="description" content="这个世界上是没有捷径可言的<br>如果说有捷径，那也就是勤奋。">
      <meta itemprop="image" content="/images/zhl_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐凡的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS面试题及解答
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              

              
                
              

              <time title="创建时间：2016-07-26 02:17:00" itemprop="dateCreated datePublished" datetime="2016-07-26T02:17:00+08:00">2016-07-26</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工作/" itemprop="url" rel="index"><span itemprop="name">工作</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h1><p>最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="设计模式是什么？你知道哪些设计模式，并简要叙述。"><a href="#设计模式是什么？你知道哪些设计模式，并简要叙述。" class="headerlink" title="设计模式是什么？你知道哪些设计模式，并简要叙述。"></a>设计模式是什么？你知道哪些设计模式，并简要叙述。</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情，常用常见到的设计模式有以下几种。</span><br><span class="line"><span class="number">1.</span>MVC：Model View Controller，模型 视图 控制器解耦合。</span><br><span class="line"><span class="number">2.</span>MVVM：Model View ViewModel，模型 视图 业务逻辑 解耦合。</span><br><span class="line"><span class="number">3.</span>单例：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。</span><br><span class="line"><span class="number">4.</span>观察者：KVO是典型的观察者，观察某个属性的状态，状态发生变化时通知观察者。</span><br><span class="line"><span class="number">5.</span>委托：代理+协议的组合。实现<span class="number">1</span>对<span class="number">1</span>的反向传值操作。</span><br><span class="line"><span class="number">6.</span>工厂：通过一个类方法，批量的根据已有模板生产对象。</span><br></pre></td></tr></table></figure>
<h3 id="MVC和MVVM的区别是什么？"><a href="#MVC和MVVM的区别是什么？" class="headerlink" title="MVC和MVVM的区别是什么？"></a>MVC和MVVM的区别是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。</span><br><span class="line">MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。</span><br></pre></td></tr></table></figure>
<h3 id="import跟-include有什么区别，-class呢，-import-lt-gt-跟-import-quot-quot-有什么区别？"><a href="#import跟-include有什么区别，-class呢，-import-lt-gt-跟-import-quot-quot-有什么区别？" class="headerlink" title="#import跟#include有什么区别，@class呢，#import&lt;&gt;跟#import &quot;&quot;有什么区别？"></a><code>#import</code>跟<code>#include</code>有什么区别，<code>@class</code>呢，<code>#import&lt;&gt;</code>跟<code>#import &quot;&quot;</code>有什么区别？</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>#<span class="keyword">import</span>是Object-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#<span class="keyword">import</span>头文件会自动只导入一次，不会重复导入。</span><br><span class="line"><span class="number">2.</span>@<span class="keyword">class</span>告诉编译器某个类的声明，当执行时，才会去查看类的实现文件，可以解决头文件的相互包含。</span><br><span class="line"><span class="number">3.</span>#<span class="keyword">import</span>&lt;&gt;用来包含系统的头文件，#<span class="keyword">import</span> <span class="string">""</span>用来包含用户头文件。</span><br></pre></td></tr></table></figure>
<h3 id="frame和bounds有什么不同？"><a href="#frame和bounds有什么不同？" class="headerlink" title="frame和bounds有什么不同？"></a><code>frame</code>和<code>bounds</code>有什么不同？</h3><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">frame指的是该<span class="keyword">view</span>在父<span class="keyword">view</span>坐标系中的位置和大小，参考点是父<span class="keyword">view</span>的坐标系。</span><br><span class="line">bounds指的是该<span class="keyword">view</span>在本身坐标系统中的位置和大小，参考点是本身坐标系。</span><br></pre></td></tr></table></figure>
<h3 id="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？"><a href="#Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？" class="headerlink" title="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？"></a>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">Objective-<span class="keyword">C</span>的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</span><br></pre></td></tr></table></figure>
<h3 id="property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"><a href="#property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？" class="headerlink" title="@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"></a><code>@property</code>的本质是什么？<code>ivar</code>、<code>getter</code>、<code>setter</code>是如何生成并添加到这个类中的？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span> = ivar + getter + setter;</span><br><span class="line">“属性”(<span class="keyword">property</span>)有两大概念：ivar（实例变量）、getter + setter（存取方法）；</span><br><span class="line">”属性“(<span class="keyword">property</span>)作为Objective-C的一项特性，主要的作用就在于封装对象中的数据。Objective-C对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过”存取方法“(access <span class="function"><span class="keyword">method</span>)来访问。其中”获取方法“<span class="params">(getter)</span>用于读取变量值，而”设置方法“<span class="params">(setter)</span>用于写入变量值。</span></span><br></pre></td></tr></table></figure>
<h3 id="property中有哪些属性关键字？"><a href="#property中有哪些属性关键字？" class="headerlink" title="@property中有哪些属性关键字？"></a><code>@property</code>中有哪些属性关键字？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">属性可以拥有的特质分为四类：</span><br><span class="line"><span class="number">1.</span>原子性：<span class="keyword">nonatomic</span>特质</span><br><span class="line"><span class="number">2.</span>读/写权限：<span class="keyword">readwrite</span>（读写）、<span class="keyword">readonly</span>（只读）</span><br><span class="line"><span class="number">3.</span>内存管理语义：<span class="keyword">assign</span>、<span class="keyword">strong</span>、<span class="keyword">weak</span>、<span class="keyword">unsafe_unretained</span>、<span class="keyword">copy</span></span><br><span class="line"><span class="number">4.</span>方法名：<span class="keyword">getter</span>、<span class="keyword">setter</span></span><br><span class="line"><span class="number">5.</span>不常用的：<span class="keyword">nonnull</span>、<span class="keyword">null_resettable</span>、<span class="keyword">nullable</span></span><br></pre></td></tr></table></figure>
<h3 id="属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？"><a href="#属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？" class="headerlink" title="属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？"></a>属性关键字<code>readwrite</code>、<code>readonly</code>、<code>assign</code>、<code>retain</code>、<code>copy</code>、<code>nonatomic</code>各是什么作用，在哪种情况下用？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">readwrite</span>：可读可写特性。需要生成<span class="keyword">getter</span>和<span class="keyword">setter</span>方法。</span><br><span class="line"><span class="number">2.</span><span class="keyword">readonly</span>：只读特性。只会生成<span class="keyword">getter</span>方法，不会生成<span class="keyword">setter</span>方法，不希望属性在类外改变。</span><br><span class="line"><span class="number">3.</span><span class="keyword">assign</span>：赋值属性。<span class="keyword">setter</span>方法将传入参数赋值给实例变量；仅设置变量时，<span class="keyword">assign</span>用于基本数据类型(如<span class="built_in">NSInteger</span>、<span class="built_in">CGFloat</span>、<span class="built_in">CGRect</span>...)。</span><br><span class="line"><span class="number">4.</span><span class="keyword">retain</span>(MRC)/<span class="keyword">strong</span>(ARC)：表示持有特性。<span class="keyword">setter</span>方法将传入值先保留，再赋值，传入参数的retaincount会+<span class="number">1</span>。</span><br><span class="line"><span class="number">5.</span><span class="keyword">copy</span>：表示拷贝特性。<span class="keyword">setter</span>方法将传入对象复制一份，需要完全一份新的变量时。</span><br><span class="line"><span class="number">6.</span><span class="keyword">nonatomic</span>：非原子操作。不写的话就默认是atomic。atomic和<span class="keyword">nonatomic</span>的区别在于，系统自动生成<span class="keyword">getter</span>/<span class="keyword">setter</span>方法不一样。对于atomic属性，系统生成的<span class="keyword">getter</span>/<span class="keyword">setter</span>会保证get、set操作的完整性，而<span class="keyword">nonatomic</span>就没有这个保证了。所以，<span class="keyword">nonatomic</span>的速度要比atomic快。不过atomic可并不能保证现成安全（<span class="keyword">nonatomic</span>是非多线程下的，atomic是多线程下的）。</span><br></pre></td></tr></table></figure>
<h3 id="什么情况使用weak关键字，相比assign有什么不同？"><a href="#什么情况使用weak关键字，相比assign有什么不同？" class="headerlink" title="什么情况使用weak关键字，相比assign有什么不同？"></a>什么情况使用weak关键字，相比assign有什么不同？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用<span class="keyword">weak</span>来解决，比如delegate属性。</span><br><span class="line"><span class="number">2.</span>自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用<span class="keyword">weak</span>，自定义IBOutLet控件属性一般使用<span class="keyword">weak</span>，当然也可以使用<span class="keyword">strong</span>。</span><br><span class="line"><span class="keyword">IBOutlet</span>连出来的视图属性为什么可以被设置成<span class="keyword">weak</span>？</span><br><span class="line">因为父控件的subViews数组已经对它有一个强引用。</span><br><span class="line">不同点：</span><br><span class="line"><span class="keyword">assign</span>可以用非OC对象，而<span class="keyword">weak</span>必须用于OC对象。</span><br><span class="line"><span class="keyword">weak</span>表明该属性定义了一种”非拥有关系“。在属性所指的对象销毁时，属性值会自动清空(<span class="literal">nil</span>)。</span><br></pre></td></tr></table></figure>
<h3 id="怎么用copy关键字？"><a href="#怎么用copy关键字？" class="headerlink" title="怎么用copy关键字？"></a>怎么用<code>copy</code>关键字？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">用途：</span><br><span class="line"><span class="number">1.</span><span class="built_in">NSString</span>、<span class="built_in">NSArray</span>、<span class="built_in">NSDictionary</span>等等经常使用<span class="keyword">copy</span>关键字，是因为他们又对应的可变类型：<span class="built_in">NSMutableString</span>、<span class="built_in">NSMutableArray</span>、<span class="built_in">NSMutableDictionary</span>；</span><br><span class="line"><span class="number">2.</span>block也经常使用<span class="keyword">copy</span>关键字。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">block使用<span class="keyword">copy</span>是从MRC遗留下来的”传统“，在MRC中，方法内部的block实在栈区的，使用<span class="keyword">copy</span>可以把它放到堆区；在ARC中写不写都行；</span><br></pre></td></tr></table></figure>
<h3 id="用-property声明的NSString-NSArray-NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？"><a href="#用-property声明的NSString-NSArray-NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？" class="headerlink" title="用@property声明的NSString/NSArray/NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？"></a>用<code>@property</code>声明的NSString/NSArray/NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">用@Property声明<span class="built_in">NSString</span>、<span class="built_in">NSArray</span>、<span class="built_in">NSDictionary</span>经常使用<span class="keyword">copy</span>关键字，是因为他们有对应的可变类型：<span class="built_in">NSMutableString</span>、<span class="built_in">NSMutableArray</span>、<span class="built_in">NSMutableDictionary</span>，他们之间可能进行赋值操作(把可变的赋值给不可变的)，为确保对象中的字符串值不会无意间变动，应该设置新属性时拷贝一份。</span><br><span class="line"><span class="number">1.</span>因为父类指针可以指向子类对象，使用<span class="keyword">copy</span>的目的是为了让本对象的属性不受外界影响，使用<span class="keyword">copy</span>无论给我传入是一个可变对象还是不可变对象，我本身持有的就是一个不可变的副本。</span><br><span class="line"><span class="number">2.</span>如果我们使用的是<span class="keyword">strong</span>，那么这个属性就有可能指向一个可变对象，如果这个可变对象被修改了，那么会影响该属性。</span><br><span class="line">总结：使用<span class="keyword">copy</span>的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发生变化会无意间篡改不可变类型对象原来的值。</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝和深拷贝的区别？"><a href="#浅拷贝和深拷贝的区别？" class="headerlink" title="浅拷贝和深拷贝的区别？"></a>浅拷贝和深拷贝的区别？</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">浅拷贝：只复制指向对象的指针，而不复制引用对象本身。</span><br><span class="line">深拷贝：复制引用对象本身。内存中存在了两份独立的对象本身，当修改<span class="literal">A</span>时，<span class="built_in">A_copy</span>不变。</span><br></pre></td></tr></table></figure>
<h3 id="系统对象的copy与mutableCopy方法"><a href="#系统对象的copy与mutableCopy方法" class="headerlink" title="系统对象的copy与mutableCopy方法"></a>系统对象的<code>copy</code>与<code>mutableCopy</code>方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不管是集合类对象(NSArray、NSDictionary、NSSet...之类的对象)，还是非集合类对象(NSString、NSNumber...之类的对象)，接收到copy和mutableCopy消息时，都遵循以下准则：</span><br><span class="line">1.copy返回的是不可变对象(immuatableObject)；如果用copy返回值调用mutable对象的方法就会crash。</span><br><span class="line">2.mutableCopy返回的是可变对象(mutableObject)。</span><br><span class="line">总结一句话：只有对不可变对象进行copy操作是指针复制(浅复制)，其他情况都是内容复制(深复制)！</span><br></pre></td></tr></table></figure>
<h3 id="这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-array"><a href="#这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-array" class="headerlink" title="这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *array;"></a>这个写法会出什么问题：<code>@property (nonatomic, copy) NSMutableArray *array;</code></h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">问题：添加，删除，修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃。</span><br><span class="line">原因：是因为<span class="keyword">copy</span>就是复制一个不可变<span class="built_in">NSArray</span>的对象，不能对<span class="built_in">NSArray</span>对象进行添加/修改。</span><br></pre></td></tr></table></figure>
<h3 id="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"><a href="#如何让自己的类用copy修饰符？如何重写带copy关键字的setter？" class="headerlink" title="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"></a>如何让自己的类用<code>copy</code>修饰符？如何重写带<code>copy</code>关键字的<code>setter</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本和不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。</span><br><span class="line">具体步骤：</span><br><span class="line">1.需声明该类遵从NSCopying协议。</span><br><span class="line">2.实现NSCopying协议的方法。</span><br><span class="line">// 该协议只有一个方法：</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone;</span><br><span class="line">// 注意：使用copy修饰符，调用的是copy方法，其实真正需要实现的是&quot;copyWithZone&quot;方法。</span><br></pre></td></tr></table></figure>
<h3 id="写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic-copy-NSString-name"><a href="#写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic-copy-NSString-name" class="headerlink" title="写一个setter方法用于完成@property (nonatomic, retain) NSString *name; 写一个setter方法用于完成@property (nonatomic, copy) NSString *name;"></a>写一个setter方法用于完成<code>@property (nonatomic, retain) NSString *name;</code> 写一个setter方法用于完成<code>@property (nonatomic, copy) NSString *name;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// retain</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    [name retain];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// copy</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    id t = [name copy];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="synthesize和-dynamic分别有什么作用？"><a href="#synthesize和-dynamic分别有什么作用？" class="headerlink" title="@synthesize和@dynamic分别有什么作用？"></a><code>@synthesize</code>和<code>@dynamic</code>分别有什么作用？</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@property</span>有两个对应的词，一个是<span class="variable">@synthesize</span>(合成实例变量)，一个是<span class="variable">@dynamic</span>。</span><br><span class="line">如果<span class="variable">@synthesize</span>和<span class="variable">@dynamic</span>都没有写，那么默认的就是<span class="variable">@synthesize</span> var = _var;</span><br><span class="line"><span class="comment">// 在类的实现代码里通过@synthesize语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</span></span><br><span class="line"><span class="selector-tag">1</span>.@<span class="selector-tag">synthesize</span>的语义是如果你没有手动实现<span class="selector-tag">setter</span>和<span class="selector-tag">getter</span>方法，那么编译器会自动为你加上这两个方法。</span><br><span class="line"><span class="selector-tag">2</span>.@<span class="selector-tag">dynamic</span>告诉编译器，属性的<span class="selector-tag">setter</span>与<span class="selector-tag">getter</span>方法由用户自己实现，不自动生成(如<span class="variable">@dynamic</span> var)。</span><br></pre></td></tr></table></figure>
<h3 id="常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。"><a href="#常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。" class="headerlink" title="常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。"></a>常见的<code>Objective-C</code>的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Objective-C的数据类型有<span class="built_in">NSString</span>，<span class="built_in">NSNumber</span>，<span class="built_in">NSArray</span>，<span class="built_in">NSMutableArray</span>，<span class="built_in">NSData</span>等等，这些都是<span class="keyword">class</span>，创建后便是对象，而C语言的基本数据类型<span class="keyword">int</span>，只是一定字节的内存空间，用于存放数值；<span class="built_in">NSInteger</span>是基本数据类型，并不是<span class="built_in">NSNumber</span>的子类，当然也不是<span class="built_in">NSObject</span>的子类。<span class="built_in">NSInteger</span>是基本数据类型<span class="keyword">int</span>或者<span class="keyword">long</span>的别名(<span class="built_in">NSInteger</span>的定义<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="built_in">NSInteger</span>)，它的区别在于，<span class="built_in">NSInteger</span>会根据系统是<span class="number">32</span>位还是<span class="number">64</span>位来决定本身是<span class="keyword">int</span>还是<span class="keyword">long</span>。</span><br></pre></td></tr></table></figure>
<h3 id="id声明的对象有什么特性？"><a href="#id声明的对象有什么特性？" class="headerlink" title="id声明的对象有什么特性？"></a><code>id</code>声明的对象有什么特性？</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>声明的对象具有运动时的特性，即可以指向任意类型的Objective-C的对象。</span><br></pre></td></tr></table></figure>
<h3 id="Objective-C如何对内存管理的，说说你的看法和解决办法？"><a href="#Objective-C如何对内存管理的，说说你的看法和解决办法？" class="headerlink" title="Objective-C如何对内存管理的，说说你的看法和解决办法？"></a><code>Objective-C</code>如何对内存管理的，说说你的看法和解决办法？</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</span><br><span class="line"><span class="number">1.</span>自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。</span><br><span class="line"><span class="number">2.</span>手动内存计数MRC：遵循内存谁申请、谁释放；谁添加、谁释放的原则。</span><br><span class="line"><span class="number">3.</span>内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</span><br></pre></td></tr></table></figure>
<h3 id="Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？"><a href="#Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？" class="headerlink" title="Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？"></a><code>Objective-C</code>中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">线程的创建有三种方法：使用<span class="selector-tag">NSThread</span>创建、使用<span class="selector-tag">GCD</span>的<span class="selector-tag">dispatch</span>、使用子类的<span class="selector-tag">NSOPeration</span>，然后将其加入<span class="selector-tag">NSOperationQueue</span>；在主线程执行代码，方法是<span class="selector-tag">performSelectorOnMainThread</span>，如果想延迟执行代码可以用<span class="selector-tag">performSelector</span><span class="selector-pseudo">:onThread</span><span class="selector-pseudo">:withObject</span><span class="selector-pseudo">:waitUntilDone</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Category-类别-、Extension-扩展-和继承的区别。"><a href="#Category-类别-、Extension-扩展-和继承的区别。" class="headerlink" title="Category(类别)、Extension(扩展)和继承的区别。"></a><code>Category</code>(类别)、<code>Extension</code>(扩展)和继承的区别。</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">区别：</span><br><span class="line"><span class="number">1.</span>分类有名字，类扩展没有分类名字，是一种特殊的分类。</span><br><span class="line"><span class="number">2.</span>分类只能扩展方法(属性仅仅是声明，并没有真正实现)，类扩展可以扩展属性、成员变量和方法。</span><br><span class="line"><span class="number">3.</span>继承可以增加，修改或者删除方法，并且可以增加属性。</span><br></pre></td></tr></table></figure>
<h3 id="我们说的OC是动态运行时语言是什么意思？"><a href="#我们说的OC是动态运行时语言是什么意思？" class="headerlink" title="我们说的OC是动态运行时语言是什么意思？"></a>我们说的<code>OC</code>是动态运行时语言是什么意思？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主要是讲数据类型的确定由编译时，推迟到了运行时。简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</span><br></pre></td></tr></table></figure>
<h3 id="为什么我们常见的delegate属性都用是weak而不是retain-strong？"><a href="#为什么我们常见的delegate属性都用是weak而不是retain-strong？" class="headerlink" title="为什么我们常见的delegate属性都用是weak而不是retain/strong？"></a>为什么我们常见的<code>delegate</code>属性都用是<code>weak</code>而不是<code>retain</code>/<code>strong</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是为了防止delegate两端产生不必要的循环引用。</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br></pre></td></tr></table></figure>
<h3 id="什么时候共delegate，什么时候用Notification？"><a href="#什么时候共delegate，什么时候用Notification？" class="headerlink" title="什么时候共delegate，什么时候用Notification？"></a>什么时候共<code>delegate</code>，什么时候用<code>Notification</code>？</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Delegate</span><span class="params">(委托模式)</span></span>：<span class="number">1</span>对<span class="number">1</span>的反向消息通知功能。</span><br><span class="line"><span class="function"><span class="title">Notification</span><span class="params">(通知模式)</span></span>：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</span><br></pre></td></tr></table></figure>
<h3 id="什么是KVO和KVC？"><a href="#什么是KVO和KVC？" class="headerlink" title="什么是KVO和KVC？"></a>什么是<code>KVO</code>和<code>KVC</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.KVC(Key-Value-Coding)：键值编码，是一种通过字符串间接访问对象的方式(即给属性赋值)。</span><br><span class="line">举例说明：</span><br><span class="line">stu.name = @&quot;张三&quot;;// 点语法给属性赋值</span><br><span class="line">[stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;];// 通过字符串使用KVC方式给属性赋值</span><br><span class="line">2.KVO(Key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大简化了代码。</span><br><span class="line">KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。</span><br><span class="line">// 通过下方方法为属性添加KVO观察</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line"></span><br><span class="line">// 当被观察的属性发生变化时，会自动触发下方方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</span><br><span class="line"></span><br><span class="line">KVC和KVO的keyPath可以是属性、实例变量、成员变量。</span><br></pre></td></tr></table></figure>
<h3 id="KVC的底层实现？"><a href="#KVC的底层实现？" class="headerlink" title="KVC的底层实现？"></a><code>KVC</code>的底层实现？</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">当一个对象调用<span class="built_in">set</span>Value方法时，方法内部会做以下操作：</span><br><span class="line"><span class="number">1</span>.检查是否存在相应的key的<span class="built_in">set</span>方法，如果存在，就调用<span class="built_in">set</span>方法。</span><br><span class="line"><span class="number">2</span>.如果<span class="built_in">set</span>方法不存在，就会查找与key相同名称并且带有下划线的成员变量，如果有，则直接给成员变量赋值。</span><br><span class="line"><span class="number">3</span>.如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</span><br><span class="line"><span class="number">4</span>.如果还没有找到，则调用valueForUndefinedKey:和<span class="built_in">set</span>Value:<span class="keyword">for</span>UndeinedKey:方法。</span><br><span class="line">这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</span><br></pre></td></tr></table></figure>
<h3 id="KVO的底层实现？"><a href="#KVO的底层实现？" class="headerlink" title="KVO的底层实现？"></a><code>KVO</code>的底层实现？</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">KVO基于<span class="keyword">runtime</span>机制实现。</span><br></pre></td></tr></table></figure>
<h3 id="ViewController生命周期"><a href="#ViewController生命周期" class="headerlink" title="ViewController生命周期"></a><code>ViewController</code>生命周期</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">按照执行顺序排列：</span><br><span class="line"><span class="number">1</span><span class="selector-class">.initWithCoder</span>: 通过nib文件初始化时触发。</span><br><span class="line"><span class="number">2</span><span class="selector-class">.awakeFromNib</span>: nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。</span><br><span class="line"><span class="number">3</span><span class="selector-class">.loadView</span>: 开始加载视图控制器自带的view。</span><br><span class="line"><span class="number">4</span><span class="selector-class">.viewDidLoad</span>: 视图控制器的view被加载完成。</span><br><span class="line"><span class="number">5</span><span class="selector-class">.viewWillAppear</span>: 视图控制器的view将要显示在window上。</span><br><span class="line"><span class="number">6</span><span class="selector-class">.updateViewConstraints</span>: 视图控制器的view开始更新AutoLayout约束。</span><br><span class="line"><span class="number">7</span><span class="selector-class">.viewWillLayoutSubviews</span>: 视图控制器的view将要更新内容视图的位置。</span><br><span class="line"><span class="number">8</span><span class="selector-class">.viewDidLayoutSubviews</span>: 视图控制器的view已经更新视图的位置。</span><br><span class="line"><span class="number">9</span><span class="selector-class">.viewDidApear</span>: 试图控制器的view已经展示到window上。</span><br><span class="line"><span class="number">10</span><span class="selector-class">.viewWillDisappear</span>: 视图控制器的view将要从window上消失。</span><br><span class="line"><span class="number">11</span><span class="selector-class">.viewDidDisappear</span>: 视图控制器的view已经从window上消失。</span><br></pre></td></tr></table></figure>
<h3 id="方法和选择器有何不同？"><a href="#方法和选择器有何不同？" class="headerlink" title="方法和选择器有何不同？"></a>方法和选择器有何不同？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">selector</span>是一个方法的名字，方法是一个组合体，包含了名字和实现。</span><br></pre></td></tr></table></figure>
<h3 id="你是否接触过OC中的反射机制？简单聊一下概念和使用"><a href="#你是否接触过OC中的反射机制？简单聊一下概念和使用" class="headerlink" title="你是否接触过OC中的反射机制？简单聊一下概念和使用"></a>你是否接触过<code>OC</code>中的反射机制？简单聊一下概念和使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.class反射</span><br><span class="line">通过类名的字符串形式实例化对象。</span><br><span class="line">Class class = NSCalssFromString(@&quot;student&quot;);</span><br><span class="line">Student *stu = [[class alloc] init];</span><br><span class="line">将类名变为字符串。</span><br><span class="line">Class class = [Student class];</span><br><span class="line">NSString className = NSStringFromClass(class);</span><br><span class="line">2.SEL的反射</span><br><span class="line">通过方法的字符串形式实例化方法。</span><br><span class="line">SEL selector = NSSelectorFrom(@&quot;setName&quot;);</span><br><span class="line">[stu performSelector:selector withObject:@&quot;Mike&quot;];</span><br><span class="line">将方法变成字符串。</span><br><span class="line">NSStringFromSelector(@selector(setName:));</span><br></pre></td></tr></table></figure>
<h3 id="调用方法有两种方式："><a href="#调用方法有两种方式：" class="headerlink" title="调用方法有两种方式："></a>调用方法有两种方式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.直接通过方法名来调用。</span><br><span class="line">[person show];</span><br><span class="line">2.间接的通过SEL数据来调用。</span><br><span class="line">SEL aaa = @selector(show); </span><br><span class="line">[person performSelector:aaa];</span><br></pre></td></tr></table></figure>
<h3 id="如何对iOS设备进行性能测试？"><a href="#如何对iOS设备进行性能测试？" class="headerlink" title="如何对iOS设备进行性能测试？"></a>如何对iOS设备进行性能测试？</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">P<span class="function"><span class="title">rofile</span>-&gt;</span>I<span class="function"><span class="title">nstruments</span>-&gt;</span>Time Profiler</span><br></pre></td></tr></table></figure>
<h3 id="开发项目时你是怎么检查内存泄漏？"><a href="#开发项目时你是怎么检查内存泄漏？" class="headerlink" title="开发项目时你是怎么检查内存泄漏？"></a>开发项目时你是怎么检查内存泄漏？</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>静态分析analyze。</span><br><span class="line"><span class="number">2.</span>instruments工具里面有个leak可以动态分析。</span><br></pre></td></tr></table></figure>
<h3 id="什么是懒加载？"><a href="#什么是懒加载？" class="headerlink" title="什么是懒加载？"></a>什么是懒加载？</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。</span><br><span class="line">我觉得最好也最简单的一个例子就是<span class="built_in">table</span>View中的图片的加载显示，一个延时加载，避免内存过高，一个异步加载，避免线程堵塞提高用户体验。</span><br></pre></td></tr></table></figure>
<h3 id="类变量的-public-protected-private-package声明各有什么含义？"><a href="#类变量的-public-protected-private-package声明各有什么含义？" class="headerlink" title="类变量的 @public,@protected,@private,@package声明各有什么含义？"></a>类变量的 <code>@public</code>,<code>@protected</code>,<code>@private</code>,<code>@package</code>声明各有什么含义？</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@public</span> 任何地方都能访问；</span><br><span class="line"><span class="variable">@protected</span> 该类和子类中访问，是默认的；</span><br><span class="line"><span class="variable">@private</span> 只能在本类中访问；</span><br><span class="line"><span class="variable">@package</span> 本包内使用，跨包不可以。</span><br></pre></td></tr></table></figure>
<h3 id="什么是谓词？"><a href="#什么是谓词？" class="headerlink" title="什么是谓词？"></a>什么是谓词？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">谓词就是通过<span class="built_in">NSPredicate</span>给定的逻辑条件作为约束条件，完成对数据的筛选。</span><br><span class="line"><span class="comment">// 定义谓词对象，谓词对象中包含了过滤条件(过滤条件比较多)</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormate:<span class="string">@"age &lt; %d"</span>, <span class="number">30</span>];</span><br><span class="line"><span class="comment">// 使用谓词条件过滤数组中的元素，过滤之后返回查询结果</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [persons filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure>
<h3 id="isa指针问题"><a href="#isa指针问题" class="headerlink" title="isa指针问题"></a><code>isa</code>指针问题</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">isa：是一个Class类型的指针。每个实例对象有个isa的指针，他指向对象的类，而Class里也有个isa的指针，指向meteClass<span class="comment">(元类)</span>。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现。如果没有，元类会向他父类查找该方法。同时注意的是：元类<span class="comment">(meteClass)</span>也是类，它也是对象。元类也有isa指针，它的isa指针最终指向的是根元类<span class="comment">(root meteClass)</span>。根元类的isa指针指向本身，这样形成了一个闭环的内循环。</span><br></pre></td></tr></table></figure>
<h3 id="如何访问并修改一个类的私有属性？"><a href="#如何访问并修改一个类的私有属性？" class="headerlink" title="如何访问并修改一个类的私有属性？"></a>如何访问并修改一个类的私有属性？</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一种是通过KVC获取。</span><br><span class="line"><span class="number">2.</span>通过runtime访问并修改私有属性。</span><br></pre></td></tr></table></figure>
<h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个<code>objc</code>对象的<code>isa</code>的指针指向什么？有什么作用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指向他的类对象，从而可以找到对象上的方法。</span><br></pre></td></tr></table></figure>
<h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// 解析：</span><br><span class="line">self是类的隐藏参数，指向当前调用方法的这个类的实例。</span><br><span class="line">super是一个Magic Keyword，它本质是一个编译标识符，和self是指向的同一个消息接收者。</span><br><span class="line">不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。</span><br><span class="line">上面的例子不管调用[self class]还是[super class]，接收消息的对象都是当前Son *obj这个对象。</span><br></pre></td></tr></table></figure>
<h3 id="写一个完整的代理，包括声明、实现"><a href="#写一个完整的代理，包括声明、实现" class="headerlink" title="写一个完整的代理，包括声明、实现"></a>写一个完整的代理，包括声明、实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建 </span><br><span class="line">@protocol MyDelegate : NSObject</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">- (void)eat:(NSString *)foodName;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 声明.h </span><br><span class="line">@interface Person : NSObject &lt;MyDelegate&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 实现.m</span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)eat:(NSString *)foodName &#123;</span><br><span class="line">    NSLog(@&quot;吃：%@&quot;, foodName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    NSLog(@&quot;run&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="isKindOfClass、isMemberOfClass、selector作用分别是什么？"><a href="#isKindOfClass、isMemberOfClass、selector作用分别是什么？" class="headerlink" title="isKindOfClass、isMemberOfClass、selector作用分别是什么？"></a><code>isKindOfClass</code>、<code>isMemberOfClass</code>、<code>selector</code>作用分别是什么？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">isKindOfClass： 作用是某个对象属于某个类型或者继承自某类。</span><br><span class="line">isMemberOfClass：某个对象确切属于某个类型。</span><br><span class="line"><span class="keyword">selector</span>：通过方法名，获取在内存中的函数的入口地址。</span><br></pre></td></tr></table></figure>
<h3 id="delegate和notification的区别"><a href="#delegate和notification的区别" class="headerlink" title="delegate和notification的区别"></a><code>delegate</code>和<code>notification</code>的区别</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>二者都用于传递消息，不同之处主要在于一个是一对一的，一个是一对多的。</span><br><span class="line"><span class="number">2.</span>notification通过维护一个array，实现一对消息的转发。</span><br><span class="line"><span class="number">3.</span>delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。</span><br></pre></td></tr></table></figure>
<h3 id="什么是block？"><a href="#什么是block？" class="headerlink" title="什么是block？"></a>什么是block？</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">闭包<span class="comment">(block)</span>：闭包就是获取其它函数局部变量的匿名函数。</span><br></pre></td></tr></table></figure>
<h3 id="block反向传值"><a href="#block反向传值" class="headerlink" title="block反向传值"></a>block反向传值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在控制器间传值可以使用代理或者block，使用block相对来说简洁。</span><br><span class="line">在前一个控制器的touchesBegan:方法内实现如下代码。</span><br><span class="line">// OneViewController.m</span><br><span class="line">TwoViewController *twoVC = [[TwoViewController alloc] init];</span><br><span class="line">towVC.valueBlock = ^(NSString *str) &#123;</span><br><span class="line">    NSLog(@&quot;OneViewController:%@&quot;, str);</span><br><span class="line">&#125;;</span><br><span class="line">[self presentViewController:twoVC animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">// TwoViewController.h (在.h文件中声明一个block属性)</span><br><span class="line">@property (nonatomic, copy) void (^valueBlock)(NSString *str);</span><br><span class="line">// TwoViewController.m (在.m中实现方法)</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    // 传值：调用block</span><br><span class="line">    if (_valueBlock) &#123;</span><br><span class="line">        _valueBlock(@&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="block的注意点"><a href="#block的注意点" class="headerlink" title="block的注意点"></a><code>block</code>的注意点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在block内部使用外部指针且会造成玄幻引用情况下，需要用__weak修饰外部指针：</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">2.在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。</span><br><span class="line">__strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">3.如果需要在block内部改变外部栈区变量的话，需要用__block修饰外部变量。</span><br></pre></td></tr></table></figure>
<h3 id="BAD-ACCESS在什么情况下出现？"><a href="#BAD-ACCESS在什么情况下出现？" class="headerlink" title="BAD_ACCESS在什么情况下出现？"></a>BAD_ACCESS在什么情况下出现？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</span><br></pre></td></tr></table></figure>
<h3 id="IIdb（gdb）常用的控制台调用命令？"><a href="#IIdb（gdb）常用的控制台调用命令？" class="headerlink" title="IIdb（gdb）常用的控制台调用命令？"></a>IIdb（gdb）常用的控制台调用命令？</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">p</span>输出基本类型。是打印命令，需要指定类型。是<span class="keyword">print</span>的缩写。</span><br><span class="line"><span class="keyword">p</span>(<span class="keyword">int</span>)[[[self <span class="keyword">view</span>] subviews] <span class="built_in">count</span>]</span><br><span class="line"><span class="number">2</span>.<span class="keyword">po</span> 打印对象，会调用对象description方法。是<span class="keyword">print</span>-object的简写。</span><br><span class="line"><span class="keyword">po</span> [self <span class="keyword">view</span>]</span><br><span class="line"><span class="number">3</span>.expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用在调试过程中修改变量的值。</span><br><span class="line"><span class="number">4</span>.bt：打印调用堆栈，是thread backrace的简写，加<span class="keyword">all</span>可以打印所有thread的堆栈。</span><br><span class="line"><span class="number">5</span>.<span class="keyword">br</span> |：是breakpoint <span class="keyword">list</span>的简写。</span><br></pre></td></tr></table></figure>
<h3 id="你一般是怎么用Instruments的？"><a href="#你一般是怎么用Instruments的？" class="headerlink" title="你一般是怎么用Instruments的？"></a>你一般是怎么用Instruments的？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Instruments</span>里面工具很多，常用：</span><br><span class="line">1<span class="selector-class">.Time</span> <span class="selector-tag">Profiler</span>：性能分析</span><br><span class="line">2<span class="selector-class">.Zombies</span>：检查是否访问了僵尸对象，但是这个工具从上往下检查，不智能。</span><br><span class="line">3<span class="selector-class">.Allocations</span>：用来检查内存，写算法的那批人也用这个来检查。</span><br><span class="line">4<span class="selector-class">.Leaks</span>：检查内存，看是否有内存泄漏。</span><br></pre></td></tr></table></figure>
<h3 id="iOS中常用的数据存储方式有哪些？"><a href="#iOS中常用的数据存储方式有哪些？" class="headerlink" title="iOS中常用的数据存储方式有哪些？"></a>iOS中常用的数据存储方式有哪些？</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">数据存储方式有四种方案：NSUserDefault、KeyChain、<span class="keyword">File</span>、<span class="keyword">DB</span>。</span><br><span class="line">其中<span class="keyword">File</span>有三种方式：writeToFile:atomically:、Plist、NSKeyedArchiever(归档)</span><br><span class="line"><span class="keyword">DB</span>包含：SQLite、FMDB、CoreData</span><br></pre></td></tr></table></figure>
<h3 id="iOS的沙盒目录结构是怎样的？"><a href="#iOS的沙盒目录结构是怎样的？" class="headerlink" title="iOS的沙盒目录结构是怎样的？"></a>iOS的沙盒目录结构是怎样的？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">沙盒结构：</span><br><span class="line">1<span class="selector-class">.AppName</span><span class="selector-class">.app</span>目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。</span><br><span class="line">2<span class="selector-class">.Documents</span>：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据。<span class="selector-tag">iCloud</span>备份目录。(这里不能存缓存文件，否则上架不被通过)</span><br><span class="line">3<span class="selector-class">.Library</span>目录：这个目录下有两个子目录：</span><br><span class="line"><span class="selector-tag">Preferences</span>目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用<span class="selector-tag">NSUserDefaults</span>类来取得和设置应用程序的偏好。</span><br><span class="line"><span class="selector-tag">Caches</span>目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。</span><br><span class="line">可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除<span class="selector-tag">Caches</span>以外，都会被<span class="selector-tag">iTunes</span>备份。</span><br><span class="line">4<span class="selector-class">.tmp</span>：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</span><br></pre></td></tr></table></figure>
<h3 id="iOS多线程技术有哪几种方式？"><a href="#iOS多线程技术有哪几种方式？" class="headerlink" title="iOS多线程技术有哪几种方式？"></a>iOS多线程技术有哪几种方式？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">prhread、<span class="built_in">NSThread</span>、GCD、<span class="built_in">NSOperation</span></span><br></pre></td></tr></table></figure>
<h3 id="GCD与NSOperation的区别"><a href="#GCD与NSOperation的区别" class="headerlink" title="GCD与NSOperation的区别"></a><code>GCD</code>与<code>NSOperation</code>的区别</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GCD</span>和NSOperation都是用于实现多线程：</span><br><span class="line"><span class="keyword">GCD</span>基于<span class="keyword">C</span>语言的底层API，<span class="keyword">GCD</span>主要与block结合使用，代码简洁高效。</span><br><span class="line">NSOperation属于Objective-<span class="keyword">C</span>类，是基于<span class="keyword">GCD</span>更高一层的封装。复杂任务一般用NSOperation实现。</span><br></pre></td></tr></table></figure>
<h3 id="写出使用GCD方式从子线程回到主线程的方法代码"><a href="#写出使用GCD方式从子线程回到主线程的方法代码" class="headerlink" title="写出使用GCD方式从子线程回到主线程的方法代码"></a>写出使用GCD方式从子线程回到主线程的方法代码</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_sync(<span class="name">dispatch_get_main_queue</span>(), ^&#123;&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）"><a href="#如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）" class="headerlink" title="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）"></a>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用Dispatch Group追加block到Global Group Queue，这些block如果全部执行完毕，就会执行Main DispatchQueue中的结束处理的block。</span><br><span class="line">// 创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 获取全局并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片1 **/&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片2 **/&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片3 **/&#125;);</span><br><span class="line">// 当并发队列组中的任务执行完毕后才会执行这里的代码</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;/* 合并图片 **/&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-barrier-async-栅栏函数-的作用是什么？"><a href="#dispatch-barrier-async-栅栏函数-的作用是什么？" class="headerlink" title="dispatch_barrier_async(栅栏函数)的作用是什么？"></a>dispatch_barrier_async(栅栏函数)的作用是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class="line">作用：</span><br><span class="line">1.在它前面的任务执行结束后才执行，它后面的任务要等它执行完成后才开始执行。</span><br><span class="line">2.避免数据竞争。</span><br><span class="line">// 1.创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2.向队列中添加任务</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">   // 1.2是并行的</span><br><span class="line">   NSLog(@&quot;任务1，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">   NSLog(@&quot;任务2，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">   NSLog(@&quot;任务 barrier，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这两个是同时执行的 </span><br><span class="line">    NSLog(@&quot;任务3，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务4，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出结果：任务1 任务2 -&gt; 任务barrier -&gt;任务3 任务4</span><br><span class="line">// 其中任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。</span><br></pre></td></tr></table></figure>
<h3 id="以下代码运行结果如何？"><a href="#以下代码运行结果如何？" class="headerlink" title="以下代码运行结果如何？"></a>以下代码运行结果如何？</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">viewDidLoad</span> &#123;</span><br><span class="line">    <span class="selector-attr">[super viewDidLoad]</span>;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"1"</span>);</span><br><span class="line">    <span class="selector-tag">dispatch_asyc</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="selector-tag">NSLog</span>(@<span class="string">"2"</span>);	</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"3"</span>);</span><br><span class="line">    <span class="comment">// 只输出：1。主线程死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">从字面上看，就是运行循环，跑圈</span><br><span class="line">其实它内部就是<span class="keyword">do</span>-<span class="keyword">while</span>循环，在这个循环内部不断处理各种任务(比如Source、Timer、Observer)</span><br><span class="line">一个现成对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。</span><br><span class="line">通过RunLoop，有事运行，没事就休息，可以节省CPU资源，提高程序性能。</span><br><span class="line"></span><br><span class="line">主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>&#123;argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="说说你对runtime的理解"><a href="#说说你对runtime的理解" class="headerlink" title="说说你对runtime的理解"></a>说说你对runtime的理解</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Runtime</span>又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。</span><br></pre></td></tr></table></figure>
<h3 id="Runtime实现机制是什么，怎么用，一般用于干嘛？"><a href="#Runtime实现机制是什么，怎么用，一般用于干嘛？" class="headerlink" title="Runtime实现机制是什么，怎么用，一般用于干嘛？"></a>Runtime实现机制是什么，怎么用，一般用于干嘛？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.使用时需要导入的头文件</span><br><span class="line"><span class="number">2</span>.Runtime运行时机制，它是一套C语言库。</span><br><span class="line"><span class="number">3</span>.实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</span><br><span class="line">比如：</span><br><span class="line">类转成了Runtime库里面的结构体等数据类型。</span><br><span class="line">方法转成了Runtime库里面的C语言函数。</span><br><span class="line">平时调方法都是转成了objc_msgSend函数(所以说OC有个消息转发机制)</span><br><span class="line"><span class="comment">// OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</span></span><br><span class="line"><span class="comment">// [stu show]; 在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));</span></span><br><span class="line"><span class="number">4</span>.因此，可以说Runtime是OC的底层实现，是OC的幕后执行者。</span><br><span class="line"></span><br><span class="line">有了Runtime库，能做什么事情呢？</span><br><span class="line">Runtime库里面包含了跟类、成员变量、方法相关的API。</span><br><span class="line">比如：</span><br><span class="line"><span class="number">1</span>.获取类里面的所有成员变量。</span><br><span class="line"><span class="number">2</span>.为类动态添加成员变量。</span><br><span class="line"><span class="number">3</span>.为类动态添加新的方法。</span><br><span class="line"><span class="number">4</span>.动态改变类的方法实现等。(<span class="function"><span class="keyword">Method</span> <span class="title">Swizzling</span>)</span></span><br><span class="line"><span class="function">因此，有了<span class="title">Runtime</span>，想怎么改就怎么改。</span></span><br></pre></td></tr></table></figure>
<h3 id="什么是Method-Swizzle（黑魔法），什么情况下会使用？"><a href="#什么是Method-Swizzle（黑魔法），什么情况下会使用？" class="headerlink" title="什么是Method Swizzle（黑魔法），什么情况下会使用？"></a>什么是Method Swizzle（黑魔法），什么情况下会使用？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法<span class="function"><span class="keyword">Method</span> <span class="title">Swizzle</span>。</span></span><br><span class="line"><span class="function">2.<span class="title">Method</span> <span class="title">Swizzle</span>指的是改变一个已存在的选择器对应的实现的过程。<span class="title">OC</span>中方法的调用能够在运行时通过改变类的调度表中选择器到最终函数的映射关系。</span></span><br><span class="line"><span class="function">3.在<span class="title">OC</span>中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是<span class="title">selector</span>的名字。利用<span class="title">OC</span>的动态特性，可以实现在运行时偷换<span class="title">selector</span>对应的方法实现。</span></span><br><span class="line"><span class="function">4.每个类都有一个方法列表，存放着<span class="title">selector</span>的名字和方法实现的映射关系。<span class="title">IMP</span>有点类似函数指针，指向具体的方法实现。</span></span><br><span class="line"><span class="function">5.我们可以利用<span class="title">method_exchangeImplementations</span>来交换2个方法中的<span class="title">IMP</span>。</span></span><br><span class="line"><span class="function">6.我们可以利用<span class="title">class_replaceMethod</span>来修改类。</span></span><br><span class="line"><span class="function">7.我们可以利用<span class="title">method_setImplementation</span>来直接设置某个方法的<span class="title">IMP</span>。</span></span><br><span class="line"><span class="function">8.归根结底，都是偷换了<span class="title">selector</span>的<span class="title">IMP</span>。</span></span><br></pre></td></tr></table></figure>
<h3 id="objc-msgForward函数是做什么的，直接调用它将会发生什么？"><a href="#objc-msgForward函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="_objc_msgForward函数是做什么的，直接调用它将会发生什么？"></a><code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">_objc_msgForward</span>是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<span class="variable">_objc_msgForward</span>会尝试做消息转发。</span><br></pre></td></tr></table></figure>
<h3 id="什么是TCP-UDP？"><a href="#什么是TCP-UDP？" class="headerlink" title="什么是TCP/UDP？"></a>什么是TCP/UDP？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP：传输控制协议。</span><br><span class="line">UDP：用户数据协议。</span><br><span class="line"></span><br><span class="line">TCP是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。</span><br><span class="line">UDP是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。</span><br><span class="line">简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。</span><br></pre></td></tr></table></figure>
<h3 id="通信底层原理（OSI七层模型）"><a href="#通信底层原理（OSI七层模型）" class="headerlink" title="通信底层原理（OSI七层模型）"></a>通信底层原理（OSI七层模型）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OSI采用了分层的结构化技术，共分七层：</span><br><span class="line">物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</span><br></pre></td></tr></table></figure>
<h3 id="OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？"><a href="#OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？" class="headerlink" title="OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？"></a>OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？</h3><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程的方法</span></span><br><span class="line">-<span class="ruby"> [NSThread <span class="symbol">detachNewThreadSelector:</span><span class="literal">nil</span> <span class="symbol">toTarget:</span><span class="literal">nil</span> <span class="symbol">withObject:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">- [<span class="keyword">self</span> <span class="symbol">performSelectorInBackground:</span><span class="literal">nil</span> <span class="symbol">withObject:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">- [[NSThread alloc] <span class="symbol">initWithTarget:</span><span class="literal">nil</span> <span class="symbol">selector:</span><span class="literal">nil</span> <span class="symbol">object:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">- dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;&#125;);</span></span><br><span class="line"><span class="ruby">- [[NSOperationQueue new] <span class="symbol">addOperation:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">/<span class="regexp">/ 主线程中执行代码的方法</span></span></span><br><span class="line"><span class="ruby">- [<span class="keyword">self</span> <span class="symbol">performSelectorOnMainThread:</span><span class="literal">nil</span> <span class="symbol">withObject:</span><span class="literal">nil</span> <span class="symbol">waitUntilDone:</span>YES];</span></span><br><span class="line"><span class="ruby">- dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</span></span><br><span class="line"><span class="ruby">- [[NSOperationQueue mainQueue] <span class="symbol">addOperation:</span><span class="literal">nil</span>];</span></span><br></pre></td></tr></table></figure>
<h3 id="tableView的重用机制？"><a href="#tableView的重用机制？" class="headerlink" title="tableView的重用机制？"></a>tableView的重用机制？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UITableView</span>通过重用单元格达到节省内存的目的；通过为每个单元格指定一个重用的标识符，即指定了单元格的种类，当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新的单元格从屏幕外滑入屏幕时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</span><br></pre></td></tr></table></figure>
<h3 id="用伪代码写一个现成安全的单例模式"><a href="#用伪代码写一个现成安全的单例模式" class="headerlink" title="用伪代码写一个现成安全的单例模式"></a>用伪代码写一个现成安全的单例模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static id _instance;</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareData &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何实现视图的变形？"><a href="#如何实现视图的变形？" class="headerlink" title="如何实现视图的变形？"></a>如何实现视图的变形？</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">通过修改<span class="built_in">view</span>的<span class="built_in">transform</span>属性即可。</span><br></pre></td></tr></table></figure>
<h3 id="在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？"><a href="#在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？" class="headerlink" title="在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？"></a>在手势对象基础类<code>UIGestureRecognizer</code>的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UITapGestureRecognizer</span>、<span class="built_in">UISwipeGestureRecognizer</span>是一次性手势，手势发生后，响应只会执行一次。</span><br></pre></td></tr></table></figure>
<h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">NSString *<span class="keyword">str</span> = @<span class="string">"abc123"</span>;</span><br><span class="line">NSArray *arr = [<span class="keyword">str</span> componentsSeperatedByString:@<span class="string">""</span>];</span><br></pre></td></tr></table></figure>
<h3 id="如何高性能的给UIImageView加个圆角？"><a href="#如何高性能的给UIImageView加个圆角？" class="headerlink" title="如何高性能的给UIImageView加个圆角？"></a>如何高性能的给UIImageView加个圆角？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制，而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。</span><br><span class="line">self.view.layer.cornerRadius = 5.0f;</span><br><span class="line">self.view.layer.masksToBounds = YES;</span><br><span class="line"></span><br><span class="line">正确的解决方案：使用绘图技术</span><br><span class="line">- (UIImage *)circleImage &#123;</span><br><span class="line">	// NO代表透明 </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">    // 获得上下文</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">    // 添加一个圆</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">    CGContextAddEllipseInRect(ctx, rect);</span><br><span class="line">    // 裁剪</span><br><span class="line">    CGContextClip(ctx);</span><br><span class="line">    // 将图片画上去</span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    // 关闭上下文</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有一种方案：使用贝塞尔曲线“切割”这个图片，给UIImageView添加的圆角，其实也是通过绘图技术来实现的。</span><br><span class="line">UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">imageView.center = CGPointMake(200, 300);</span><br><span class="line">UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1);</span><br><span class="line">[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:50] addClip];</span><br><span class="line">[anotherImage drawInRct:imageView.bounds];</span><br><span class="line">imageView.image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">[self.view addSubview:imageView];</span><br></pre></td></tr></table></figure>
<h3 id="你是怎么封装一个view的"><a href="#你是怎么封装一个view的" class="headerlink" title="你是怎么封装一个view的"></a>你是怎么封装一个view的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.可以通过纯代码或者xib的方式来封装子控件。</span><br><span class="line">2.建立一个跟view相关的模型，然后将模型数据给view，通过模型上的数据给view的子控件赋值。</span><br><span class="line">/** 纯代码初始化控件时一定会走这个方法 */</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 通过xib初始化控件时一定会走这个方法 */</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupUI &#123;// 初始化代码 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTTP协议中POST方法和GET方法有哪些区别？"><a href="#HTTP协议中POST方法和GET方法有哪些区别？" class="headerlink" title="HTTP协议中POST方法和GET方法有哪些区别？"></a>HTTP协议中POST方法和GET方法有哪些区别？</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">GET</span>用于向服务器请求数据，POST用于提交数据。</span><br><span class="line"><span class="number">2.</span><span class="keyword">GET</span>请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此<span class="keyword">GET</span>请求不适合用于验证密码等操作。</span><br><span class="line"><span class="number">3.</span><span class="keyword">GET</span>请求的URL有长度限制，POST请求不会有长度限制。</span><br></pre></td></tr></table></figure>
<h3 id="请简单的介绍下APNS发送系统消息的机制"><a href="#请简单的介绍下APNS发送系统消息的机制" class="headerlink" title="请简单的介绍下APNS发送系统消息的机制"></a>请简单的介绍下APNS发送系统消息的机制</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。</span><br><span class="line">APNS的原理：</span><br><span class="line"><span class="number">1.</span>应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)；</span><br><span class="line"><span class="number">2.</span>应用程序接收到设备令牌并发送给自己的后台服务器；</span><br><span class="line"><span class="number">3.</span>服务器把要推送的内容和设备发送给APNS；</span><br><span class="line"><span class="number">4.</span>APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示。</span><br></pre></td></tr></table></figure>
<h3 id="iOS开发逆向传值的集中方法整理"><a href="#iOS开发逆向传值的集中方法整理" class="headerlink" title="iOS开发逆向传值的集中方法整理"></a>iOS开发逆向传值的集中方法整理</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>代理传值</span><br><span class="line"><span class="number">2.</span>通知传值</span><br><span class="line"><span class="number">3.</span>单例传值</span><br><span class="line"><span class="number">4.</span>block传值</span><br><span class="line"><span class="number">5.</span>extern传值(全局变量)</span><br><span class="line"><span class="number">6.</span>KVO传值</span><br></pre></td></tr></table></figure>
<h3 id="你使用过Objective-C的运行时编程-Runtime-Programming-么-如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"><a href="#你使用过Objective-C的运行时编程-Runtime-Programming-么-如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？" class="headerlink" title="你使用过Objective-C的运行时编程(Runtime Programming)么?如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"></a>你使用过Objective-C的运行时编程(Runtime Programming)么?如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Objective-C的重要特性是Runtime(运行时)，在#import下能看到相关的方法，用objc_getClass()和class_copyMethodList()获取过私有API；使用</span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">method1</span> = <span class="title">class_getInstanceMethod</span><span class="params">(cls, sel1)</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">method2</span> = <span class="title">class_getInstanceMethod</span><span class="params">(cls, sel2)</span>;</span></span><br><span class="line">method_exchangeImplementations(method1, method2);</span><br><span class="line"></span><br><span class="line">代码交换两个方法，在写<span class="keyword">unit</span> test时使用到。</span><br></pre></td></tr></table></figure>
<h3 id="Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）"><a href="#Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）" class="headerlink" title="Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）"></a>Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">UI框架的底层有CoreAnimation，CoreAnimation的底层有CoreGraphics。</span><br><span class="line">UIKit<span class="string">|</span></span><br><span class="line">--------<span class="string">|</span></span><br><span class="line">Core Animation<span class="string">|</span></span><br><span class="line">Core Graphics<span class="string">|</span></span><br><span class="line">Graphics Hardware<span class="string">|</span></span><br><span class="line">使用CA做过menu菜单的展开收起</span><br></pre></td></tr></table></figure>
<h3 id="是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。"><a href="#是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。" class="headerlink" title="是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。"></a>是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CoreText可以解决复杂文字内容排版问题。CoreImage可以处理图片，为其添加各种效果。体验是很强大，挺复杂的。</span><br></pre></td></tr></table></figure>
<h3 id="自动释放池是什么，如何工作"><a href="#自动释放池是什么，如何工作" class="headerlink" title="自动释放池是什么，如何工作"></a>自动释放池是什么，如何工作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放，它仍然是个OC的对象，因此自动释放池定义的作用域内的其它对象可以向他发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。</span><br></pre></td></tr></table></figure>
<h3 id="NSNotification和KVO的区别和用法是什么-什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate-或者delegate的Array-来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么-虽然protocol和delegate这种东西面试已经面烂了"><a href="#NSNotification和KVO的区别和用法是什么-什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate-或者delegate的Array-来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么-虽然protocol和delegate这种东西面试已经面烂了" class="headerlink" title="NSNotification和KVO的区别和用法是什么?什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate(或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么?(虽然protocol和delegate这种东西面试已经面烂了)"></a>NSNotification和KVO的区别和用法是什么?什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate(或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么?(虽然protocol和delegate这种东西面试已经面烂了)</h3><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">NSNotification是通知模式在iOS的实现，KVO的全称是键值观察(<span class="keyword">Key</span>-value observing)，其是基于KVC(<span class="keyword">key</span>-value coding)的，KVC是一个通过属性名访问属性变量的机制。例如<span class="keyword">Module</span>层的变化，通知到多个Controller对象时，可以使用NSNotification；如果是只需要观察某个对象的某个属性，可以使用KVO。</span><br><span class="line">对于委托模式，在设计模式中是对象适配器模式，其是<span class="keyword">delegate</span>是指向某个对象，这是一对一的关系，而在通知模式中，往往是一对多的关系。委托模式，从技术上可以实现改变<span class="keyword">delegate</span>指向的对象，但不建议这样做，会让人迷惑，如果一个<span class="keyword">delegate</span>对象不断改变，指向不同的对象。</span><br></pre></td></tr></table></figure>
<h3 id="你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）"><a href="#你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）" class="headerlink" title="你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）"></a>你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">使用<span class="built_in">NSOperationQueue</span>用来管理子类化的<span class="built_in">NSOperation</span>对象，控制其线程并发数目。GCD和<span class="built_in">NSOperation</span>都可以实现对线程的管理，区别是<span class="built_in">NSOperation</span>和<span class="built_in">NSOperationQueue</span>是多线程的面向对象抽象。项目中使用<span class="built_in">NSOperation</span>的优点是<span class="built_in">NSOperation</span>是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化<span class="built_in">NSOperation</span>的设计思路，是具有面向对象的有点(复用、封装)，使得实现多线程支持，而接口简单，建议在复杂项目中使用。</span><br><span class="line">项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会使代码更为易读，建议在简单项目中使用。</span><br></pre></td></tr></table></figure>
<h3 id="既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么"><a href="#既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么" class="headerlink" title="既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?"></a>既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">使用block时要注意，若将block做函数参数时，需要把它放到最后，<span class="keyword">GCD</span>是Grand Central <span class="keyword">Dispatch</span>，是一个对线程开源类库，而<span class="keyword">Block</span>是闭包，是能够读取其它函数内部变量的函数。</span><br></pre></td></tr></table></figure>
<h3 id="对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？"><a href="#对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？" class="headerlink" title="对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？"></a>对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用<span class="keyword">link</span>命令及flag解决冲突。</span><br></pre></td></tr></table></figure>
<h3 id="你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。"><a href="#你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。" class="headerlink" title="你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。"></a>你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一个文件解压压缩框架，从使用者角度出发，只需要关注发送给框架一个解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给使用者，如解压完成、解压出错等。在框架内部去构建对象的关系，通过抽象让其更为健壮、便于更改。其次是API的说明文档。</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/02/iOS-Runloop浅谈/" rel="next" title="iOS-Runloop浅谈">
                <i class="fa fa-chevron-left"></i> iOS-Runloop浅谈
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/27/iOS面试题及解答-二/" rel="prev" title="iOS面试题及解答(二)">
                iOS面试题及解答(二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/zhl_avatar.jpg"
                alt="mufan" />
            
              <p class="site-author-name" itemprop="name">mufan</p>
              <p class="site-description motion-element" itemprop="description">这个世界上是没有捷径可言的<br>如果说有捷径，那也就是勤奋。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/htmlios" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#闲谈"><span class="nav-number">1.</span> <span class="nav-text">闲谈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基础"><span class="nav-number">2.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计模式是什么？你知道哪些设计模式，并简要叙述。"><span class="nav-number">2.0.1.</span> <span class="nav-text">设计模式是什么？你知道哪些设计模式，并简要叙述。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC和MVVM的区别是什么？"><span class="nav-number">2.0.2.</span> <span class="nav-text">MVC和MVVM的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import跟-include有什么区别，-class呢，-import-lt-gt-跟-import-quot-quot-有什么区别？"><span class="nav-number">2.0.3.</span> <span class="nav-text">#import跟#include有什么区别，@class呢，#import&lt;&gt;跟#import &quot;&quot;有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#frame和bounds有什么不同？"><span class="nav-number">2.0.4.</span> <span class="nav-text">frame和bounds有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？"><span class="nav-number">2.0.5.</span> <span class="nav-text">Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"><span class="nav-number">2.0.6.</span> <span class="nav-text">@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property中有哪些属性关键字？"><span class="nav-number">2.0.7.</span> <span class="nav-text">@property中有哪些属性关键字？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？"><span class="nav-number">2.0.8.</span> <span class="nav-text">属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么情况使用weak关键字，相比assign有什么不同？"><span class="nav-number">2.0.9.</span> <span class="nav-text">什么情况使用weak关键字，相比assign有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么用copy关键字？"><span class="nav-number">2.0.10.</span> <span class="nav-text">怎么用copy关键字？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-property声明的NSString-NSArray-NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？"><span class="nav-number">2.0.11.</span> <span class="nav-text">用@property声明的NSString/NSArray/NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝和深拷贝的区别？"><span class="nav-number">2.0.12.</span> <span class="nav-text">浅拷贝和深拷贝的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统对象的copy与mutableCopy方法"><span class="nav-number">2.0.13.</span> <span class="nav-text">系统对象的copy与mutableCopy方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-array"><span class="nav-number">2.0.14.</span> <span class="nav-text">这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *array;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"><span class="nav-number">2.0.15.</span> <span class="nav-text">如何让自己的类用copy修饰符？如何重写带copy关键字的setter？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic-copy-NSString-name"><span class="nav-number">2.0.16.</span> <span class="nav-text">写一个setter方法用于完成@property (nonatomic, retain) NSString *name; 写一个setter方法用于完成@property (nonatomic, copy) NSString *name;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synthesize和-dynamic分别有什么作用？"><span class="nav-number">2.0.17.</span> <span class="nav-text">@synthesize和@dynamic分别有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。"><span class="nav-number">2.0.18.</span> <span class="nav-text">常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#id声明的对象有什么特性？"><span class="nav-number">2.0.19.</span> <span class="nav-text">id声明的对象有什么特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C如何对内存管理的，说说你的看法和解决办法？"><span class="nav-number">2.0.20.</span> <span class="nav-text">Objective-C如何对内存管理的，说说你的看法和解决办法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？"><span class="nav-number">2.0.21.</span> <span class="nav-text">Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Category-类别-、Extension-扩展-和继承的区别。"><span class="nav-number">2.0.22.</span> <span class="nav-text">Category(类别)、Extension(扩展)和继承的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我们说的OC是动态运行时语言是什么意思？"><span class="nav-number">2.0.23.</span> <span class="nav-text">我们说的OC是动态运行时语言是什么意思？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么我们常见的delegate属性都用是weak而不是retain-strong？"><span class="nav-number">2.0.24.</span> <span class="nav-text">为什么我们常见的delegate属性都用是weak而不是retain/strong？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候共delegate，什么时候用Notification？"><span class="nav-number">2.0.25.</span> <span class="nav-text">什么时候共delegate，什么时候用Notification？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是KVO和KVC？"><span class="nav-number">2.0.26.</span> <span class="nav-text">什么是KVO和KVC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVC的底层实现？"><span class="nav-number">2.0.27.</span> <span class="nav-text">KVC的底层实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVO的底层实现？"><span class="nav-number">2.0.28.</span> <span class="nav-text">KVO的底层实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewController生命周期"><span class="nav-number">2.0.29.</span> <span class="nav-text">ViewController生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法和选择器有何不同？"><span class="nav-number">2.0.30.</span> <span class="nav-text">方法和选择器有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你是否接触过OC中的反射机制？简单聊一下概念和使用"><span class="nav-number">2.0.31.</span> <span class="nav-text">你是否接触过OC中的反射机制？简单聊一下概念和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用方法有两种方式："><span class="nav-number">2.0.32.</span> <span class="nav-text">调用方法有两种方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何对iOS设备进行性能测试？"><span class="nav-number">2.0.33.</span> <span class="nav-text">如何对iOS设备进行性能测试？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开发项目时你是怎么检查内存泄漏？"><span class="nav-number">2.0.34.</span> <span class="nav-text">开发项目时你是怎么检查内存泄漏？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是懒加载？"><span class="nav-number">2.0.35.</span> <span class="nav-text">什么是懒加载？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类变量的-public-protected-private-package声明各有什么含义？"><span class="nav-number">2.0.36.</span> <span class="nav-text">类变量的 @public,@protected,@private,@package声明各有什么含义？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是谓词？"><span class="nav-number">2.0.37.</span> <span class="nav-text">什么是谓词？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isa指针问题"><span class="nav-number">2.0.38.</span> <span class="nav-text">isa指针问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何访问并修改一个类的私有属性？"><span class="nav-number">2.0.39.</span> <span class="nav-text">如何访问并修改一个类的私有属性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个objc对象的isa的指针指向什么？有什么作用？"><span class="nav-number">2.0.40.</span> <span class="nav-text">一个objc对象的isa的指针指向什么？有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下面的代码输出什么？"><span class="nav-number">2.0.41.</span> <span class="nav-text">下面的代码输出什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写一个完整的代理，包括声明、实现"><span class="nav-number">2.0.42.</span> <span class="nav-text">写一个完整的代理，包括声明、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isKindOfClass、isMemberOfClass、selector作用分别是什么？"><span class="nav-number">2.0.43.</span> <span class="nav-text">isKindOfClass、isMemberOfClass、selector作用分别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delegate和notification的区别"><span class="nav-number">2.0.44.</span> <span class="nav-text">delegate和notification的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是block？"><span class="nav-number">2.0.45.</span> <span class="nav-text">什么是block？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#block反向传值"><span class="nav-number">2.0.46.</span> <span class="nav-text">block反向传值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#block的注意点"><span class="nav-number">2.0.47.</span> <span class="nav-text">block的注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BAD-ACCESS在什么情况下出现？"><span class="nav-number">2.0.48.</span> <span class="nav-text">BAD_ACCESS在什么情况下出现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IIdb（gdb）常用的控制台调用命令？"><span class="nav-number">2.0.49.</span> <span class="nav-text">IIdb（gdb）常用的控制台调用命令？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你一般是怎么用Instruments的？"><span class="nav-number">2.0.50.</span> <span class="nav-text">你一般是怎么用Instruments的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS中常用的数据存储方式有哪些？"><span class="nav-number">2.0.51.</span> <span class="nav-text">iOS中常用的数据存储方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS的沙盒目录结构是怎样的？"><span class="nav-number">2.0.52.</span> <span class="nav-text">iOS的沙盒目录结构是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS多线程技术有哪几种方式？"><span class="nav-number">2.0.53.</span> <span class="nav-text">iOS多线程技术有哪几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD与NSOperation的区别"><span class="nav-number">2.0.54.</span> <span class="nav-text">GCD与NSOperation的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写出使用GCD方式从子线程回到主线程的方法代码"><span class="nav-number">2.0.55.</span> <span class="nav-text">写出使用GCD方式从子线程回到主线程的方法代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）"><span class="nav-number">2.0.56.</span> <span class="nav-text">如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-barrier-async-栅栏函数-的作用是什么？"><span class="nav-number">2.0.57.</span> <span class="nav-text">dispatch_barrier_async(栅栏函数)的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以下代码运行结果如何？"><span class="nav-number">2.0.58.</span> <span class="nav-text">以下代码运行结果如何？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是RunLoop"><span class="nav-number">2.0.59.</span> <span class="nav-text">什么是RunLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说说你对runtime的理解"><span class="nav-number">2.0.60.</span> <span class="nav-text">说说你对runtime的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime实现机制是什么，怎么用，一般用于干嘛？"><span class="nav-number">2.0.61.</span> <span class="nav-text">Runtime实现机制是什么，怎么用，一般用于干嘛？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是Method-Swizzle（黑魔法），什么情况下会使用？"><span class="nav-number">2.0.62.</span> <span class="nav-text">什么是Method Swizzle（黑魔法），什么情况下会使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-msgForward函数是做什么的，直接调用它将会发生什么？"><span class="nav-number">2.0.63.</span> <span class="nav-text">_objc_msgForward函数是做什么的，直接调用它将会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是TCP-UDP？"><span class="nav-number">2.0.64.</span> <span class="nav-text">什么是TCP/UDP？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信底层原理（OSI七层模型）"><span class="nav-number">2.0.65.</span> <span class="nav-text">通信底层原理（OSI七层模型）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？"><span class="nav-number">2.0.66.</span> <span class="nav-text">OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tableView的重用机制？"><span class="nav-number">2.0.67.</span> <span class="nav-text">tableView的重用机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用伪代码写一个现成安全的单例模式"><span class="nav-number">2.0.68.</span> <span class="nav-text">用伪代码写一个现成安全的单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现视图的变形？"><span class="nav-number">2.0.69.</span> <span class="nav-text">如何实现视图的变形？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？"><span class="nav-number">2.0.70.</span> <span class="nav-text">在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串常用方法"><span class="nav-number">2.0.71.</span> <span class="nav-text">字符串常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何高性能的给UIImageView加个圆角？"><span class="nav-number">2.0.72.</span> <span class="nav-text">如何高性能的给UIImageView加个圆角？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你是怎么封装一个view的"><span class="nav-number">2.0.73.</span> <span class="nav-text">你是怎么封装一个view的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP协议中POST方法和GET方法有哪些区别？"><span class="nav-number">2.0.74.</span> <span class="nav-text">HTTP协议中POST方法和GET方法有哪些区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请简单的介绍下APNS发送系统消息的机制"><span class="nav-number">2.0.75.</span> <span class="nav-text">请简单的介绍下APNS发送系统消息的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS开发逆向传值的集中方法整理"><span class="nav-number">2.0.76.</span> <span class="nav-text">iOS开发逆向传值的集中方法整理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你使用过Objective-C的运行时编程-Runtime-Programming-么-如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"><span class="nav-number">2.0.77.</span> <span class="nav-text">你使用过Objective-C的运行时编程(Runtime Programming)么?如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）"><span class="nav-number">2.0.78.</span> <span class="nav-text">Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。"><span class="nav-number">2.0.79.</span> <span class="nav-text">是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动释放池是什么，如何工作"><span class="nav-number">2.0.80.</span> <span class="nav-text">自动释放池是什么，如何工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSNotification和KVO的区别和用法是什么-什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate-或者delegate的Array-来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么-虽然protocol和delegate这种东西面试已经面烂了"><span class="nav-number">2.0.81.</span> <span class="nav-text">NSNotification和KVO的区别和用法是什么?什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate(或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么?(虽然protocol和delegate这种东西面试已经面烂了)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）"><span class="nav-number">2.0.82.</span> <span class="nav-text">你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么"><span class="nav-number">2.0.83.</span> <span class="nav-text">既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？"><span class="nav-number">2.0.84.</span> <span class="nav-text">对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。"><span class="nav-number">2.0.85.</span> <span class="nav-text">你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沐凡</span>

  

  
</div>


  



  <div class="powered-by">程序 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> </div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
