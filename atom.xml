<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐凡的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://htmlios.github.io/"/>
  <updated>2018-06-27T10:16:30.132Z</updated>
  <id>http://htmlios.github.io/</id>
  
  <author>
    <name>mufan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS面试题及解答(二)</title>
    <link href="http://htmlios.github.io/2016/07/27/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94-%E4%BA%8C/"/>
    <id>http://htmlios.github.io/2016/07/27/iOS面试题及解答-二/</id>
    <published>2016-07-27T06:33:00.000Z</published>
    <updated>2018-06-27T10:16:30.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h2><h3 id="AFNetworking底层原理分析"><a href="#AFNetworking底层原理分析" class="headerlink" title="AFNetworking底层原理分析"></a>AFNetworking底层原理分析</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">AFNetworking</span>主要是对<span class="selector-tag">NSURLSession</span>和<span class="selector-tag">NSURLConnection</span>(<span class="selector-tag">iOS9</span><span class="selector-class">.0</span>废弃)的封装，其主要有以下类：</span><br><span class="line">1<span class="selector-class">.AFHTTPRequestOperationManager</span>：内部封装的是<span class="selector-tag">NSURLConnection</span>，负责发送网络请求，使用最多的一个类。(3<span class="selector-class">.0</span>废弃)</span><br><span class="line">2<span class="selector-class">.AFHTTPSeesionManager</span>：内部封装的是<span class="selector-tag">NSURLSeesion</span>，负责发送网络请求，使用最多的一个类。</span><br><span class="line">3<span class="selector-class">.AFNetworkingReachabilityManager</span>：实时监测网络状态的工具类。当前的网络环境发生变化之后，这个工具类就可以检测到。</span><br><span class="line">4<span class="selector-class">.AFSecurityPolicy</span>：网络安全的工具类，主要是针对<span class="selector-tag">HTTPS</span>服务。</span><br><span class="line">5<span class="selector-class">.AFURLRequestSerialization</span>：序列化工具类，基类。上传的数据转换成<span class="selector-tag">JSON</span>格式，<span class="selector-tag">AFJSONRequestSerializer</span>使用不多。</span><br><span class="line">6<span class="selector-class">.AFURLResponseSerialization</span>：反序列化工具类；基类，使用比较多。</span><br><span class="line">7<span class="selector-class">.AFJSONResponseSerializer</span>：<span class="selector-tag">JSON</span>解析器，默认的解析器。</span><br><span class="line">8<span class="selector-class">.AFHTTPResponseSerializer</span>：万能解析器，<span class="selector-tag">jSON</span>和<span class="selector-tag">XML</span>之外的数据类型，直接返回二进制数据，对服务器返回的数据不做任何处理。</span><br><span class="line">9<span class="selector-class">.AFXMLParserResponseSerializer</span>：<span class="selector-tag">XML</span>解析器。</span><br></pre></td></tr></table></figure><h3 id="描述下SDWebImage里面给UIImageView加载图片的逻辑"><a href="#描述下SDWebImage里面给UIImageView加载图片的逻辑" class="headerlink" title="描述下SDWebImage里面给UIImageView加载图片的逻辑"></a>描述下SDWebImage里面给UIImageView加载图片的逻辑</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">SDWebImage</span>中为<span class="selector-tag">UIImageView</span>提供了一个分类<span class="selector-tag">UIImageView</span>+<span class="selector-tag">WebCache</span><span class="selector-class">.h</span>，这个分类中有一个最常用的接口<span class="selector-tag">sd_setImageWithURL</span><span class="selector-pseudo">:placeholderImage</span>:,会再真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。</span><br><span class="line">加载图片的过程大致如下：</span><br><span class="line"><span class="selector-tag">1</span>.首先会再<span class="selector-tag">SDWebImageCache</span>中寻找图片是否有对应的缓存，会以<span class="selector-tag">url</span>作为数据的索引先在内存中寻找是否有对应的缓存。</span><br><span class="line"><span class="selector-tag">2</span>.如果缓存中未找到就会利用通过<span class="selector-tag">MD5</span>处理过的<span class="selector-tag">key</span>来继续在磁盘中查询对应的数据，如果找到了，就会把磁盘中的数据加载到内存中，并将图片显示出来。</span><br><span class="line"><span class="selector-tag">3</span>.如果内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片。</span><br><span class="line"><span class="selector-tag">4</span>.下载后的图片会加入缓存中，并写入磁盘中。</span><br><span class="line"><span class="selector-tag">5</span>.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">SDWebImage</span>原理：</span><br><span class="line">调用类别的方法：</span><br><span class="line"><span class="selector-tag">1</span>.从内存(字典)中找图片(当这个图片在本次使用程序的过程中已经被加载过)，找到直接使用。</span><br><span class="line"><span class="selector-tag">2</span>.从沙盒中找(当这个图片在之前使用程序的过程中被加载过)，找到使用，缓存到内存中。</span><br><span class="line"><span class="selector-tag">3</span>.从网络上获取，使用，缓存到内存，缓存到沙盒。</span><br></pre></td></tr></table></figure><h3 id="友盟统计接口统计的所有功能"><a href="#友盟统计接口统计的所有功能" class="headerlink" title="友盟统计接口统计的所有功能"></a>友盟统计接口统计的所有功能</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">APP</span>启动速度，<span class="keyword">APP</span>停留页面时间等</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="不用中间变量，用两种方法交换A和B的值"><a href="#不用中间变量，用两种方法交换A和B的值" class="headerlink" title="不用中间变量，用两种方法交换A和B的值"></a>不用中间变量，用两种方法交换A和B的值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.中间变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.加法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = a - b;</span><br><span class="line">    a = a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.异或(相同为0，不同为1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.直接遍历法</span></span><br><span class="line"><span class="keyword">int</span> maxCommonDivisor(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b; i++) &#123;</span><br><span class="line">        <span class="built_in">if</span> (a % i = <span class="number">0</span> &amp;&amp; b % i = <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">max</span> = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.辗转相除法(扩展：最小公倍数 = (a * b) / 最大公约数)</span></span><br><span class="line"><span class="keyword">int</span> maxCommonDivisor(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="built_in">while</span> (a % b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">选择排序、冒泡排序、插入排序三种排序算法可以总结如下：</span><br><span class="line">都将数组分为已排序部分和未排序部分。</span><br><span class="line"><span class="number">1.</span>选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</span><br><span class="line"><span class="number">2.</span>冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</span><br><span class="line"><span class="number">3.</span>插入排序将已排序部分定义在左端，将未排序部分的第一个元素插入到已排序部分合适的位置。</span><br></pre></td></tr></table></figure><h3 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h3><p>算法思想：遍历待排序的数据，每次比较临近的两个元素，如果他们的排序错误交换两个元素位置，经过一趟排序最大的就会排在最末端。重复操作，直到排序完成。</p><p>示例演示：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一趟排序</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第二趟排序</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第三趟排序</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第五趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr></tbody></table><p>其中第一趟排序过程如下：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一次比较</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第二次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">6</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第三次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">6</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第四次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">6</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第五次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">6</td></tr></tbody></table><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array:待排序数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">array</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法思想：查找待排序数据中最小的一个元素，将它与数组的第一个元素交换位置。然后从剩下的元素中选择一个最小元素，将它与第二个位置的元素交换位置，如果最小元素就是该位置的元素，就将它和自身交换位置，依次类推，直到排序完成。</p><p>示例演示：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一趟排序</td><td style="text-align:right">1</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第二趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第三趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第五趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第六趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr></tbody></table><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array:待排序数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">array</span>.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[min]) &#123;</span><br><span class="line">            min = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[min];</span><br><span class="line">    <span class="built_in">array</span>[min] = <span class="built_in">array</span>[i];</span><br><span class="line">    <span class="built_in">array</span>[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>算法思想：从数组的第二个开始遍历，将该元素依次倒序与前面元素比较，如果该元素比前面的元素小，将该元素保存进临时变量中，依次将前面元素后移，然后将该元素插入到合适的位置。每次排序完成后，索引左边的元素一定是有序的，但是还可以移动。对于倒置越少的数组，该算法排序效率越高。</p><p>示例演示：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一趟排序</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第二趟排序</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第三趟排序</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr></tbody></table><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array:待排序数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[j];</span><br><span class="line">        <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">array</span>[j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 折半查找：优化查找时间(不用遍历全部数据)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 折半查找的原理</span></span><br><span class="line"><span class="comment">*   1.数组必须是有序的</span></span><br><span class="line"><span class="comment">* 2.必须已知min和max(知道范围)</span></span><br><span class="line"><span class="comment">*   3.动态计算mid的值，取出mid对应的值进行比较</span></span><br><span class="line"><span class="comment">*   4.如果mid对应的值大于要查找的值，那么max要变小为mid-1</span></span><br><span class="line"><span class="comment">*   5.如果mid对应的值小于要查找的值，那么min要变大为mid+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 已知一个有序数组，和一个key，要求从数组中找到key对应的索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKey</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> length, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(min &lt;= max) &#123;</span><br><span class="line">        mid = (min + max) / <span class="number">2</span>; <span class="comment">// 计算中间值</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            min = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            max = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它知识点"><a href="#其它知识点" class="headerlink" title="其它知识点"></a>其它知识点</h2><p>1.Homekit，是苹果2014年发布的智能家具平台。</p><p>2.什么是OpenGL、Quartz 2D？</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Quartz <span class="number">2</span>D 是Apple提供的基本图形工具库。只适用于<span class="number">2</span>D图形的绘制。</span><br><span class="line">OpenGL，是一个跨平台的图形开发库，适用于<span class="number">2</span>D和<span class="number">3</span>D图形的绘制。</span><br></pre></td></tr></table></figure><p>3.ffmpeg框架</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg是音视频处理工具，既有音视频编解码功能，又可以作为播放器使用。</span><br></pre></td></tr></table></figure><p>4.谈谈UITableView的优化</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>正确的复用cell;</span><br><span class="line"><span class="number">2.</span>设计统一规格的cell;</span><br><span class="line"><span class="number">3.</span>提前计算并缓存好高度(布局)，因为heightForRowAtIndexPath:是调用最频繁的方法;</span><br><span class="line"><span class="number">4.</span>异步绘制，遇到复杂的界面，遇到性能瓶颈时，可能是突破口。</span><br><span class="line"><span class="number">5.</span>滑动时按需加载，这个在大量图片展示，网络加载的时候很管用。</span><br><span class="line"><span class="number">6.</span>减少子视图的层级关系。</span><br><span class="line"><span class="number">7.</span>尽量使所有的视图不透明化以及切圆操作。</span><br><span class="line"><span class="number">8.</span>不要动态的add或者<span class="comment">remove子控件。最好在初始化就添加完，然后通过hidden来控制是否显示。</span></span><br><span class="line"><span class="number">9.</span>使用调试工具分析问题。</span><br></pre></td></tr></table></figure><p>5.如何实行cell的动态的行高</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">如果希望每条数据显示自身行高，必须设置两个属性，<span class="number">1.</span>预估行高；<span class="number">2.</span>自定义行高。</span><br><span class="line">设置预估行高 tableView.estimatedRowHeight = <span class="number">200</span>;</span><br><span class="line">设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension;</span><br><span class="line">如果要让自定义行高有效，必须让容器视图有一个自上而下的约束。</span><br></pre></td></tr></table></figure><p>6.什么是野指针、空指针？</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">野指针：不知道指向了哪里的指针叫野指针。即指针指向不明确，指针存在的地址是一个垃圾值，未初始化。</span><br><span class="line">空指针：不指向任何位置的指针叫空指针。即指针没有指向，指针存的地址是一个空地址，<span class="literal">NULL</span>。</span><br></pre></td></tr></table></figure><p>7.什么是OOA/OOD/OOP？</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">OOA</span><span class="params">(Object Oriented Analysis)</span></span>--面向对象分析</span><br><span class="line"><span class="function"><span class="title">OOD</span><span class="params">(Object Oriented Design)</span></span> -- 面向对象设计</span><br><span class="line"><span class="function"><span class="title">OOP</span><span class="params">(Object Oriented Programming)</span></span> -- 面向对象编程</span><br></pre></td></tr></table></figure><p>8.多线程是什么？</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">多线程是个复杂的概念，按字面意思是同步完成多项任务，提高了资源的使用效率，从硬件、操作系统、应用软件不同的角度去看，多线程被赋予不同的内涵；</span><br><span class="line">对于硬件，现在市面上多数的<span class="meta">CPU</span>都是多核的，多核的<span class="meta">CPU</span>运算多线程更为出色；</span><br><span class="line">从操作系统角度，是多任务，现在用的主流操作系统都是多任务的，可以一边听歌，一边写博客；</span><br><span class="line">对于应用来说，多线程可以让应用更快的回应，可以在网络下载时，同时响应用户的触摸操作。</span><br><span class="line">在iOS应用中，多线程最初的理解，就是并发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成烧水的同时去摘菜，最后去炒菜。</span><br></pre></td></tr></table></figure><p>9.iOS中的多线程</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更为方便的使用多线程，做过C</span><span class="literal">+</span><span class="literal">+</span><span class="comment">的同学可能会对线程有更多的理解，比如线程的创立，信号量，共享变量有认识，Cocoa框架下会更方便，它对线程做了封装，有些封装，可以让我们创建的对象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提供程序的健壮性。</span></span><br></pre></td></tr></table></figure><p>10.static关键字的作用</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在函数体内定义的static他的作用域就是该函数体，该变量在内存中只被分配一次内存，因此，其值在下次调用的时候仍是上次的值不变。</span><br><span class="line"><span class="number">2.</span>在模块内的static全局变量可以被模块内所有函数访问，但是不能被外部模块的其他函数访问。</span><br><span class="line"><span class="number">3.</span>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝，也就是说只要是该类的对象，那么该对象中被static修饰的成员变量都指向同一地址。</span><br><span class="line"><span class="number">4.</span>修饰局部变量：</span><br><span class="line">  延长局部变量的生命周期，程序结束才会销毁。</span><br><span class="line">  局部变量只会生成一份内存，只会初始化一次。</span><br><span class="line">  改变局部变量的作用域。</span><br><span class="line"><span class="number">5.</span>修饰全局变量：</span><br><span class="line">  只能在本文件中访问，修改全局变量的作用域，声明周期不会改。</span><br><span class="line">  避免重复定义全局变量。</span><br><span class="line"><span class="number">6.</span>在OC中static关键字使用误区</span><br><span class="line">  <span class="number">1.</span>使用static修饰实例变量是不被允许的。</span><br><span class="line">  <span class="number">2.</span>使用static修饰了方法，也是错误的。</span><br></pre></td></tr></table></figure><h3 id="使用Swift语言编程的优缺点"><a href="#使用Swift语言编程的优缺点" class="headerlink" title="使用Swift语言编程的优缺点"></a>使用Swift语言编程的优缺点</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">总的来说，我认为使用Swift来作为编程语言的有点还是远远大于缺点的，而且很多缺点苹果也在逐渐改善。</span><br><span class="line">优点：</span><br><span class="line"><span class="number">1.</span>简洁的语法</span><br><span class="line"><span class="number">2.</span>更强的类型安全</span><br><span class="line"><span class="number">3.</span>函数式编程的支持</span><br><span class="line">  Swift语言本身提供了对函数式编程的支持。</span><br><span class="line">  Objc本身是不支持的，但是可以通过引入ReactiveCocoa这个库来支持函数式编程。</span><br><span class="line"><span class="number">4.</span>编写OSX下的自动化脚本</span><br><span class="line">缺点：</span><br><span class="line"><span class="number">1.</span>App体积变大</span><br><span class="line">  使用Swift后，App体积大概增加<span class="number">5</span><span class="number">-8</span>M左右，对体积大小敏感的慎用。</span><br><span class="line">  体积变大的原因是因为Swift还在变化，所以Apple没有在iOS系统里放入Swift的运行库，反而是每个App里都要包含其对应的Swift运行库。</span><br><span class="line"><span class="number">2.</span>Xcode支持不够好</span><br><span class="line">  如果你是使用Xcode经常卡住或者崩溃想必你肯定碰到过了，这个是目前使用Swift最让人头疼的事情，即使是到现在Xcode9，有时候也会偶尔遇到这种问题，所以要看你的承受力了。。。</span><br><span class="line"><span class="number">3.</span>第三方库的支持不够多</span><br><span class="line">  目前确实Swift编写的第三方库不多，但可以通过桥接的方式来使用Objc的第三方库，基本上没有太大问题。现在已经改善很多了。</span><br><span class="line"><span class="number">4.</span>怨言版本更新带来的编译问题</span><br><span class="line">  语言本身还在发展，所以每次版本更新后都会出现编译不过的情况(至少到目前为止还是)，但是自从<span class="number">4.0</span>版本发布后，改动没有beta时候那么大了，而且根据Xcode提示基本就可以解决语法变动导致的编译问题了。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三方框架&quot;&gt;&lt;a href=&quot;#第三方框架&quot; class=&quot;headerlink&quot; title=&quot;第三方框架&quot;&gt;&lt;/a&gt;第三方框架&lt;/h2&gt;&lt;h3 id=&quot;AFNetworking底层原理分析&quot;&gt;&lt;a href=&quot;#AFNetworking底层原理分析&quot; cla
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题及解答</title>
    <link href="http://htmlios.github.io/2016/07/26/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94/"/>
    <id>http://htmlios.github.io/2016/07/26/iOS面试题及解答/</id>
    <published>2016-07-25T18:17:00.000Z</published>
    <updated>2018-06-27T06:25:36.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h1><p>最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="设计模式是什么？你知道哪些设计模式，并简要叙述。"><a href="#设计模式是什么？你知道哪些设计模式，并简要叙述。" class="headerlink" title="设计模式是什么？你知道哪些设计模式，并简要叙述。"></a>设计模式是什么？你知道哪些设计模式，并简要叙述。</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情，常用常见到的设计模式有以下几种。</span><br><span class="line"><span class="number">1.</span>MVC：Model View Controller，模型 视图 控制器解耦合。</span><br><span class="line"><span class="number">2.</span>MVVM：Model View ViewModel，模型 视图 业务逻辑 解耦合。</span><br><span class="line"><span class="number">3.</span>单例：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。</span><br><span class="line"><span class="number">4.</span>观察者：KVO是典型的观察者，观察某个属性的状态，状态发生变化时通知观察者。</span><br><span class="line"><span class="number">5.</span>委托：代理+协议的组合。实现<span class="number">1</span>对<span class="number">1</span>的反向传值操作。</span><br><span class="line"><span class="number">6.</span>工厂：通过一个类方法，批量的根据已有模板生产对象。</span><br></pre></td></tr></table></figure><h3 id="MVC和MVVM的区别是什么？"><a href="#MVC和MVVM的区别是什么？" class="headerlink" title="MVC和MVVM的区别是什么？"></a>MVC和MVVM的区别是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。</span><br><span class="line">MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。</span><br></pre></td></tr></table></figure><h3 id="import跟-include有什么区别，-class呢，-import-lt-gt-跟-import-quot-quot-有什么区别？"><a href="#import跟-include有什么区别，-class呢，-import-lt-gt-跟-import-quot-quot-有什么区别？" class="headerlink" title="#import跟#include有什么区别，@class呢，#import&lt;&gt;跟#import &quot;&quot;有什么区别？"></a><code>#import</code>跟<code>#include</code>有什么区别，<code>@class</code>呢，<code>#import&lt;&gt;</code>跟<code>#import &quot;&quot;</code>有什么区别？</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>#<span class="keyword">import</span>是Object-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#<span class="keyword">import</span>头文件会自动只导入一次，不会重复导入。</span><br><span class="line"><span class="number">2.</span>@<span class="keyword">class</span>告诉编译器某个类的声明，当执行时，才会去查看类的实现文件，可以解决头文件的相互包含。</span><br><span class="line"><span class="number">3.</span>#<span class="keyword">import</span>&lt;&gt;用来包含系统的头文件，#<span class="keyword">import</span> <span class="string">""</span>用来包含用户头文件。</span><br></pre></td></tr></table></figure><h3 id="frame和bounds有什么不同？"><a href="#frame和bounds有什么不同？" class="headerlink" title="frame和bounds有什么不同？"></a><code>frame</code>和<code>bounds</code>有什么不同？</h3><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">frame指的是该<span class="keyword">view</span>在父<span class="keyword">view</span>坐标系中的位置和大小，参考点是父<span class="keyword">view</span>的坐标系。</span><br><span class="line">bounds指的是该<span class="keyword">view</span>在本身坐标系统中的位置和大小，参考点是本身坐标系。</span><br></pre></td></tr></table></figure><h3 id="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？"><a href="#Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？" class="headerlink" title="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？"></a>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">Objective-<span class="keyword">C</span>的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</span><br></pre></td></tr></table></figure><h3 id="property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"><a href="#property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？" class="headerlink" title="@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"></a><code>@property</code>的本质是什么？<code>ivar</code>、<code>getter</code>、<code>setter</code>是如何生成并添加到这个类中的？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">property</span> = ivar + getter + setter;</span><br><span class="line">“属性”(<span class="keyword">property</span>)有两大概念：ivar（实例变量）、getter + setter（存取方法）；</span><br><span class="line">”属性“(<span class="keyword">property</span>)作为Objective-C的一项特性，主要的作用就在于封装对象中的数据。Objective-C对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过”存取方法“(access <span class="function"><span class="keyword">method</span>)来访问。其中”获取方法“<span class="params">(getter)</span>用于读取变量值，而”设置方法“<span class="params">(setter)</span>用于写入变量值。</span></span><br></pre></td></tr></table></figure><h3 id="property中有哪些属性关键字？"><a href="#property中有哪些属性关键字？" class="headerlink" title="@property中有哪些属性关键字？"></a><code>@property</code>中有哪些属性关键字？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">属性可以拥有的特质分为四类：</span><br><span class="line"><span class="number">1.</span>原子性：<span class="keyword">nonatomic</span>特质</span><br><span class="line"><span class="number">2.</span>读/写权限：<span class="keyword">readwrite</span>（读写）、<span class="keyword">readonly</span>（只读）</span><br><span class="line"><span class="number">3.</span>内存管理语义：<span class="keyword">assign</span>、<span class="keyword">strong</span>、<span class="keyword">weak</span>、<span class="keyword">unsafe_unretained</span>、<span class="keyword">copy</span></span><br><span class="line"><span class="number">4.</span>方法名：<span class="keyword">getter</span>、<span class="keyword">setter</span></span><br><span class="line"><span class="number">5.</span>不常用的：<span class="keyword">nonnull</span>、<span class="keyword">null_resettable</span>、<span class="keyword">nullable</span></span><br></pre></td></tr></table></figure><h3 id="属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？"><a href="#属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？" class="headerlink" title="属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？"></a>属性关键字<code>readwrite</code>、<code>readonly</code>、<code>assign</code>、<code>retain</code>、<code>copy</code>、<code>nonatomic</code>各是什么作用，在哪种情况下用？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">readwrite</span>：可读可写特性。需要生成<span class="keyword">getter</span>和<span class="keyword">setter</span>方法。</span><br><span class="line"><span class="number">2.</span><span class="keyword">readonly</span>：只读特性。只会生成<span class="keyword">getter</span>方法，不会生成<span class="keyword">setter</span>方法，不希望属性在类外改变。</span><br><span class="line"><span class="number">3.</span><span class="keyword">assign</span>：赋值属性。<span class="keyword">setter</span>方法将传入参数赋值给实例变量；仅设置变量时，<span class="keyword">assign</span>用于基本数据类型(如<span class="built_in">NSInteger</span>、<span class="built_in">CGFloat</span>、<span class="built_in">CGRect</span>...)。</span><br><span class="line"><span class="number">4.</span><span class="keyword">retain</span>(MRC)/<span class="keyword">strong</span>(ARC)：表示持有特性。<span class="keyword">setter</span>方法将传入值先保留，再赋值，传入参数的retaincount会+<span class="number">1</span>。</span><br><span class="line"><span class="number">5.</span><span class="keyword">copy</span>：表示拷贝特性。<span class="keyword">setter</span>方法将传入对象复制一份，需要完全一份新的变量时。</span><br><span class="line"><span class="number">6.</span><span class="keyword">nonatomic</span>：非原子操作。不写的话就默认是atomic。atomic和<span class="keyword">nonatomic</span>的区别在于，系统自动生成<span class="keyword">getter</span>/<span class="keyword">setter</span>方法不一样。对于atomic属性，系统生成的<span class="keyword">getter</span>/<span class="keyword">setter</span>会保证get、set操作的完整性，而<span class="keyword">nonatomic</span>就没有这个保证了。所以，<span class="keyword">nonatomic</span>的速度要比atomic快。不过atomic可并不能保证现成安全（<span class="keyword">nonatomic</span>是非多线程下的，atomic是多线程下的）。</span><br></pre></td></tr></table></figure><h3 id="什么情况使用weak关键字，相比assign有什么不同？"><a href="#什么情况使用weak关键字，相比assign有什么不同？" class="headerlink" title="什么情况使用weak关键字，相比assign有什么不同？"></a>什么情况使用weak关键字，相比assign有什么不同？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用<span class="keyword">weak</span>来解决，比如delegate属性。</span><br><span class="line"><span class="number">2.</span>自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用<span class="keyword">weak</span>，自定义IBOutLet控件属性一般使用<span class="keyword">weak</span>，当然也可以使用<span class="keyword">strong</span>。</span><br><span class="line"><span class="keyword">IBOutlet</span>连出来的视图属性为什么可以被设置成<span class="keyword">weak</span>？</span><br><span class="line">因为父控件的subViews数组已经对它有一个强引用。</span><br><span class="line">不同点：</span><br><span class="line"><span class="keyword">assign</span>可以用非OC对象，而<span class="keyword">weak</span>必须用于OC对象。</span><br><span class="line"><span class="keyword">weak</span>表明该属性定义了一种”非拥有关系“。在属性所指的对象销毁时，属性值会自动清空(<span class="literal">nil</span>)。</span><br></pre></td></tr></table></figure><h3 id="怎么用copy关键字？"><a href="#怎么用copy关键字？" class="headerlink" title="怎么用copy关键字？"></a>怎么用<code>copy</code>关键字？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">用途：</span><br><span class="line"><span class="number">1.</span><span class="built_in">NSString</span>、<span class="built_in">NSArray</span>、<span class="built_in">NSDictionary</span>等等经常使用<span class="keyword">copy</span>关键字，是因为他们又对应的可变类型：<span class="built_in">NSMutableString</span>、<span class="built_in">NSMutableArray</span>、<span class="built_in">NSMutableDictionary</span>；</span><br><span class="line"><span class="number">2.</span>block也经常使用<span class="keyword">copy</span>关键字。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">block使用<span class="keyword">copy</span>是从MRC遗留下来的”传统“，在MRC中，方法内部的block实在栈区的，使用<span class="keyword">copy</span>可以把它放到堆区；在ARC中写不写都行；</span><br></pre></td></tr></table></figure><h3 id="用-property声明的NSString-NSArray-NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？"><a href="#用-property声明的NSString-NSArray-NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？" class="headerlink" title="用@property声明的NSString/NSArray/NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？"></a>用<code>@property</code>声明的NSString/NSArray/NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">用@Property声明<span class="built_in">NSString</span>、<span class="built_in">NSArray</span>、<span class="built_in">NSDictionary</span>经常使用<span class="keyword">copy</span>关键字，是因为他们有对应的可变类型：<span class="built_in">NSMutableString</span>、<span class="built_in">NSMutableArray</span>、<span class="built_in">NSMutableDictionary</span>，他们之间可能进行赋值操作(把可变的赋值给不可变的)，为确保对象中的字符串值不会无意间变动，应该设置新属性时拷贝一份。</span><br><span class="line"><span class="number">1.</span>因为父类指针可以指向子类对象，使用<span class="keyword">copy</span>的目的是为了让本对象的属性不受外界影响，使用<span class="keyword">copy</span>无论给我传入是一个可变对象还是不可变对象，我本身持有的就是一个不可变的副本。</span><br><span class="line"><span class="number">2.</span>如果我们使用的是<span class="keyword">strong</span>，那么这个属性就有可能指向一个可变对象，如果这个可变对象被修改了，那么会影响该属性。</span><br><span class="line">总结：使用<span class="keyword">copy</span>的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发生变化会无意间篡改不可变类型对象原来的值。</span><br></pre></td></tr></table></figure><h3 id="浅拷贝和深拷贝的区别？"><a href="#浅拷贝和深拷贝的区别？" class="headerlink" title="浅拷贝和深拷贝的区别？"></a>浅拷贝和深拷贝的区别？</h3><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">浅拷贝：只复制指向对象的指针，而不复制引用对象本身。</span><br><span class="line">深拷贝：复制引用对象本身。内存中存在了两份独立的对象本身，当修改<span class="literal">A</span>时，<span class="built_in">A_copy</span>不变。</span><br></pre></td></tr></table></figure><h3 id="系统对象的copy与mutableCopy方法"><a href="#系统对象的copy与mutableCopy方法" class="headerlink" title="系统对象的copy与mutableCopy方法"></a>系统对象的<code>copy</code>与<code>mutableCopy</code>方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不管是集合类对象(NSArray、NSDictionary、NSSet...之类的对象)，还是非集合类对象(NSString、NSNumber...之类的对象)，接收到copy和mutableCopy消息时，都遵循以下准则：</span><br><span class="line">1.copy返回的是不可变对象(immuatableObject)；如果用copy返回值调用mutable对象的方法就会crash。</span><br><span class="line">2.mutableCopy返回的是可变对象(mutableObject)。</span><br><span class="line">总结一句话：只有对不可变对象进行copy操作是指针复制(浅复制)，其他情况都是内容复制(深复制)！</span><br></pre></td></tr></table></figure><h3 id="这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-array"><a href="#这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-array" class="headerlink" title="这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *array;"></a>这个写法会出什么问题：<code>@property (nonatomic, copy) NSMutableArray *array;</code></h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">问题：添加，删除，修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃。</span><br><span class="line">原因：是因为<span class="keyword">copy</span>就是复制一个不可变<span class="built_in">NSArray</span>的对象，不能对<span class="built_in">NSArray</span>对象进行添加/修改。</span><br></pre></td></tr></table></figure><h3 id="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"><a href="#如何让自己的类用copy修饰符？如何重写带copy关键字的setter？" class="headerlink" title="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"></a>如何让自己的类用<code>copy</code>修饰符？如何重写带<code>copy</code>关键字的<code>setter</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本和不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。</span><br><span class="line">具体步骤：</span><br><span class="line">1.需声明该类遵从NSCopying协议。</span><br><span class="line">2.实现NSCopying协议的方法。</span><br><span class="line">// 该协议只有一个方法：</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone;</span><br><span class="line">// 注意：使用copy修饰符，调用的是copy方法，其实真正需要实现的是&quot;copyWithZone&quot;方法。</span><br></pre></td></tr></table></figure><h3 id="写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic-copy-NSString-name"><a href="#写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic-copy-NSString-name" class="headerlink" title="写一个setter方法用于完成@property (nonatomic, retain) NSString *name; 写一个setter方法用于完成@property (nonatomic, copy) NSString *name;"></a>写一个setter方法用于完成<code>@property (nonatomic, retain) NSString *name;</code> 写一个setter方法用于完成<code>@property (nonatomic, copy) NSString *name;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// retain</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    [name retain];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// copy</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    id t = [name copy];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synthesize和-dynamic分别有什么作用？"><a href="#synthesize和-dynamic分别有什么作用？" class="headerlink" title="@synthesize和@dynamic分别有什么作用？"></a><code>@synthesize</code>和<code>@dynamic</code>分别有什么作用？</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@property</span>有两个对应的词，一个是<span class="variable">@synthesize</span>(合成实例变量)，一个是<span class="variable">@dynamic</span>。</span><br><span class="line">如果<span class="variable">@synthesize</span>和<span class="variable">@dynamic</span>都没有写，那么默认的就是<span class="variable">@synthesize</span> var = _var;</span><br><span class="line"><span class="comment">// 在类的实现代码里通过@synthesize语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</span></span><br><span class="line"><span class="selector-tag">1</span>.@<span class="selector-tag">synthesize</span>的语义是如果你没有手动实现<span class="selector-tag">setter</span>和<span class="selector-tag">getter</span>方法，那么编译器会自动为你加上这两个方法。</span><br><span class="line"><span class="selector-tag">2</span>.@<span class="selector-tag">dynamic</span>告诉编译器，属性的<span class="selector-tag">setter</span>与<span class="selector-tag">getter</span>方法由用户自己实现，不自动生成(如<span class="variable">@dynamic</span> var)。</span><br></pre></td></tr></table></figure><h3 id="常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。"><a href="#常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。" class="headerlink" title="常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。"></a>常见的<code>Objective-C</code>的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Objective-C的数据类型有<span class="built_in">NSString</span>，<span class="built_in">NSNumber</span>，<span class="built_in">NSArray</span>，<span class="built_in">NSMutableArray</span>，<span class="built_in">NSData</span>等等，这些都是<span class="keyword">class</span>，创建后便是对象，而C语言的基本数据类型<span class="keyword">int</span>，只是一定字节的内存空间，用于存放数值；<span class="built_in">NSInteger</span>是基本数据类型，并不是<span class="built_in">NSNumber</span>的子类，当然也不是<span class="built_in">NSObject</span>的子类。<span class="built_in">NSInteger</span>是基本数据类型<span class="keyword">int</span>或者<span class="keyword">long</span>的别名(<span class="built_in">NSInteger</span>的定义<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="built_in">NSInteger</span>)，它的区别在于，<span class="built_in">NSInteger</span>会根据系统是<span class="number">32</span>位还是<span class="number">64</span>位来决定本身是<span class="keyword">int</span>还是<span class="keyword">long</span>。</span><br></pre></td></tr></table></figure><h3 id="id声明的对象有什么特性？"><a href="#id声明的对象有什么特性？" class="headerlink" title="id声明的对象有什么特性？"></a><code>id</code>声明的对象有什么特性？</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>声明的对象具有运动时的特性，即可以指向任意类型的Objective-C的对象。</span><br></pre></td></tr></table></figure><h3 id="Objective-C如何对内存管理的，说说你的看法和解决办法？"><a href="#Objective-C如何对内存管理的，说说你的看法和解决办法？" class="headerlink" title="Objective-C如何对内存管理的，说说你的看法和解决办法？"></a><code>Objective-C</code>如何对内存管理的，说说你的看法和解决办法？</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</span><br><span class="line"><span class="number">1.</span>自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。</span><br><span class="line"><span class="number">2.</span>手动内存计数MRC：遵循内存谁申请、谁释放；谁添加、谁释放的原则。</span><br><span class="line"><span class="number">3.</span>内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</span><br></pre></td></tr></table></figure><h3 id="Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？"><a href="#Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？" class="headerlink" title="Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？"></a><code>Objective-C</code>中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">线程的创建有三种方法：使用<span class="selector-tag">NSThread</span>创建、使用<span class="selector-tag">GCD</span>的<span class="selector-tag">dispatch</span>、使用子类的<span class="selector-tag">NSOPeration</span>，然后将其加入<span class="selector-tag">NSOperationQueue</span>；在主线程执行代码，方法是<span class="selector-tag">performSelectorOnMainThread</span>，如果想延迟执行代码可以用<span class="selector-tag">performSelector</span><span class="selector-pseudo">:onThread</span><span class="selector-pseudo">:withObject</span><span class="selector-pseudo">:waitUntilDone</span>;</span><br></pre></td></tr></table></figure><h3 id="Category-类别-、Extension-扩展-和继承的区别。"><a href="#Category-类别-、Extension-扩展-和继承的区别。" class="headerlink" title="Category(类别)、Extension(扩展)和继承的区别。"></a><code>Category</code>(类别)、<code>Extension</code>(扩展)和继承的区别。</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">区别：</span><br><span class="line"><span class="number">1.</span>分类有名字，类扩展没有分类名字，是一种特殊的分类。</span><br><span class="line"><span class="number">2.</span>分类只能扩展方法(属性仅仅是声明，并没有真正实现)，类扩展可以扩展属性、成员变量和方法。</span><br><span class="line"><span class="number">3.</span>继承可以增加，修改或者删除方法，并且可以增加属性。</span><br></pre></td></tr></table></figure><h3 id="我们说的OC是动态运行时语言是什么意思？"><a href="#我们说的OC是动态运行时语言是什么意思？" class="headerlink" title="我们说的OC是动态运行时语言是什么意思？"></a>我们说的<code>OC</code>是动态运行时语言是什么意思？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主要是讲数据类型的确定由编译时，推迟到了运行时。简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</span><br></pre></td></tr></table></figure><h3 id="为什么我们常见的delegate属性都用是weak而不是retain-strong？"><a href="#为什么我们常见的delegate属性都用是weak而不是retain-strong？" class="headerlink" title="为什么我们常见的delegate属性都用是weak而不是retain/strong？"></a>为什么我们常见的<code>delegate</code>属性都用是<code>weak</code>而不是<code>retain</code>/<code>strong</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是为了防止delegate两端产生不必要的循环引用。</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br></pre></td></tr></table></figure><h3 id="什么时候共delegate，什么时候用Notification？"><a href="#什么时候共delegate，什么时候用Notification？" class="headerlink" title="什么时候共delegate，什么时候用Notification？"></a>什么时候共<code>delegate</code>，什么时候用<code>Notification</code>？</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Delegate</span><span class="params">(委托模式)</span></span>：<span class="number">1</span>对<span class="number">1</span>的反向消息通知功能。</span><br><span class="line"><span class="function"><span class="title">Notification</span><span class="params">(通知模式)</span></span>：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</span><br></pre></td></tr></table></figure><h3 id="什么是KVO和KVC？"><a href="#什么是KVO和KVC？" class="headerlink" title="什么是KVO和KVC？"></a>什么是<code>KVO</code>和<code>KVC</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.KVC(Key-Value-Coding)：键值编码，是一种通过字符串间接访问对象的方式(即给属性赋值)。</span><br><span class="line">举例说明：</span><br><span class="line">stu.name = @&quot;张三&quot;;// 点语法给属性赋值</span><br><span class="line">[stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;];// 通过字符串使用KVC方式给属性赋值</span><br><span class="line">2.KVO(Key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大简化了代码。</span><br><span class="line">KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。</span><br><span class="line">// 通过下方方法为属性添加KVO观察</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line"></span><br><span class="line">// 当被观察的属性发生变化时，会自动触发下方方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</span><br><span class="line"></span><br><span class="line">KVC和KVO的keyPath可以是属性、实例变量、成员变量。</span><br></pre></td></tr></table></figure><h3 id="KVC的底层实现？"><a href="#KVC的底层实现？" class="headerlink" title="KVC的底层实现？"></a><code>KVC</code>的底层实现？</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">当一个对象调用<span class="built_in">set</span>Value方法时，方法内部会做以下操作：</span><br><span class="line"><span class="number">1</span>.检查是否存在相应的key的<span class="built_in">set</span>方法，如果存在，就调用<span class="built_in">set</span>方法。</span><br><span class="line"><span class="number">2</span>.如果<span class="built_in">set</span>方法不存在，就会查找与key相同名称并且带有下划线的成员变量，如果有，则直接给成员变量赋值。</span><br><span class="line"><span class="number">3</span>.如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</span><br><span class="line"><span class="number">4</span>.如果还没有找到，则调用valueForUndefinedKey:和<span class="built_in">set</span>Value:<span class="keyword">for</span>UndeinedKey:方法。</span><br><span class="line">这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</span><br></pre></td></tr></table></figure><h3 id="KVO的底层实现？"><a href="#KVO的底层实现？" class="headerlink" title="KVO的底层实现？"></a><code>KVO</code>的底层实现？</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">KVO基于<span class="keyword">runtime</span>机制实现。</span><br></pre></td></tr></table></figure><h3 id="ViewController生命周期"><a href="#ViewController生命周期" class="headerlink" title="ViewController生命周期"></a><code>ViewController</code>生命周期</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">按照执行顺序排列：</span><br><span class="line"><span class="number">1</span><span class="selector-class">.initWithCoder</span>: 通过nib文件初始化时触发。</span><br><span class="line"><span class="number">2</span><span class="selector-class">.awakeFromNib</span>: nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。</span><br><span class="line"><span class="number">3</span><span class="selector-class">.loadView</span>: 开始加载视图控制器自带的view。</span><br><span class="line"><span class="number">4</span><span class="selector-class">.viewDidLoad</span>: 视图控制器的view被加载完成。</span><br><span class="line"><span class="number">5</span><span class="selector-class">.viewWillAppear</span>: 视图控制器的view将要显示在window上。</span><br><span class="line"><span class="number">6</span><span class="selector-class">.updateViewConstraints</span>: 视图控制器的view开始更新AutoLayout约束。</span><br><span class="line"><span class="number">7</span><span class="selector-class">.viewWillLayoutSubviews</span>: 视图控制器的view将要更新内容视图的位置。</span><br><span class="line"><span class="number">8</span><span class="selector-class">.viewDidLayoutSubviews</span>: 视图控制器的view已经更新视图的位置。</span><br><span class="line"><span class="number">9</span><span class="selector-class">.viewDidApear</span>: 试图控制器的view已经展示到window上。</span><br><span class="line"><span class="number">10</span><span class="selector-class">.viewWillDisappear</span>: 视图控制器的view将要从window上消失。</span><br><span class="line"><span class="number">11</span><span class="selector-class">.viewDidDisappear</span>: 视图控制器的view已经从window上消失。</span><br></pre></td></tr></table></figure><h3 id="方法和选择器有何不同？"><a href="#方法和选择器有何不同？" class="headerlink" title="方法和选择器有何不同？"></a>方法和选择器有何不同？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">selector</span>是一个方法的名字，方法是一个组合体，包含了名字和实现。</span><br></pre></td></tr></table></figure><h3 id="你是否接触过OC中的反射机制？简单聊一下概念和使用"><a href="#你是否接触过OC中的反射机制？简单聊一下概念和使用" class="headerlink" title="你是否接触过OC中的反射机制？简单聊一下概念和使用"></a>你是否接触过<code>OC</code>中的反射机制？简单聊一下概念和使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.class反射</span><br><span class="line">通过类名的字符串形式实例化对象。</span><br><span class="line">Class class = NSCalssFromString(@&quot;student&quot;);</span><br><span class="line">Student *stu = [[class alloc] init];</span><br><span class="line">将类名变为字符串。</span><br><span class="line">Class class = [Student class];</span><br><span class="line">NSString className = NSStringFromClass(class);</span><br><span class="line">2.SEL的反射</span><br><span class="line">通过方法的字符串形式实例化方法。</span><br><span class="line">SEL selector = NSSelectorFrom(@&quot;setName&quot;);</span><br><span class="line">[stu performSelector:selector withObject:@&quot;Mike&quot;];</span><br><span class="line">将方法变成字符串。</span><br><span class="line">NSStringFromSelector(@selector(setName:));</span><br></pre></td></tr></table></figure><h3 id="调用方法有两种方式："><a href="#调用方法有两种方式：" class="headerlink" title="调用方法有两种方式："></a>调用方法有两种方式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.直接通过方法名来调用。</span><br><span class="line">[person show];</span><br><span class="line">2.间接的通过SEL数据来调用。</span><br><span class="line">SEL aaa = @selector(show); </span><br><span class="line">[person performSelector:aaa];</span><br></pre></td></tr></table></figure><h3 id="如何对iOS设备进行性能测试？"><a href="#如何对iOS设备进行性能测试？" class="headerlink" title="如何对iOS设备进行性能测试？"></a>如何对iOS设备进行性能测试？</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">P<span class="function"><span class="title">rofile</span>-&gt;</span>I<span class="function"><span class="title">nstruments</span>-&gt;</span>Time Profiler</span><br></pre></td></tr></table></figure><h3 id="开发项目时你是怎么检查内存泄漏？"><a href="#开发项目时你是怎么检查内存泄漏？" class="headerlink" title="开发项目时你是怎么检查内存泄漏？"></a>开发项目时你是怎么检查内存泄漏？</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>静态分析analyze。</span><br><span class="line"><span class="number">2.</span>instruments工具里面有个leak可以动态分析。</span><br></pre></td></tr></table></figure><h3 id="什么是懒加载？"><a href="#什么是懒加载？" class="headerlink" title="什么是懒加载？"></a>什么是懒加载？</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。</span><br><span class="line">我觉得最好也最简单的一个例子就是<span class="built_in">table</span>View中的图片的加载显示，一个延时加载，避免内存过高，一个异步加载，避免线程堵塞提高用户体验。</span><br></pre></td></tr></table></figure><h3 id="类变量的-public-protected-private-package声明各有什么含义？"><a href="#类变量的-public-protected-private-package声明各有什么含义？" class="headerlink" title="类变量的 @public,@protected,@private,@package声明各有什么含义？"></a>类变量的 <code>@public</code>,<code>@protected</code>,<code>@private</code>,<code>@package</code>声明各有什么含义？</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@public</span> 任何地方都能访问；</span><br><span class="line"><span class="variable">@protected</span> 该类和子类中访问，是默认的；</span><br><span class="line"><span class="variable">@private</span> 只能在本类中访问；</span><br><span class="line"><span class="variable">@package</span> 本包内使用，跨包不可以。</span><br></pre></td></tr></table></figure><h3 id="什么是谓词？"><a href="#什么是谓词？" class="headerlink" title="什么是谓词？"></a>什么是谓词？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">谓词就是通过<span class="built_in">NSPredicate</span>给定的逻辑条件作为约束条件，完成对数据的筛选。</span><br><span class="line"><span class="comment">// 定义谓词对象，谓词对象中包含了过滤条件(过滤条件比较多)</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormate:<span class="string">@"age &lt; %d"</span>, <span class="number">30</span>];</span><br><span class="line"><span class="comment">// 使用谓词条件过滤数组中的元素，过滤之后返回查询结果</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [persons filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure><h3 id="isa指针问题"><a href="#isa指针问题" class="headerlink" title="isa指针问题"></a><code>isa</code>指针问题</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">isa：是一个Class类型的指针。每个实例对象有个isa的指针，他指向对象的类，而Class里也有个isa的指针，指向meteClass<span class="comment">(元类)</span>。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现。如果没有，元类会向他父类查找该方法。同时注意的是：元类<span class="comment">(meteClass)</span>也是类，它也是对象。元类也有isa指针，它的isa指针最终指向的是根元类<span class="comment">(root meteClass)</span>。根元类的isa指针指向本身，这样形成了一个闭环的内循环。</span><br></pre></td></tr></table></figure><h3 id="如何访问并修改一个类的私有属性？"><a href="#如何访问并修改一个类的私有属性？" class="headerlink" title="如何访问并修改一个类的私有属性？"></a>如何访问并修改一个类的私有属性？</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一种是通过KVC获取。</span><br><span class="line"><span class="number">2.</span>通过runtime访问并修改私有属性。</span><br></pre></td></tr></table></figure><h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个<code>objc</code>对象的<code>isa</code>的指针指向什么？有什么作用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指向他的类对象，从而可以找到对象上的方法。</span><br></pre></td></tr></table></figure><h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// 解析：</span><br><span class="line">self是类的隐藏参数，指向当前调用方法的这个类的实例。</span><br><span class="line">super是一个Magic Keyword，它本质是一个编译标识符，和self是指向的同一个消息接收者。</span><br><span class="line">不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。</span><br><span class="line">上面的例子不管调用[self class]还是[super class]，接收消息的对象都是当前Son *obj这个对象。</span><br></pre></td></tr></table></figure><h3 id="写一个完整的代理，包括声明、实现"><a href="#写一个完整的代理，包括声明、实现" class="headerlink" title="写一个完整的代理，包括声明、实现"></a>写一个完整的代理，包括声明、实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建 </span><br><span class="line">@protocol MyDelegate : NSObject</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">- (void)eat:(NSString *)foodName;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 声明.h </span><br><span class="line">@interface Person : NSObject &lt;MyDelegate&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 实现.m</span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)eat:(NSString *)foodName &#123;</span><br><span class="line">    NSLog(@&quot;吃：%@&quot;, foodName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    NSLog(@&quot;run&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="isKindOfClass、isMemberOfClass、selector作用分别是什么？"><a href="#isKindOfClass、isMemberOfClass、selector作用分别是什么？" class="headerlink" title="isKindOfClass、isMemberOfClass、selector作用分别是什么？"></a><code>isKindOfClass</code>、<code>isMemberOfClass</code>、<code>selector</code>作用分别是什么？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">isKindOfClass： 作用是某个对象属于某个类型或者继承自某类。</span><br><span class="line">isMemberOfClass：某个对象确切属于某个类型。</span><br><span class="line"><span class="keyword">selector</span>：通过方法名，获取在内存中的函数的入口地址。</span><br></pre></td></tr></table></figure><h3 id="delegate和notification的区别"><a href="#delegate和notification的区别" class="headerlink" title="delegate和notification的区别"></a><code>delegate</code>和<code>notification</code>的区别</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>二者都用于传递消息，不同之处主要在于一个是一对一的，一个是一对多的。</span><br><span class="line"><span class="number">2.</span>notification通过维护一个array，实现一对消息的转发。</span><br><span class="line"><span class="number">3.</span>delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。</span><br></pre></td></tr></table></figure><h3 id="什么是block？"><a href="#什么是block？" class="headerlink" title="什么是block？"></a>什么是block？</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">闭包<span class="comment">(block)</span>：闭包就是获取其它函数局部变量的匿名函数。</span><br></pre></td></tr></table></figure><h3 id="block反向传值"><a href="#block反向传值" class="headerlink" title="block反向传值"></a>block反向传值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在控制器间传值可以使用代理或者block，使用block相对来说简洁。</span><br><span class="line">在前一个控制器的touchesBegan:方法内实现如下代码。</span><br><span class="line">// OneViewController.m</span><br><span class="line">TwoViewController *twoVC = [[TwoViewController alloc] init];</span><br><span class="line">towVC.valueBlock = ^(NSString *str) &#123;</span><br><span class="line">    NSLog(@&quot;OneViewController:%@&quot;, str);</span><br><span class="line">&#125;;</span><br><span class="line">[self presentViewController:twoVC animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">// TwoViewController.h (在.h文件中声明一个block属性)</span><br><span class="line">@property (nonatomic, copy) void (^valueBlock)(NSString *str);</span><br><span class="line">// TwoViewController.m (在.m中实现方法)</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    // 传值：调用block</span><br><span class="line">    if (_valueBlock) &#123;</span><br><span class="line">        _valueBlock(@&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block的注意点"><a href="#block的注意点" class="headerlink" title="block的注意点"></a><code>block</code>的注意点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在block内部使用外部指针且会造成玄幻引用情况下，需要用__weak修饰外部指针：</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">2.在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。</span><br><span class="line">__strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">3.如果需要在block内部改变外部栈区变量的话，需要用__block修饰外部变量。</span><br></pre></td></tr></table></figure><h3 id="BAD-ACCESS在什么情况下出现？"><a href="#BAD-ACCESS在什么情况下出现？" class="headerlink" title="BAD_ACCESS在什么情况下出现？"></a>BAD_ACCESS在什么情况下出现？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</span><br></pre></td></tr></table></figure><h3 id="IIdb（gdb）常用的控制台调用命令？"><a href="#IIdb（gdb）常用的控制台调用命令？" class="headerlink" title="IIdb（gdb）常用的控制台调用命令？"></a>IIdb（gdb）常用的控制台调用命令？</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">p</span>输出基本类型。是打印命令，需要指定类型。是<span class="keyword">print</span>的缩写。</span><br><span class="line"><span class="keyword">p</span>(<span class="keyword">int</span>)[[[self <span class="keyword">view</span>] subviews] <span class="built_in">count</span>]</span><br><span class="line"><span class="number">2</span>.<span class="keyword">po</span> 打印对象，会调用对象description方法。是<span class="keyword">print</span>-object的简写。</span><br><span class="line"><span class="keyword">po</span> [self <span class="keyword">view</span>]</span><br><span class="line"><span class="number">3</span>.expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用在调试过程中修改变量的值。</span><br><span class="line"><span class="number">4</span>.bt：打印调用堆栈，是thread backrace的简写，加<span class="keyword">all</span>可以打印所有thread的堆栈。</span><br><span class="line"><span class="number">5</span>.<span class="keyword">br</span> |：是breakpoint <span class="keyword">list</span>的简写。</span><br></pre></td></tr></table></figure><h3 id="你一般是怎么用Instruments的？"><a href="#你一般是怎么用Instruments的？" class="headerlink" title="你一般是怎么用Instruments的？"></a>你一般是怎么用Instruments的？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Instruments</span>里面工具很多，常用：</span><br><span class="line">1<span class="selector-class">.Time</span> <span class="selector-tag">Profiler</span>：性能分析</span><br><span class="line">2<span class="selector-class">.Zombies</span>：检查是否访问了僵尸对象，但是这个工具从上往下检查，不智能。</span><br><span class="line">3<span class="selector-class">.Allocations</span>：用来检查内存，写算法的那批人也用这个来检查。</span><br><span class="line">4<span class="selector-class">.Leaks</span>：检查内存，看是否有内存泄漏。</span><br></pre></td></tr></table></figure><h3 id="iOS中常用的数据存储方式有哪些？"><a href="#iOS中常用的数据存储方式有哪些？" class="headerlink" title="iOS中常用的数据存储方式有哪些？"></a>iOS中常用的数据存储方式有哪些？</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">数据存储方式有四种方案：NSUserDefault、KeyChain、<span class="keyword">File</span>、<span class="keyword">DB</span>。</span><br><span class="line">其中<span class="keyword">File</span>有三种方式：writeToFile:atomically:、Plist、NSKeyedArchiever(归档)</span><br><span class="line"><span class="keyword">DB</span>包含：SQLite、FMDB、CoreData</span><br></pre></td></tr></table></figure><h3 id="iOS的沙盒目录结构是怎样的？"><a href="#iOS的沙盒目录结构是怎样的？" class="headerlink" title="iOS的沙盒目录结构是怎样的？"></a>iOS的沙盒目录结构是怎样的？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">沙盒结构：</span><br><span class="line">1<span class="selector-class">.AppName</span><span class="selector-class">.app</span>目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。</span><br><span class="line">2<span class="selector-class">.Documents</span>：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据。<span class="selector-tag">iCloud</span>备份目录。(这里不能存缓存文件，否则上架不被通过)</span><br><span class="line">3<span class="selector-class">.Library</span>目录：这个目录下有两个子目录：</span><br><span class="line"><span class="selector-tag">Preferences</span>目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用<span class="selector-tag">NSUserDefaults</span>类来取得和设置应用程序的偏好。</span><br><span class="line"><span class="selector-tag">Caches</span>目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。</span><br><span class="line">可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除<span class="selector-tag">Caches</span>以外，都会被<span class="selector-tag">iTunes</span>备份。</span><br><span class="line">4<span class="selector-class">.tmp</span>：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</span><br></pre></td></tr></table></figure><h3 id="iOS多线程技术有哪几种方式？"><a href="#iOS多线程技术有哪几种方式？" class="headerlink" title="iOS多线程技术有哪几种方式？"></a>iOS多线程技术有哪几种方式？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">prhread、<span class="built_in">NSThread</span>、GCD、<span class="built_in">NSOperation</span></span><br></pre></td></tr></table></figure><h3 id="GCD与NSOperation的区别"><a href="#GCD与NSOperation的区别" class="headerlink" title="GCD与NSOperation的区别"></a><code>GCD</code>与<code>NSOperation</code>的区别</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GCD</span>和NSOperation都是用于实现多线程：</span><br><span class="line"><span class="keyword">GCD</span>基于<span class="keyword">C</span>语言的底层API，<span class="keyword">GCD</span>主要与block结合使用，代码简洁高效。</span><br><span class="line">NSOperation属于Objective-<span class="keyword">C</span>类，是基于<span class="keyword">GCD</span>更高一层的封装。复杂任务一般用NSOperation实现。</span><br></pre></td></tr></table></figure><h3 id="写出使用GCD方式从子线程回到主线程的方法代码"><a href="#写出使用GCD方式从子线程回到主线程的方法代码" class="headerlink" title="写出使用GCD方式从子线程回到主线程的方法代码"></a>写出使用GCD方式从子线程回到主线程的方法代码</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_sync(<span class="name">dispatch_get_main_queue</span>(), ^&#123;&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）"><a href="#如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）" class="headerlink" title="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）"></a>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用Dispatch Group追加block到Global Group Queue，这些block如果全部执行完毕，就会执行Main DispatchQueue中的结束处理的block。</span><br><span class="line">// 创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 获取全局并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片1 **/&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片2 **/&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片3 **/&#125;);</span><br><span class="line">// 当并发队列组中的任务执行完毕后才会执行这里的代码</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;/* 合并图片 **/&#125;);</span><br></pre></td></tr></table></figure><h3 id="dispatch-barrier-async-栅栏函数-的作用是什么？"><a href="#dispatch-barrier-async-栅栏函数-的作用是什么？" class="headerlink" title="dispatch_barrier_async(栅栏函数)的作用是什么？"></a>dispatch_barrier_async(栅栏函数)的作用是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class="line">作用：</span><br><span class="line">1.在它前面的任务执行结束后才执行，它后面的任务要等它执行完成后才开始执行。</span><br><span class="line">2.避免数据竞争。</span><br><span class="line">// 1.创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2.向队列中添加任务</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">   // 1.2是并行的</span><br><span class="line">   NSLog(@&quot;任务1，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">   NSLog(@&quot;任务2，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">   NSLog(@&quot;任务 barrier，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这两个是同时执行的 </span><br><span class="line">    NSLog(@&quot;任务3，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务4，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出结果：任务1 任务2 -&gt; 任务barrier -&gt;任务3 任务4</span><br><span class="line">// 其中任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。</span><br></pre></td></tr></table></figure><h3 id="以下代码运行结果如何？"><a href="#以下代码运行结果如何？" class="headerlink" title="以下代码运行结果如何？"></a>以下代码运行结果如何？</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">viewDidLoad</span> &#123;</span><br><span class="line">    <span class="selector-attr">[super viewDidLoad]</span>;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"1"</span>);</span><br><span class="line">    <span class="selector-tag">dispatch_asyc</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="selector-tag">NSLog</span>(@<span class="string">"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"3"</span>);</span><br><span class="line">    <span class="comment">// 只输出：1。主线程死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">从字面上看，就是运行循环，跑圈</span><br><span class="line">其实它内部就是<span class="keyword">do</span>-<span class="keyword">while</span>循环，在这个循环内部不断处理各种任务(比如Source、Timer、Observer)</span><br><span class="line">一个现成对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。</span><br><span class="line">通过RunLoop，有事运行，没事就休息，可以节省CPU资源，提高程序性能。</span><br><span class="line"></span><br><span class="line">主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>&#123;argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说说你对runtime的理解"><a href="#说说你对runtime的理解" class="headerlink" title="说说你对runtime的理解"></a>说说你对runtime的理解</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Runtime</span>又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。</span><br></pre></td></tr></table></figure><h3 id="Runtime实现机制是什么，怎么用，一般用于干嘛？"><a href="#Runtime实现机制是什么，怎么用，一般用于干嘛？" class="headerlink" title="Runtime实现机制是什么，怎么用，一般用于干嘛？"></a>Runtime实现机制是什么，怎么用，一般用于干嘛？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.使用时需要导入的头文件</span><br><span class="line"><span class="number">2</span>.Runtime运行时机制，它是一套C语言库。</span><br><span class="line"><span class="number">3</span>.实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</span><br><span class="line">比如：</span><br><span class="line">类转成了Runtime库里面的结构体等数据类型。</span><br><span class="line">方法转成了Runtime库里面的C语言函数。</span><br><span class="line">平时调方法都是转成了objc_msgSend函数(所以说OC有个消息转发机制)</span><br><span class="line"><span class="comment">// OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</span></span><br><span class="line"><span class="comment">// [stu show]; 在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));</span></span><br><span class="line"><span class="number">4</span>.因此，可以说Runtime是OC的底层实现，是OC的幕后执行者。</span><br><span class="line"></span><br><span class="line">有了Runtime库，能做什么事情呢？</span><br><span class="line">Runtime库里面包含了跟类、成员变量、方法相关的API。</span><br><span class="line">比如：</span><br><span class="line"><span class="number">1</span>.获取类里面的所有成员变量。</span><br><span class="line"><span class="number">2</span>.为类动态添加成员变量。</span><br><span class="line"><span class="number">3</span>.为类动态添加新的方法。</span><br><span class="line"><span class="number">4</span>.动态改变类的方法实现等。(<span class="function"><span class="keyword">Method</span> <span class="title">Swizzling</span>)</span></span><br><span class="line"><span class="function">因此，有了<span class="title">Runtime</span>，想怎么改就怎么改。</span></span><br></pre></td></tr></table></figure><h3 id="什么是Method-Swizzle（黑魔法），什么情况下会使用？"><a href="#什么是Method-Swizzle（黑魔法），什么情况下会使用？" class="headerlink" title="什么是Method Swizzle（黑魔法），什么情况下会使用？"></a>什么是Method Swizzle（黑魔法），什么情况下会使用？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法<span class="function"><span class="keyword">Method</span> <span class="title">Swizzle</span>。</span></span><br><span class="line"><span class="function">2.<span class="title">Method</span> <span class="title">Swizzle</span>指的是改变一个已存在的选择器对应的实现的过程。<span class="title">OC</span>中方法的调用能够在运行时通过改变类的调度表中选择器到最终函数的映射关系。</span></span><br><span class="line"><span class="function">3.在<span class="title">OC</span>中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是<span class="title">selector</span>的名字。利用<span class="title">OC</span>的动态特性，可以实现在运行时偷换<span class="title">selector</span>对应的方法实现。</span></span><br><span class="line"><span class="function">4.每个类都有一个方法列表，存放着<span class="title">selector</span>的名字和方法实现的映射关系。<span class="title">IMP</span>有点类似函数指针，指向具体的方法实现。</span></span><br><span class="line"><span class="function">5.我们可以利用<span class="title">method_exchangeImplementations</span>来交换2个方法中的<span class="title">IMP</span>。</span></span><br><span class="line"><span class="function">6.我们可以利用<span class="title">class_replaceMethod</span>来修改类。</span></span><br><span class="line"><span class="function">7.我们可以利用<span class="title">method_setImplementation</span>来直接设置某个方法的<span class="title">IMP</span>。</span></span><br><span class="line"><span class="function">8.归根结底，都是偷换了<span class="title">selector</span>的<span class="title">IMP</span>。</span></span><br></pre></td></tr></table></figure><h3 id="objc-msgForward函数是做什么的，直接调用它将会发生什么？"><a href="#objc-msgForward函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="_objc_msgForward函数是做什么的，直接调用它将会发生什么？"></a><code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">_objc_msgForward</span>是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<span class="variable">_objc_msgForward</span>会尝试做消息转发。</span><br></pre></td></tr></table></figure><h3 id="什么是TCP-UDP？"><a href="#什么是TCP-UDP？" class="headerlink" title="什么是TCP/UDP？"></a>什么是TCP/UDP？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP：传输控制协议。</span><br><span class="line">UDP：用户数据协议。</span><br><span class="line"></span><br><span class="line">TCP是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。</span><br><span class="line">UDP是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。</span><br><span class="line">简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。</span><br></pre></td></tr></table></figure><h3 id="通信底层原理（OSI七层模型）"><a href="#通信底层原理（OSI七层模型）" class="headerlink" title="通信底层原理（OSI七层模型）"></a>通信底层原理（OSI七层模型）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OSI采用了分层的结构化技术，共分七层：</span><br><span class="line">物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</span><br></pre></td></tr></table></figure><h3 id="OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？"><a href="#OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？" class="headerlink" title="OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？"></a>OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？</h3><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程的方法</span></span><br><span class="line">-<span class="ruby"> [NSThread <span class="symbol">detachNewThreadSelector:</span><span class="literal">nil</span> <span class="symbol">toTarget:</span><span class="literal">nil</span> <span class="symbol">withObject:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">- [<span class="keyword">self</span> <span class="symbol">performSelectorInBackground:</span><span class="literal">nil</span> <span class="symbol">withObject:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">- [[NSThread alloc] <span class="symbol">initWithTarget:</span><span class="literal">nil</span> <span class="symbol">selector:</span><span class="literal">nil</span> <span class="symbol">object:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">- dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;&#125;);</span></span><br><span class="line"><span class="ruby">- [[NSOperationQueue new] <span class="symbol">addOperation:</span><span class="literal">nil</span>];</span></span><br><span class="line"><span class="ruby">/<span class="regexp">/ 主线程中执行代码的方法</span></span></span><br><span class="line"><span class="ruby">- [<span class="keyword">self</span> <span class="symbol">performSelectorOnMainThread:</span><span class="literal">nil</span> <span class="symbol">withObject:</span><span class="literal">nil</span> <span class="symbol">waitUntilDone:</span>YES];</span></span><br><span class="line"><span class="ruby">- dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</span></span><br><span class="line"><span class="ruby">- [[NSOperationQueue mainQueue] <span class="symbol">addOperation:</span><span class="literal">nil</span>];</span></span><br></pre></td></tr></table></figure><h3 id="tableView的重用机制？"><a href="#tableView的重用机制？" class="headerlink" title="tableView的重用机制？"></a>tableView的重用机制？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UITableView</span>通过重用单元格达到节省内存的目的；通过为每个单元格指定一个重用的标识符，即指定了单元格的种类，当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新的单元格从屏幕外滑入屏幕时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</span><br></pre></td></tr></table></figure><h3 id="用伪代码写一个现成安全的单例模式"><a href="#用伪代码写一个现成安全的单例模式" class="headerlink" title="用伪代码写一个现成安全的单例模式"></a>用伪代码写一个现成安全的单例模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static id _instance;</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareData &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何实现视图的变形？"><a href="#如何实现视图的变形？" class="headerlink" title="如何实现视图的变形？"></a>如何实现视图的变形？</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">通过修改<span class="built_in">view</span>的<span class="built_in">transform</span>属性即可。</span><br></pre></td></tr></table></figure><h3 id="在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？"><a href="#在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？" class="headerlink" title="在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？"></a>在手势对象基础类<code>UIGestureRecognizer</code>的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UITapGestureRecognizer</span>、<span class="built_in">UISwipeGestureRecognizer</span>是一次性手势，手势发生后，响应只会执行一次。</span><br></pre></td></tr></table></figure><h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">NSString *<span class="keyword">str</span> = @<span class="string">"abc123"</span>;</span><br><span class="line">NSArray *arr = [<span class="keyword">str</span> componentsSeperatedByString:@<span class="string">""</span>];</span><br></pre></td></tr></table></figure><h3 id="如何高性能的给UIImageView加个圆角？"><a href="#如何高性能的给UIImageView加个圆角？" class="headerlink" title="如何高性能的给UIImageView加个圆角？"></a>如何高性能的给UIImageView加个圆角？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制，而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。</span><br><span class="line">self.view.layer.cornerRadius = 5.0f;</span><br><span class="line">self.view.layer.masksToBounds = YES;</span><br><span class="line"></span><br><span class="line">正确的解决方案：使用绘图技术</span><br><span class="line">- (UIImage *)circleImage &#123;</span><br><span class="line">// NO代表透明 </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">    // 获得上下文</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">    // 添加一个圆</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">    CGContextAddEllipseInRect(ctx, rect);</span><br><span class="line">    // 裁剪</span><br><span class="line">    CGContextClip(ctx);</span><br><span class="line">    // 将图片画上去</span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    // 关闭上下文</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有一种方案：使用贝塞尔曲线“切割”这个图片，给UIImageView添加的圆角，其实也是通过绘图技术来实现的。</span><br><span class="line">UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">imageView.center = CGPointMake(200, 300);</span><br><span class="line">UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1);</span><br><span class="line">[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:50] addClip];</span><br><span class="line">[anotherImage drawInRct:imageView.bounds];</span><br><span class="line">imageView.image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">[self.view addSubview:imageView];</span><br></pre></td></tr></table></figure><h3 id="你是怎么封装一个view的"><a href="#你是怎么封装一个view的" class="headerlink" title="你是怎么封装一个view的"></a>你是怎么封装一个view的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.可以通过纯代码或者xib的方式来封装子控件。</span><br><span class="line">2.建立一个跟view相关的模型，然后将模型数据给view，通过模型上的数据给view的子控件赋值。</span><br><span class="line">/** 纯代码初始化控件时一定会走这个方法 */</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 通过xib初始化控件时一定会走这个方法 */</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupUI &#123;// 初始化代码 &#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP协议中POST方法和GET方法有哪些区别？"><a href="#HTTP协议中POST方法和GET方法有哪些区别？" class="headerlink" title="HTTP协议中POST方法和GET方法有哪些区别？"></a>HTTP协议中POST方法和GET方法有哪些区别？</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">GET</span>用于向服务器请求数据，POST用于提交数据。</span><br><span class="line"><span class="number">2.</span><span class="keyword">GET</span>请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此<span class="keyword">GET</span>请求不适合用于验证密码等操作。</span><br><span class="line"><span class="number">3.</span><span class="keyword">GET</span>请求的URL有长度限制，POST请求不会有长度限制。</span><br></pre></td></tr></table></figure><h3 id="请简单的介绍下APNS发送系统消息的机制"><a href="#请简单的介绍下APNS发送系统消息的机制" class="headerlink" title="请简单的介绍下APNS发送系统消息的机制"></a>请简单的介绍下APNS发送系统消息的机制</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。</span><br><span class="line">APNS的原理：</span><br><span class="line"><span class="number">1.</span>应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)；</span><br><span class="line"><span class="number">2.</span>应用程序接收到设备令牌并发送给自己的后台服务器；</span><br><span class="line"><span class="number">3.</span>服务器把要推送的内容和设备发送给APNS；</span><br><span class="line"><span class="number">4.</span>APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示。</span><br></pre></td></tr></table></figure><h3 id="iOS开发逆向传值的集中方法整理"><a href="#iOS开发逆向传值的集中方法整理" class="headerlink" title="iOS开发逆向传值的集中方法整理"></a>iOS开发逆向传值的集中方法整理</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>代理传值</span><br><span class="line"><span class="number">2.</span>通知传值</span><br><span class="line"><span class="number">3.</span>单例传值</span><br><span class="line"><span class="number">4.</span>block传值</span><br><span class="line"><span class="number">5.</span>extern传值(全局变量)</span><br><span class="line"><span class="number">6.</span>KVO传值</span><br></pre></td></tr></table></figure><h3 id="你使用过Objective-C的运行时编程-Runtime-Programming-么-如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"><a href="#你使用过Objective-C的运行时编程-Runtime-Programming-么-如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？" class="headerlink" title="你使用过Objective-C的运行时编程(Runtime Programming)么?如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"></a>你使用过Objective-C的运行时编程(Runtime Programming)么?如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Objective-C的重要特性是Runtime(运行时)，在#import下能看到相关的方法，用objc_getClass()和class_copyMethodList()获取过私有API；使用</span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">method1</span> = <span class="title">class_getInstanceMethod</span><span class="params">(cls, sel1)</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">method2</span> = <span class="title">class_getInstanceMethod</span><span class="params">(cls, sel2)</span>;</span></span><br><span class="line">method_exchangeImplementations(method1, method2);</span><br><span class="line"></span><br><span class="line">代码交换两个方法，在写<span class="keyword">unit</span> test时使用到。</span><br></pre></td></tr></table></figure><h3 id="Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）"><a href="#Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）" class="headerlink" title="Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）"></a>Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">UI框架的底层有CoreAnimation，CoreAnimation的底层有CoreGraphics。</span><br><span class="line">UIKit<span class="string">|</span></span><br><span class="line">--------<span class="string">|</span></span><br><span class="line">Core Animation<span class="string">|</span></span><br><span class="line">Core Graphics<span class="string">|</span></span><br><span class="line">Graphics Hardware<span class="string">|</span></span><br><span class="line">使用CA做过menu菜单的展开收起</span><br></pre></td></tr></table></figure><h3 id="是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。"><a href="#是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。" class="headerlink" title="是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。"></a>是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CoreText可以解决复杂文字内容排版问题。CoreImage可以处理图片，为其添加各种效果。体验是很强大，挺复杂的。</span><br></pre></td></tr></table></figure><h3 id="自动释放池是什么，如何工作"><a href="#自动释放池是什么，如何工作" class="headerlink" title="自动释放池是什么，如何工作"></a>自动释放池是什么，如何工作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放，它仍然是个OC的对象，因此自动释放池定义的作用域内的其它对象可以向他发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。</span><br></pre></td></tr></table></figure><h3 id="NSNotification和KVO的区别和用法是什么-什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate-或者delegate的Array-来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么-虽然protocol和delegate这种东西面试已经面烂了"><a href="#NSNotification和KVO的区别和用法是什么-什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate-或者delegate的Array-来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么-虽然protocol和delegate这种东西面试已经面烂了" class="headerlink" title="NSNotification和KVO的区别和用法是什么?什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate(或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么?(虽然protocol和delegate这种东西面试已经面烂了)"></a>NSNotification和KVO的区别和用法是什么?什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate(或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么?(虽然protocol和delegate这种东西面试已经面烂了)</h3><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">NSNotification是通知模式在iOS的实现，KVO的全称是键值观察(<span class="keyword">Key</span>-value observing)，其是基于KVC(<span class="keyword">key</span>-value coding)的，KVC是一个通过属性名访问属性变量的机制。例如<span class="keyword">Module</span>层的变化，通知到多个Controller对象时，可以使用NSNotification；如果是只需要观察某个对象的某个属性，可以使用KVO。</span><br><span class="line">对于委托模式，在设计模式中是对象适配器模式，其是<span class="keyword">delegate</span>是指向某个对象，这是一对一的关系，而在通知模式中，往往是一对多的关系。委托模式，从技术上可以实现改变<span class="keyword">delegate</span>指向的对象，但不建议这样做，会让人迷惑，如果一个<span class="keyword">delegate</span>对象不断改变，指向不同的对象。</span><br></pre></td></tr></table></figure><h3 id="你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）"><a href="#你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）" class="headerlink" title="你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）"></a>你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">使用<span class="built_in">NSOperationQueue</span>用来管理子类化的<span class="built_in">NSOperation</span>对象，控制其线程并发数目。GCD和<span class="built_in">NSOperation</span>都可以实现对线程的管理，区别是<span class="built_in">NSOperation</span>和<span class="built_in">NSOperationQueue</span>是多线程的面向对象抽象。项目中使用<span class="built_in">NSOperation</span>的优点是<span class="built_in">NSOperation</span>是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化<span class="built_in">NSOperation</span>的设计思路，是具有面向对象的有点(复用、封装)，使得实现多线程支持，而接口简单，建议在复杂项目中使用。</span><br><span class="line">项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会使代码更为易读，建议在简单项目中使用。</span><br></pre></td></tr></table></figure><h3 id="既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么"><a href="#既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么" class="headerlink" title="既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?"></a>既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">使用block时要注意，若将block做函数参数时，需要把它放到最后，<span class="keyword">GCD</span>是Grand Central <span class="keyword">Dispatch</span>，是一个对线程开源类库，而<span class="keyword">Block</span>是闭包，是能够读取其它函数内部变量的函数。</span><br></pre></td></tr></table></figure><h3 id="对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？"><a href="#对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？" class="headerlink" title="对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？"></a>对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用<span class="keyword">link</span>命令及flag解决冲突。</span><br></pre></td></tr></table></figure><h3 id="你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。"><a href="#你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。" class="headerlink" title="你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。"></a>你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一个文件解压压缩框架，从使用者角度出发，只需要关注发送给框架一个解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给使用者，如解压完成、解压出错等。在框架内部去构建对象的关系，通过抽象让其更为健壮、便于更改。其次是API的说明文档。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闲谈&quot;&gt;&lt;a href=&quot;#闲谈&quot; class=&quot;headerlink&quot; title=&quot;闲谈&quot;&gt;&lt;/a&gt;闲谈&lt;/h1&gt;&lt;p&gt;最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。&lt;/p&gt;
&lt;h1 id=&quot;基础&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-Runloop浅谈</title>
    <link href="http://htmlios.github.io/2016/07/02/iOS-Runloop%E6%B5%85%E8%B0%88/"/>
    <id>http://htmlios.github.io/2016/07/02/iOS-Runloop浅谈/</id>
    <published>2016-07-02T01:52:00.000Z</published>
    <updated>2018-07-05T01:25:06.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="苹果官方文档中有下图："><a href="#苹果官方文档中有下图：" class="headerlink" title="苹果官方文档中有下图："></a><a href="https://link.jianshu.com/?t=https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">苹果官方文档</a>中有下图：</h3><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop.jpg" alt="Structure of a run loop and its sources"></p><h3 id="Runloop内部的逻辑基本如下："><a href="#Runloop内部的逻辑基本如下：" class="headerlink" title="Runloop内部的逻辑基本如下："></a>Runloop内部的逻辑基本如下：</h3><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop2.jpg" alt="1829339-d378878ffdf4c6ae.jpg"></p><h3 id="其内部代码整理如下："><a href="#其内部代码整理如下：" class="headerlink" title="其内部代码整理如下："></a>其内部代码整理如下：</h3><p>可以看到，实际上Runloop是一个这样的函数，其内部是一个do-while循环。当你调用<code>CFRunloopRun()</code>时，线程就会一直停留在这个循环里，直到手动停止或者超时，该函数才会返回。</p><h3 id="Runloop的底层实现："><a href="#Runloop的底层实现：" class="headerlink" title="Runloop的底层实现："></a>Runloop的底层实现：</h3><p>Runloop的核心是基于mach port的，其进入休眠时调用的函数是mach_msg()。解释这个逻辑，下面稍微介绍一下OSX/iOS的系统架构。</p><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop3.png" alt="1829339-be19d014752b22c0.png"></p><p>苹果官方将整个系统大致分为上述4个层次：</p><p>应用层包括用户能够接触到的图形应用，例如Spotlight、Aqua、SpringBoard等；</p><p>应用框架层即开发人员所接触到的Cocoa等框架；</p><p>核心架构层包括各种核心架构、OpenGL等内容；</p><p>Darwin即操作系统核心，包括系统内核、驱动、Shell等内容，是开源的，其所有源码都可以在opensource.apple.com里找到；</p><p>深入看Darwin这个核心架构：</p><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop4.png" alt="1829339-a9bd8e6efe4245a6.png"></p><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit（还包括上面一些标注内容），共同组成了XNU内核。</p><p>XNU内核的内环被称作为Mach，其作为一个内核，仅提供诸如处理器调度、IPC(进程间调度)等非常少量的基础服务。</p><p>BSD层可以看做是围绕Mach层的一个外环，其提供诸如进程管理、文件系统和网络等功能。</p><p>IOKit层为设置驱动提供了一个面向对象(C++)的架构。</p><p>Mach</p><p>本身提供的API非常有限，而且苹果也不鼓励使用Mach的API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在Mach中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为“对象”。和其他架构不同，Mach的对象间不能直接通信，只能通过消息传递的方式实现对象间的通信。“消息”是Mach中最基础的概念，消息在两个端口（port）之间传递，这就是Mach的IPC(进程间通信)的核心。</p><p>Mach的消息定义是在头文件的，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">mach_msg_header_t header;</span><br><span class="line">mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">mach_msg_bits_t msgh_bits;</span><br><span class="line">mach_msg_size_t msgh_size;</span><br><span class="line">mach_port_t msgh_remote_port;</span><br><span class="line">mach_port_t msgh_local_port;</span><br><span class="line">mach_port_name_t msgh_voucher_port;</span><br><span class="line">mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure><p>一条Mach的消息实际上是一个二进制数据包（BLOB），其头部定了当前端口local_port和目标端口remote_port，发送和接收消息是通过同一个API进行的，其option标记了消息传递的方向。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span> mach_msg(</span><br><span class="line"><span class="keyword">mach_msg_header_t</span> *msg,</span><br><span class="line"><span class="keyword">mach_msg_option_t</span> option,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> send_size,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> rcv_size,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> rcv_name,</span><br><span class="line"><span class="keyword">mach_msg_timeout_t</span> timeout,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> notify);</span><br></pre></td></tr></table></figure><p>为了实现消息的发送和接收，mach_msg()函数实际上调用了一个Mach陷阱(trap)，即函数mach_msg_trap()，陷阱这个概念在Mach中等同于系统调用。当你在用户态调用mach_msg_map()时会出发陷阱机制，切换到内核态：内核态中内核实现的mach_msg()函数会完成实际工作，如下图：</p><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop5.png" alt="1829339-7d244424ee5a8ef8.png"></p><p>这些概念参考维基百科：System_call、Trap_(computing)</p><p>RunLoop的核心就是一个mach_msg()（见上面代码第七部），RunLoop调用这个函数去接收实际消息，如果没有别人发送port，消息过来，内核会将线程闲置等待状态。例如你在模拟器里跑一个iOS App，然后在App静止时点击暂停，你会看到主线程调用栈是停留在<code>mach_msg_trap()</code>这个地方。</p><h3 id="苹果用Runloop实现的功能"><a href="#苹果用Runloop实现的功能" class="headerlink" title="苹果用Runloop实现的功能"></a>苹果用Runloop实现的功能</h3><p>首先我们可以看一下App启动后Runloop的状态：</p><p>可以看到，系统默认注册了5个Mode:</p><p>1.KCFRunLoopDefaultMode:App的默认Mode，通常主线程是在这个Mode下运行的。</p><p>2.UITrackingRunLoopMode:界面跟踪Mode，用于ScrollView跟踪触摸滑动，保证界面滑动时不受其他Mode影响。</p><p>3.UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode，启动完成后就不再使用。</p><p>4.GSEventReceiveRunLoopMode:接受系统事件的内部Mode，通常用不到。</p><p>5.kCFRunLoopCommonModes:这是一个占位的Mode，没有实际作用。</p><p>可以看到很多苹果内部的Mode，但那些Mode在开发中很难遇到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;苹果官方文档中有下图：&quot;&gt;&lt;a href=&quot;#苹果官方文档中有下图：&quot; class=&quot;headerlink&quot; title=&quot;苹果官方文档中有下图：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https://develope
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建博客</title>
    <link href="http://htmlios.github.io/2016/06/25/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://htmlios.github.io/2016/06/25/Hexo-Github搭建博客/</id>
    <published>2016-06-25T12:05:15.000Z</published>
    <updated>2018-06-23T18:01:37.407Z</updated>
    
    <content type="html"><![CDATA[<p>1.安装和配置Node.js环境，打开终端，成功界面如下</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog1.png" alt="img"></p><p>2.安装和配置Git环境，安装成功的象征是鼠标右键出现选择如下</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog2.png" alt="img"></p><p>3.Github账户注册和新建项目，勾选Initialize this repository with a README</p><p>4.创建博客文件夹，在该文件夹下安装Hexo，输入如下命令开始安装，成功如下图</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo -g</span><br></pre></td></tr></table></figure><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog3.png" alt="img"></p><p>输入hexo -v，检查hexo是否安装成功</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog4.png" alt="img"></p><p>输入hexo init，初始化该文件夹，需要一段时间</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog5.png" alt="img"></p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog6.png" alt="img"></p><p>输入npm install，安装所需要的组件</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog7.png" alt="img"></p><p>输入hexo g，首次体验Hexo</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog8.png" alt="img"></p><p>输入hexo s，开启服务器，访问该网址，正式体验Hexo</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog9.png" alt="img"></p><p>假如页面一直无法跳转，那么可能端口被占用了，输入命令ctrl+c停止服务器，输入hexo server -p来修改端口号</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog10.png" alt="img"></p><p>打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 如下图就成功了</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog11.png" alt="img"></p><p>5.将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次）</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog12.png" alt="img"></p><p>上图是在其文件夹里鼠标右键，点击Git Base Here。这里feng可以替换成自己的用户名，邮箱可以替换成自己的邮箱</p><p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog13.png" alt="img"></p><p>输入ls，列出该文件夹下的内容。下图说明存在</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog14.png" alt="img"></p><p>输入ssh-keygen -t rsa -C”邮箱地址”，连续三个回车，生成密钥，最后得到了两个文件夹:id_rsa和id_rsa.pub（默认存储路径是：C:/Users/Administrator/.ssh）。</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog15.png" alt="img"></p><p>输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog16.png" alt="img"></p><p>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog17.png" alt="img"></p><p>登录Github，点击头向下的settings，添加ssh</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog18.png" alt="img"></p><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog19.png" alt="img"></p><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加的ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog20.png" alt="img"></p><p>问题：加入ssh-key配置失败，那么只要以下步骤就能完全解决</p><p>首先，清楚所有的key-pair</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span><span class="bash"> -D</span></span><br><span class="line"><span class="bash">rm -r ~/.ssh</span></span><br></pre></td></tr></table></figure><p>删除你在github中的public-key</p><p>重新生成ssh密钥对</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">xxx</span>@<span class="keyword">xxx</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure><p>接下来正常操作</p><p>在github上添加公钥public-key:</p><p>1.首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪贴板</p><p>2.在github上添加公钥时，直接复制即可</p><p>3.保存</p><p>测试：</p><p>在终端 </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-T</span> <span class="selector-tag">git</span>@<span class="keyword">github</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure><p>6.配置Deployment，在其文件夹中，找到_config.yml文件夹，修改repo值（在末尾）</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog21.png" alt="img"></p><p>repo值是你在github项目里ssh (右下角)</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog22.png" alt="img"></p><p>7.新建一篇博客，在cmd执行命令：hexo new post”博客名”</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog23.png" alt="img"></p><p>这时候在文件夹_posts目录下将会看到已经创建好的文件</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog24.png" alt="img"></p><p>在生成以及波束文章之前，需要安装一个扩展: </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog25.png" alt="img"></p><p>使用编辑器编辑好文章，那么就可以使用命令生成以及部署了</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo d -g</span></span><br></pre></td></tr></table></figure><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog26.png" alt="img"></p><p>部署成功后访问你的地址:http://用户名.github.io。将看到生成的文章</p><p>到此为止，最基本的也是最全面的Hexo+github搭建博客完结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.安装和配置Node.js环境，打开终端，成功界面如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.安装和配置Git环境，安装成功的象征是鼠
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个性化配置</title>
    <link href="http://htmlios.github.io/2016/06/24/Hexo%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://htmlios.github.io/2016/06/24/Hexo个性化配置/</id>
    <published>2016-06-24T11:37:00.000Z</published>
    <updated>2018-06-24T11:51:02.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-next-categories和tags页面"><a href="#Hexo-next-categories和tags页面" class="headerlink" title="Hexo-next categories和tags页面"></a>Hexo-next categories和tags页面</h2><p>hexo默认是没有categories和tags的，创建步骤：</p><p>在hexo目录分别执行如下命令</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span><span class="string">"tags"</span></span><br><span class="line"></span><br><span class="line">hexo new<span class="built_in"> page </span><span class="string">"categories"</span></span><br></pre></td></tr></table></figure><p>编辑<code>/tags/index.md</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">type:</span> <span class="string">"tags"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">layout:</span> <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><p>编辑<code>/categories/index.md</code></p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">type:</span> <span class="string">"categories"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">layout:</span> <span class="string">"categories"</span></span><br></pre></td></tr></table></figure><p>取消next的<code>_config.yml</code>的<code>tags</code>、<code>categories</code>的注释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hexo-next-categories和tags页面&quot;&gt;&lt;a href=&quot;#Hexo-next-categories和tags页面&quot; class=&quot;headerlink&quot; title=&quot;Hexo-next categories和tags页面&quot;&gt;&lt;/a&gt;Hexo-
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-plugin</title>
    <link href="http://htmlios.github.io/2016/06/24/Hexo-plugin/"/>
    <id>http://htmlios.github.io/2016/06/24/Hexo-plugin/</id>
    <published>2016-06-24T09:53:00.000Z</published>
    <updated>2018-06-24T11:56:45.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-admin"><a href="#Hexo-admin" class="headerlink" title="Hexo-admin"></a>Hexo-admin</h2><p>老方式<code>hexo new post &quot;title&quot;</code>来新建博客，写完后，生成，发布<code>hexo d -g</code>，过程麻烦，不能可视化接受不了。</p><p>Hexo-admin可以比较好的解决这个问题，简单介绍一下：</p><p>官网：<code>https://jaredforsyth.com/hexo-admin/</code></p><p>安装hexo-admin插件（基于你已经搭建好<a href="https://htmlios.github.io/2016/06/25/Hexo-Github搭建博客/" target="_blank" rel="noopener">Hexo</a>），并且启动hexo服务，打开浏览器访问能看到基本的界面</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-admin</span></span><br><span class="line">hexo <span class="keyword">server</span> -d</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">http</span>://localhost:<span class="number">4000</span>/<span class="keyword">admin</span>/</span><br></pre></td></tr></table></figure><p>在hexo的_config.yml配置hexo-admin</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-admin authentification</span></span><br><span class="line"></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">xxx</span> <span class="comment"># 账号</span></span><br><span class="line"><span class="attr">  password_hash:</span> <span class="string">xxx</span> <span class="comment"># 密码</span></span><br><span class="line"><span class="attr">  secret:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  deployCommand:</span> <span class="string">'./hexo-deploy.sh'</span></span><br></pre></td></tr></table></figure><p>密码生成方式，在<code>http://localhost:4000/admin/</code>-&gt;<code>Settings</code>-&gt;<code>Setup authentification here.</code>按照界面指示输入<code>Username</code>、<code>Password</code>、<code>Secret</code>后，在底部会看到生成的相应配置，将其拷贝到Hexo目录下的_config.yml里，重启hexo，访问<code>http://localhost:4000/admin/</code>输入你生成好的账号密码。</p><p>deployCommand需要配置，在Hexo目录下新建<code>hexo-deploy.sh</code>输入以下内容</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure><p>保存退出，并且赋予执行权限</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">chmod</span> +<span class="selector-tag">x</span> <span class="selector-tag">hexo-deploy</span><span class="selector-class">.sh</span></span><br></pre></td></tr></table></figure><p>完成，后续写完博客只需要点击Deploy即可生成发布</p><p><img src="/2016/06/24/Hexo-plugin/image-20180624184646419.png" alt="image-20180624184646419"></p><ul><li>Post：博客文章列表，包括已经发布的和还在草稿箱等待宠幸的；</li><li>Pages：就是诸如标签云之类的页面管理；</li><li>About：关于admin插件的说明</li><li>hexo-gen：这个原来是Deploy，被我修改了，关键节点；</li><li>Settings:配置</li></ul><h2 id="Hexo插入图片"><a href="#Hexo插入图片" class="headerlink" title="Hexo插入图片"></a>Hexo插入图片</h2><p>1.修改配置：修改hexo配置文件_config.yml，post_asset_folder: true；</p><p>2.安装插件：终端切换到在hexo目录，安装hexo-asset-image插件，命令及成功如下；成功后新生成md博文时，/source/_posts文件夹内会同时生成xxxx.md、xxxx文件夹；</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-<span class="built_in">image</span> --<span class="built_in">save</span></span><br></pre></td></tr></table></figure><p><img src="/2016/06/24/Hexo-plugin/image-20180622142939294.jpg" alt="安装hexo-asset-image plugin"></p><p>3.使用方式：在xxxx.md中想引入图片时，将图片存在xxxx文件夹内，后只需在xxxx.md中按照markdown的格式引入图片；</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片hover提示</span>](<span class="link">xxxx/图片名.图片格式</span>)</span><br></pre></td></tr></table></figure><p>4.检验结果：hexo g生成页面后，进入public/年/月/日/xxxx/index.html找到生成的相关字段，html标签内的语句应如下；</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"年/月/日/xxxx/图片名.图片格式"</span>&gt;</span><br></pre></td></tr></table></figure><p>慈不带兵，义不行贾。</p><h2 id="Hexo-next博客图片浏览器"><a href="#Hexo-next博客图片浏览器" class="headerlink" title="Hexo-next博客图片浏览器"></a>Hexo-next博客图片浏览器</h2><p>修改<code>next的</code> <code>_config.yml</code>配置里的<code>fancybox: true</code>，配置上方的注释有插件安装地址（包含安装教程）。</p><p>更新中。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hexo-admin&quot;&gt;&lt;a href=&quot;#Hexo-admin&quot; class=&quot;headerlink&quot; title=&quot;Hexo-admin&quot;&gt;&lt;/a&gt;Hexo-admin&lt;/h2&gt;&lt;p&gt;老方式&lt;code&gt;hexo new post &amp;quot;title&amp;quo
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="http://htmlios.github.io/2016/06/21/Hexo/"/>
    <id>http://htmlios.github.io/2016/06/21/Hexo/</id>
    <published>2016-06-20T18:07:00.000Z</published>
    <updated>2018-06-23T18:11:17.743Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
