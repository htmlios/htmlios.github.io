<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐凡的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://htmlios.github.io/"/>
  <updated>2018-09-06T09:11:45.138Z</updated>
  <id>http://htmlios.github.io/</id>
  
  <author>
    <name>mufan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS知识点一</title>
    <link href="http://htmlios.github.io/2017/02/09/iOS%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"/>
    <id>http://htmlios.github.io/2017/02/09/iOS知识点一/</id>
    <published>2017-02-09T02:00:00.000Z</published>
    <updated>2018-09-06T09:11:45.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="为什么要有hash方法？"><a href="#为什么要有hash方法？" class="headerlink" title="为什么要有hash方法？"></a>为什么要有hash方法？</h3><p>这个问题要从Hash Table这种数据结构说起</p><p>如果在数组中查找某个成员</p><ol><li>遍历数组中的成员；</li><li>将取出的值与目标值比较，如果相等，则返回该成员；</li></ol><p>在数组未排序的情况下，查找的时间复杂度是O(array_length)</p><p><code>为了提高查找速度</code>，Hash Table出现了</p><p>当成员被加入到Hash Table中时，会给他分配一个hash值，以标识该成员在集合中的位置</p><p>通过这个位置标识我们就可以把查找的时间复杂度优化到O(1)，当然如果多个成员都是同一位置标识，那么查找就不能达到O(1)了</p><p>重点：</p><blockquote><p>分配的这个hash值（即用于查找集合中成员的位置标识），就是通过hash方法计算得来的，且hash方法返回的hash值最好唯一</p></blockquote><p>和数组相比，基于hash值索引的Hash Table查找某个成员的过程就是：</p><ol><li>通过hash值直接找到查找目标的位置</li><li>如果目标位置上有多个相同hash值的成员，此时再按照数组的方法进行查找</li></ol><h3 id="Hash方法什么时候被调用？"><a href="#Hash方法什么时候被调用？" class="headerlink" title="Hash方法什么时候被调用？"></a>Hash方法什么时候被调用？</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Person *person = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    person.name = <span class="keyword">self</span>.name;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> hash = [<span class="keyword">super</span> hash];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hash = %@"</span>, @(hash));</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">Person *person1 = [[Person alloc] init];</span><br><span class="line">    Person *person2 = [[Person alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array1 = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [array1 addObject:person1];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array2 = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [array2 addObject:person2];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array end -------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableSet</span> *set1 = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    [set1 addObject:person1];</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *set2 = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    [set2 addObject:person2];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"set end -------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dictionaryValue1 = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [dictionaryValue1 setObject:person1 forKey:<span class="string">@"kKey1"</span>];</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dictionaryValue2 = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [dictionaryValue2 setObject:person2 forKey:<span class="string">@"kKey2"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dictionary value end -------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dictionaryKey1 = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [dictionaryKey1 setObject:<span class="string">@"kValue1"</span> forKey:person1];</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dictionaryKey2 = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [dictionaryKey2 setObject:<span class="string">@"kValue2"</span> forKey:person2];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dictionary key end -------------------------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array end -------------------------------</span><br><span class="line">hash = 105827994186080</span><br><span class="line">hash = 105827994186256</span><br><span class="line">set end -------------------------------</span><br><span class="line">dictionary value end -------------------------------</span><br><span class="line">hash = 105827994186080</span><br><span class="line">hash = 105827994186256</span><br><span class="line">dictionary key end -------------------------------</span><br></pre></td></tr></table></figure><p>从输出可以看到：</p><blockquote><p>hash方法只有在对象被添加到NSSet和设置为NSDictionary的key时会调用。</p></blockquote><p>NSSet在添加新成员时，需要根据hash值来快速查找成员，以保证集合中是否已经存在该成员；</p><p>NSDictionary在查找key时，也利用了key的hash值来提高查询效率；</p><h3 id="Hash方法与判等的关系？"><a href="#Hash方法与判等的关系？" class="headerlink" title="Hash方法与判等的关系？"></a>Hash方法与判等的关系？</h3><p>hash方法主要是用于Hash Table中查询成员用的，那和isEqual()有什么关系呢？</p><p>为了优化判等的效率，基于hash的NSSet和NSDictionary在判断成员是否相等时，会这样做：</p><ol><li>集合成员的hash值是否和目标hash值相等，如果相同进入Step 2，如果不等，直接判断不相等。</li><li>hash值相同（即Step 1）的情况下，再进行对象判等，作为判等结果。</li></ol><p>简要概之：</p><blockquote><p>hash值是对象判等的必要非充分条件；</p></blockquote><h3 id="如何重写自己的hash方法？"><a href="#如何重写自己的hash方法？" class="headerlink" title="如何重写自己的hash方法？"></a>如何重写自己的hash方法？</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person1 = [[Person alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1 = %ld"</span>, (<span class="built_in">NSUInteger</span>)person1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"[person1 hash] = %ld"</span>, [person1 hash]);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person1 = 105827994256016</span><br><span class="line">[person1 hash] = 105827994256016</span><br></pre></td></tr></table></figure><p>可见，[super hash]得到的就是对象的内存地址。</p><p>联系到前面hash值唯一性的要求，使用对象内存地址作为hash值不是很好么。</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="为什么用-weakify、-strongify？"><a href="#为什么用-weakify、-strongify？" class="headerlink" title="为什么用@weakify、@strongify？"></a>为什么用@weakify、@strongify？</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在block语句块中，如果需要引用block的持有者，就会造成循环引用，导致内存泄漏，比如以下代码。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> description];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般我们怎么解决，使用一个<code>__weak</code>修饰的weakVar变量指向block持有者，在block中使用weakVar。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    [weakSelf description];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这样写，还是可能出问题，因为weakSelf是弱引用，而self一旦释放，weakSelf可能为nil，举个例子：</p><ol><li><p>定义一个TestObj对象，他的属性有一个block对象</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObj</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (nonatomatic, <span class="keyword">copy</span>) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObj</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepTimeInterval:<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>在另一个类实例中定义一个testFunc方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)testFunc &#123;</span><br><span class="line">    TestObj *obj = [TestObj new];</span><br><span class="line">obj.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>testFunc</code>方法，结果打印的是(null)，因为block打印的方法是异步执行的，在<code>NSLog(@&quot;%@&quot;, weakSelf);</code>这句代码执行之前<code>testFunc</code>函数就结束，所以obj对象已经被释放了。</p></li></ol><p>怎么解决呢？所以再对<code>weakSelf</code>做一次<code>__strong</code>就可以了：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>)(<span class="string">@"%@"</span>, strongSelf);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用了<code>__strong</code>在<code>strongSelf</code>变量作用域结束之前，对<code>weakSelf</code>有一个引用，防止self提前释放。而作用域一过,<code>strongSelf</code>不存在了，对象(self)也会被释放。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>前面的写法虽然严谨了，也解决了问题，但是作为喜欢偷懒的程序员，会不会搞的很啰嗦？每次都要写那两条长长的<code>__weak</code>和<code>__strong</code>，而且在Block里面用到的self全部都要改成strongSelf，假设把一段很多self的代码拷贝到block里，一个个改成strongSelf是不是很蛋疼？</p><h4 id="RAC解决"><a href="#RAC解决" class="headerlink" title="RAC解决"></a>RAC解决</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[[button rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>只要在block外面使用了@weakSelf(self);然后在block里面写@strongify(self);就可以了，@strongify(self);语句后的self可以原封不动，好像很神奇，下面一起看看@weakify、@strongify这两个神奇的宏最终替换了什么东西。</p><p>导入RAC的头文件，把上面的测试代码替换成RAC中用的@weakify(self);和@strongify(self)，分屏显示Xcode，让右侧的显示内容改为preprocess，就可以看到宏最终替换的结果。</p><p><img src="/2017/02/09/iOS知识点一/1.jpg" alt="1.jpg"></p><ol><li><p>@autoreleasepool {} 是什么鬼？</p><p>注意到@weakify(self)前面的<code>@</code>颜色并不是橙色没有？<code>@</code>并不属于宏的一部分，当然你不能平白无故的写个@对吧，所以RAC的weakify宏定义机智地给你补了一句<code>autoreleasepool {}</code>这样一前一后就变成啥事都没干的@autoreleasepool {}。</p></li><li><p>__attribute__((objc_ownership(weak)))是什么鬼？</p><p>这个就是__weak在编译前被编译器替换的结果，weakify这个宏后面最终替换成__weak（后面说到），所以编译器再替换就成了__attribute__((objc_ownership(weak)))</p></li></ol><h4 id="weakify、-strongify的定义（网上有很多文章）"><a href="#weakify、-strongify的定义（网上有很多文章）" class="headerlink" title="@weakify、@strongify的定义（网上有很多文章）"></a>@weakify、@strongify的定义（网上有很多文章）</h4><p>推荐一篇<a href="http://www.cocoachina.com/ios/20161025/17303.html" target="_blank" rel="noopener">@weakify、@strongify的定义</a></p><h2 id="使用代码自定义UIView注意"><a href="#使用代码自定义UIView注意" class="headerlink" title="使用代码自定义UIView注意"></a>使用代码自定义UIView注意</h2><h3 id="自定义UIView要重写初始化方法initWithFrame-方法而不是init"><a href="#自定义UIView要重写初始化方法initWithFrame-方法而不是init" class="headerlink" title="自定义UIView要重写初始化方法initWithFrame:方法而不是init"></a>自定义UIView要重写初始化方法<code>initWithFrame:</code>方法而不是<code>init</code></h3><p>为什么？因为当外部调用<code>init</code>方法时，内部会自动调用<code>initWithFrame:</code>方法，你不能保证你的同事一定不会调用<code>initWithFrame:</code>方法，那么你需要初始化时候做的一些事情就做不了了。</p><p>于是应该写成这样：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="comment">/** 添加子控件的代码 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要在构造方法里直接取自身-self，或者说本视图-的宽高"><a href="#不要在构造方法里直接取自身-self，或者说本视图-的宽高" class="headerlink" title="不要在构造方法里直接取自身(self，或者说本视图)的宽高"></a>不要在构造方法里直接取自身(self，或者说本视图)的宽高</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="comment">/** 添加子控件 */</span></span><br><span class="line">        <span class="keyword">self</span>.imageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.imageView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, </span><br><span class="line">                                          <span class="number">0</span>, </span><br><span class="line">                                          <span class="keyword">self</span>.frame.size.width, </span><br><span class="line">                                          <span class="keyword">self</span>.frame.size.height);</span><br><span class="line">        [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.imageView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写有问题么？如果全部写好运行起来，能看到imageView么？答案是不确定，问题就出在<code>imageView.frame</code>赋值那里，<code>imageView</code>取的宽高都是<code>self</code>的宽高，但是这个时候<code>self.frame</code>可能是没有值的，也就是说可能宽高都是0。</p><p>上面我们说过了，如果外部调用了<code>init</code>方法，也会执行到这里，这时候<code>frame</code>的值是<code>CGRectZearo</code>。</p><p>这类情况我们初学的时候基本都遇到过，<code>UITableViewCell</code>自定义的时候，重写初始化方法，在初始化方法里写一个label居cell底部（假设cell的高度是100）</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        ...</span><br><span class="line">label.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.frame.size.height - <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行出来我们发现label并不在我们期望的位置（底部），而是在cell中比较偏上的位置（实际y值是44-20，而不是100-20）。</p><p>debug后我们发现，虽然我们重新设置了cell的高度是100，但是初始化方法取到的cell的高度仍然是默认的44。</p><p>这其实就是我们说的问题本身，不能在构造方法里直接取frame或者bounds，这时候取值是不准确的。</p><p>所以构造方法里面，我们只需要把控件放进去，暂时不用考虑他们在什么位置：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView = [[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">        [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.imageView];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.label = [[<span class="built_in">UILabel</span> alloc]init];</span><br><span class="line">        <span class="keyword">self</span>.label.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.label];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那什么时候设置子控件的frame呢？</p><p>引出第三个问题：</p><h3 id="在layoutSubviews方法里面布局子控件"><a href="#在layoutSubviews方法里面布局子控件" class="headerlink" title="在layoutSubviews方法里面布局子控件"></a>在layoutSubviews方法里面布局子控件</h3><p>如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    <span class="comment">// 一定要调用super方法</span></span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定子控件的frame（这里得到的self的frame/bounds才是准确的）</span></span><br><span class="line">    <span class="built_in">CGFloat</span> width = <span class="keyword">self</span>.bounds.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> height = <span class="keyword">self</span>.bounds.size.height;</span><br><span class="line">    <span class="keyword">self</span>.imageView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, width);</span><br><span class="line">    <span class="keyword">self</span>.label.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, width, width, height - width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里面我们可以获取到准确的宽高及frame和bounds，所以在这里布局比较合适。</p><p>这里需要注意的是一定要调用父类的layoutSubviews方法。</p><h2 id="关于-property和-synthesize的进一步理解"><a href="#关于-property和-synthesize的进一步理解" class="headerlink" title="关于@property和@synthesize的进一步理解"></a>关于@property和@synthesize的进一步理解</h2><p>@property一行代码编译器就会自动帮我们生成getter和setter方法的(@property声明)声明和(@synthesize实现)实现，同时在.m文件中声明一个和属性名一样并且有前置下划线的成员变量（private）</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br></pre></td></tr></table></figure><p>当我们同时重写一个属性的setter和getter方法时，系统会报错，原因：@property默认给属性自动生成getter和setter方法，当getter和setter被同时重写时，系统就不会自动生成getter和setter方法了，也不会自动帮你生成_age变量，所以不会识别_age，找不到_age这个变量。</p><p>解决办法：</p><p>第一种在.h文件中声明这个属性：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>第二种在.m文件中使用@synthesize</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> age = _age;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>初学者可能觉得这句特别奇怪</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> age = _age;</span><br></pre></td></tr></table></figure><p>实际上它是告诉编译器age属性为_age实例变量生成getter和setter方法的实现。</p><p>也就是说age属性的setter方法是setAge，它操作的是_age这个成员变量。</p><h2 id="iOS中通知和KVO"><a href="#iOS中通知和KVO" class="headerlink" title="iOS中通知和KVO"></a>iOS中通知和KVO</h2><h3 id="iOS中通知在哪个线程上发出通知，接收通知就在哪个线程上"><a href="#iOS中通知在哪个线程上发出通知，接收通知就在哪个线程上" class="headerlink" title="iOS中通知在哪个线程上发出通知，接收通知就在哪个线程上"></a>iOS中通知在哪个线程上发出通知，接收通知就在哪个线程上</h3><h3 id="KVO也一样，在哪个线程上做的改变，接收就在哪个线程上"><a href="#KVO也一样，在哪个线程上做的改变，接收就在哪个线程上" class="headerlink" title="KVO也一样，在哪个线程上做的改变，接收就在哪个线程上"></a>KVO也一样，在哪个线程上做的改变，接收就在哪个线程上</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="string">@"abc"</span></span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(notificationRecived:)</span><br><span class="line">                                                 name:<span class="string">@"testNotification"</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span>([keyPath isEqualToString:<span class="string">@"abc"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"KVO: abc:%@ currentThread:%s"</span>, @(<span class="keyword">self</span>.abc), dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)notificationRecived:(<span class="built_in">NSNotification</span> *)note &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"notification: abc:%@ currentThread:%s"</span>, @(<span class="keyword">self</span>.abc), dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"ABCD"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.abc += <span class="number">1</span>;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"testNotification"</span> object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次触摸屏幕控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KVO: abc:2 currentThread:ABCD</span><br><span class="line">notification: abc:2 currentThread:ABCD</span><br><span class="line">KVO: abc:3 currentThread:ABCD</span><br><span class="line">notification: abc:3 currentThread:ABCD</span><br><span class="line">KVO: abc:4 currentThread:ABCD</span><br><span class="line">notification: abc:4 currentThread:ABCD</span><br><span class="line">KVO: abc:5 currentThread:ABCD</span><br><span class="line">notification: abc:5 currentThread:ABCD</span><br></pre></td></tr></table></figure><p>我们注意到接收处的当前线程id都是ABCD，而非主线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hash&quot;&gt;&lt;a href=&quot;#Hash&quot; class=&quot;headerlink&quot; title=&quot;Hash&quot;&gt;&lt;/a&gt;Hash&lt;/h2&gt;&lt;h3 id=&quot;为什么要有hash方法？&quot;&gt;&lt;a href=&quot;#为什么要有hash方法？&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>将自己的SDK上传到Github并用cocoapods管理</title>
    <link href="http://htmlios.github.io/2017/01/07/%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84SDK%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E5%B9%B6%E7%94%A8cocoapods%E7%AE%A1%E7%90%86/"/>
    <id>http://htmlios.github.io/2017/01/07/将自己的SDK上传到Github并用cocoapods管理/</id>
    <published>2017-01-07T01:22:00.000Z</published>
    <updated>2018-08-07T02:26:27.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github创建存储库；"><a href="#Github创建存储库；" class="headerlink" title="Github创建存储库；"></a>Github创建存储库；</h3><h3 id="将需要cocoapods托管的SDK上传到Github存储库且发布到cocoapods上；"><a href="#将需要cocoapods托管的SDK上传到Github存储库且发布到cocoapods上；" class="headerlink" title="将需要cocoapods托管的SDK上传到Github存储库且发布到cocoapods上；"></a>将需要cocoapods托管的SDK上传到Github存储库且发布到cocoapods上；</h3><h4 id="创建pod账号"><a href="#创建pod账号" class="headerlink" title="创建pod账号"></a>创建pod账号</h4><p>发布到cocoapods上你需要有一个pod的账号，可以使用 <code>pod trunk me</code>命令来查看自己的账号信息，如果没有账号的话先注册一个；</p><blockquote><p>pod trunk register [email] ‘昵称’；//（通过后打开邮箱验证）</p></blockquote><h4 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h4><p>使用终端进入到工程文件的目录中，在README.md文件所在的位置创建一个podspec文件，命令<code>pod spec create 项目名称</code></p><p>编辑podspec文件，新创建的podspec文件里面有大量的信息不用填就可以，我们只需要拷贝成熟的podspec文件里的内容，然后做出自己所需要的改动即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         = &quot;xxx&quot;    #存储库名称</span><br><span class="line">  s.version      = &quot;0.0.1&quot;      #版本号，与tag值一致</span><br><span class="line">  s.summary      = &quot;a repository demo&quot;  #简介</span><br><span class="line">  s.description  = &quot;a repository demo&quot;  #描述</span><br><span class="line">  s.homepage     = &quot;https://github.com/xxx&quot;      #项目主页，不是git地址</span><br><span class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;   #开源协议</span><br><span class="line">  s.author             = &#123; &quot;xxx&quot; =&gt; &quot;xxx&quot; &#125;  #作者</span><br><span class="line">  s.platform     = :ios, &quot;7.0&quot;                  #支持的平台和版本号</span><br><span class="line">  s.source       = &#123; :git =&gt; &quot;https://github.com/xxx.git&quot;, :tag =&gt; &quot;0.0.1&quot; &#125;         #存储库的git地址，以及tag值</span><br><span class="line">  s.source_files  =  &quot;xxx/Other/**/*.&#123;h,m&#125;&quot; #需要托管的源代码路径</span><br><span class="line">  s.requires_arc = true #是否支持ARC</span><br><span class="line">  s.dependency &quot;Masonry&quot;, &quot;~&gt; 1.0.0&quot;    #所依赖的第三方库，没有就不用写</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>设置tag的值，并上传到github上</p><ol><li>git add *(将代码添加到暂存区)</li><li>git commit -m ‘提交内容’(将代码提交到本地库)</li><li>git tag ‘xxx’(设置本地分支的版本，xxx必须是你在.podspec文件中的version版本号)</li><li>git tag(使用此命令查看tag的值是否设置成功)</li><li>git push origin master(将本地主干提交到远程服务端)</li><li>git push origin xxx(将本地xxx版本上传到github服务器上并设置origin为xxx)</li></ol><h4 id="发布到到cocoapods上进行托管"><a href="#发布到到cocoapods上进行托管" class="headerlink" title="发布到到cocoapods上进行托管"></a>发布到到cocoapods上进行托管</h4><ol><li><p>先用<code>pod spec lint</code> 验证podspec文件，如果报警告就用<code>pod spec lint --allow-warnings</code>来忽略所有警告</p></li><li><p>发布，输入<code>pod trunk push --allow-warinings</code>命令发布到cocoapods上，这可能需要几分钟的时间</p></li><li><p>使用<code>pod search xxx --simple</code>搜索自己的库，之搜索库名称</p></li><li><p>新建工程，然后导入自己刚发布的库，podfile文件如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line">target &apos;TestDemo&apos; do</span><br><span class="line">pod &apos;xxx&apos;, &apos;~&gt;0.0.1&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Github创建存储库；&quot;&gt;&lt;a href=&quot;#Github创建存储库；&quot; class=&quot;headerlink&quot; title=&quot;Github创建存储库；&quot;&gt;&lt;/a&gt;Github创建存储库；&lt;/h3&gt;&lt;h3 id=&quot;将需要cocoapods托管的SDK上传到Gith
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="cocoapods" scheme="http://htmlios.github.io/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出iOS多线程</title>
    <link href="http://htmlios.github.io/2016/12/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://htmlios.github.io/2016/12/23/深入浅出iOS多线程/</id>
    <published>2016-12-23T08:01:00.000Z</published>
    <updated>2018-09-07T02:49:30.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列和任务"><a href="#队列和任务" class="headerlink" title="队列和任务"></a>队列和任务</h3><p>队列分为串行队列和并行队列</p><p>任务的执行分为同步和异步</p><p>以上两两组合就成为了：1、串行队列同步执行;2、串行队列异步执行;3、并行队列同步执行;4、并行队列异步执行。</p><p>异步是多线程的代名词，异步在实际应用中会开启新的线程，执行耗时操作。</p><p>一个很重要的事情：</p><p>队列只负责任务的调度，而不负责任务的执行；</p><p>任务是在线程中执行的；</p><h4 id="队列和任务的特点"><a href="#队列和任务的特点" class="headerlink" title="队列和任务的特点"></a>队列和任务的特点</h4><p>队列特点：先进先出，排在前面的任务最先执行；</p><p>串行队列：任务按照顺序被调度，前一个任务不执行完毕，队列不会调度；</p><p>并行队列：只要有空闲的线程，队列就会调度当前任务，交给线程去执行，不需要考虑前面是否有任务在执行，只要有线程可以利用，队列就会调度任务。</p><p>主队列：专门用来在主线程调度任务的队列，所以主队列的任务都在主线程来执行，主队列会随着程序的启动一起创建，我们只需要get即可。</p><p>全局队列：是系统为了方便程序员开发提供的，其工作表现与并发队列一致。</p><p>全局队列跟并发队列的区别是什么？</p><ol><li>全局队列：无论在ARC还是MRC都不需要考虑释放，因为系统提供的我们只需要get就可以。</li><li>并发队列：在MRC下，并发队列创建出来后，需要手动释放dispatch_release();</li></ol><p>同步执行：不会开启新的线程，任务按顺序执行；</p><p>异步执行：会开启新的线程，任务可以并发的执行；</p><h4 id="多线程的几种组合特点"><a href="#多线程的几种组合特点" class="headerlink" title="多线程的几种组合特点"></a>多线程的几种组合特点</h4><ol><li><p>串行队列同步执行</p><blockquote><p>综合串行队列的特点：按顺序执行；同步：不会开启新的线程；则串行队列同步执行只是按部就班one by one就行。</p></blockquote></li><li><p>串行队列异步执行</p><blockquote><p>虽然队列中存放的是异步执行的任务，但是结合串行队列的特点，前一个任务不执行完毕，队列不会调度，所以串行队列异步执行也还是one by one执行。</p></blockquote></li><li><p>并行队列同步执行</p><blockquote><p>综合并行队列的特点，和同步执行的特点，可以明确分析出来，虽然并行队列可以不需要等待前一个执行完毕就可以调度下一个任务，但是任务同步执行不会开启新的线程，所以任务还是one by one的执行。</p></blockquote></li><li><p>并行队列异步执行</p><blockquote><p>并行队列不需要等待前一个执行完毕就可以调度下一个任务，异步执行任务时可以开启新的线程，所以这种组合可以实现任务并发，在实际开发中也经常用到。</p></blockquote></li></ol><h3 id="多线程在iOS中的使用：GCD"><a href="#多线程在iOS中的使用：GCD" class="headerlink" title="多线程在iOS中的使用：GCD"></a>多线程在iOS中的使用：GCD</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>GCD，全称Grand Central Dispatch ，是iOS用来管理线程的技术。纯C语言，提供了非常多强大的函数。</p><h4 id="GCD优势"><a href="#GCD优势" class="headerlink" title="GCD优势"></a>GCD优势</h4><p>GCD会自动利用更多的CPU模块（比如双核、四核）。</p><p>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。</p><p>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。</p><h4 id="为什么要使用GCD"><a href="#为什么要使用GCD" class="headerlink" title="为什么要使用GCD"></a>为什么要使用GCD</h4><p>为了提高软件性能，应该异步执行耗时任务（图片加载），以防影响主线程任务的执行（UI相关）。</p><blockquote><p>例如：</p><p>从网络加载一张图片，如果将其放到主线程，那么在下载完成的时间里，软件是无法响应用户的其他操作。特别，如果当前是可以滚动的页面，就会造成无法滚动这种体验非常差。</p></blockquote><p>所以，应该将网络加载放在异步线程里执行，执行成功后，再回到主线程显示加载后的图片。</p><h4 id="GCD的使用步骤"><a href="#GCD的使用步骤" class="headerlink" title="GCD的使用步骤"></a>GCD的使用步骤</h4><ol><li>由开发者指定要执行的任务；</li><li>将任务添加到队列中，GCD会自动将队列中的任务取出，放到对应的线程中执行；</li></ol><blockquote><p>注意：</p><p>任务取出遵循队列的FIFO原则：先进先出，后进后出。</p></blockquote><h4 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h4><p>队列是用来存放任务的，由GCD将这些任务从队列中取出放到对应的线程中执行。</p><h4 id="GCD的队列可以分为2大类型："><a href="#GCD的队列可以分为2大类型：" class="headerlink" title="GCD的队列可以分为2大类型："></a>GCD的队列可以分为2大类型：</h4><h5 id="1-并发队列（Concurrent-Dispatch-Queue）"><a href="#1-并发队列（Concurrent-Dispatch-Queue）" class="headerlink" title="1.并发队列（Concurrent Dispatch Queue）"></a>1.并发队列（Concurrent Dispatch Queue）</h5><p>可以让多个任务并发（同时）执行（自动开启多个线程执行任务），并发功能只有在异步（dispatch_async）函数下才有效。</p><h5 id="2-串行队列（Serial-Dispatch-Queue）"><a href="#2-串行队列（Serial-Dispatch-Queue）" class="headerlink" title="2.串行队列（Serial Dispatch Queue）"></a>2.串行队列（Serial Dispatch Queue）</h5><p>让任务一个接一个的执行（一个任务执行完毕后，再执行下一个任务）。</p><h5 id="队列和线程有什么区别？"><a href="#队列和线程有什么区别？" class="headerlink" title="队列和线程有什么区别？"></a>队列和线程有什么区别？</h5><p>简单来说，队列就是用来存放任务的“暂存区”，而线程是执行任务的路径，GCD将这些存在于队列的任务取出放到相应线程上去执行，而队列的性质决定了在其中的任务在哪种线程上执行。</p><p>下图直观的展示了任务、队列、线程的关系：</p><p><img src="/2016/12/23/深入浅出iOS多线程/1.png" alt="img"></p><blockquote><p>在这里，我们可以看到，放入队列的任务会一个一个地执行。而放入并行队列的任务，会在多个线程并发地执行。</p></blockquote><h4 id="队列的创建："><a href="#队列的创建：" class="headerlink" title="队列的创建："></a>队列的创建：</h4><h5 id="串行队列的创建："><a href="#串行队列的创建：" class="headerlink" title="串行队列的创建："></a>串行队列的创建：</h5><p>GCD中获取串行有2种途径：</p><ol><li><p>使用<code>dispatch_queue_create</code>函数创建串行队列</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建串行队列(队列类型传递NULL或者DISPATCH_QUEUE_SERIAL)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用主队列（跟主线程关联的队列）</p><p>主队列是GCD自带的一种特殊的串行队列；放在主队列中的任务，都会放到主线程中执行。</p><p>使用<code>dispatch_get_main_queue()</code>获得系统提供的主队列</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></li></ol><h5 id="并发队列的创建："><a href="#并发队列的创建：" class="headerlink" title="并发队列的创建："></a>并发队列的创建：</h5><ol><li><p>使用<code>dispatch_queue_create</code>函数创建并发队列</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"concurrent_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>dispatch_get_global_queue</code>获得全局并发队列</p><p>GCD默认提供了全局并发队列，供整个应用使用，可以无需手动创建。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="GCD的几种重要的应用"><a href="#GCD的几种重要的应用" class="headerlink" title="GCD的几种重要的应用"></a>GCD的几种重要的应用</h4><h5 id="子线程与主线程的通信"><a href="#子线程与主线程的通信" class="headerlink" title="子线程与主线程的通信"></a>子线程与主线程的通信</h5><p>需求点：我们有时需要在子线程处理一个耗时比较长的任务，而且此任务完成后，要在主线程执行另一任务。</p><p>例子：从网络加载图片（在子线程），加载完成后更新UI（在主线程）。</p><p>为了实现这个需求，我们需要首先拿到全局并发队列（或者自己开一个子线程）来执行耗时操作，然后在其完成的block中拿到全局串行队列来执行UI刷新的任务。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">   <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="built_in">NSData</span> *dataFromURL = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageURL];</span><br><span class="line">    <span class="built_in">UIImage</span> *imageFromData = [<span class="built_in">UIImage</span> imageWithData:dataFromURL];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 显示加载好的image</span></span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:imageFromData];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>以笔者的拙见，除了复杂的算法，网络请求外，大多数<code>dataWithContentsOf...</code>函数也会比较耗时，所以以后遇到与NSData交互的操作时，尽量将其放在子线程执行。</p></blockquote><h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h5><p>需求点：用于程序启动到终止，只执行一次的代码。此代码执行后，相当于自身全部被加上了注释，不会再执行了。</p><p>为了实现这个需求，我们需要使用<code>dispatch_once</code>让代码运行一次后就被“雪藏”。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行一次的代码，这里默认是线程安全的：不会有其他线程访问到这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h5><p>需求点：执行多个耗时的异步任务，但是只能等到这些任务执行完成后，才能在主线程中执行某个任务。</p><p>为了实现这个需求，我们需要将这些异步操作放在<code>dispatch_group_async</code>函数中执行，最后再调用<code>dispatch_group_notify</code>来执行最后的任务。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_asyn(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_asyn(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_asyn(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_asyn(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">40000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>); </span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完成后，回到主线程...</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"都完成了"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2016/12/23/深入浅出iOS多线程/2.png" alt="运行结果"></p><blockquote><p>从三次运行结果来看：</p><ol><li>异步执行的任务1-5的最终完成时间是与其自身完成任务所需的时间并无关联。因为任务5是最耗时的，它在第一次运行结果里并不是最后才完成的。任务1是最不耗时的，但是它在第二次运行结果里并不是最先完成的。</li><li>异步执行的任务1-5无论完成顺序如何，只有他们都完成了才会调用主线程的打印“都完成了”。</li></ol></blockquote><h5 id="dispatch-barrier"><a href="#dispatch-barrier" class="headerlink" title="dispatch_barrier"></a>dispatch_barrier</h5><p>需求点：虽然我们有时候需要执行几个不同的异步任务，但是我们想将其分成两组，当第一组异步任务执行完成后才执行第二组异步任务。这里的组可以包含一个任务，也可以包含多个任务。</p><p>为了实现这个需求，我们需要使用<code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code>在两组任务之间形成“栅栏”，使其“下方”的异步任务在其“上方”的异步任务都完成之前是无法执行的。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"123123123"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">200000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---分割线---"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">400000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">500000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务5"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">600000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务6"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2016/12/23/深入浅出iOS多线程/3.png" alt="栅栏"></p><blockquote><p>从三次运行结果来看：</p><ol><li>无论任务1-3内部执行顺序如何，只有当三个都完成了才会执行任务4-6。</li><li>1-3内部的执行顺序和4-6内部的执行顺序都是不可控的，同上一个知识点类似。</li></ol></blockquote><h3 id="线程安全与锁"><a href="#线程安全与锁" class="headerlink" title="线程安全与锁"></a>线程安全与锁</h3><blockquote><p>在iOS编程中，锁的出现是为了解决多线程中出现的线程安全的问题。那么，什么是线程安全？为什么锁可以解决多线程安全问题？单线程是不是绝对线程安全？iOS变成有多少种锁？加解锁的效率如何？</p></blockquote><h4 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h4><p>多线程操作共享数据不会出现意想不到的结果就是线程安全的，否则，是线程不安全的。</p><p>举个例子未加锁：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        total += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"total:%@"</span>, @(total));</span><br><span class="line">        total -= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"total:%@"</span>, @(total));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第一次输出：</span><br><span class="line">total:1</span><br><span class="line">total:3</span><br><span class="line">total:2</span><br><span class="line">total:2</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br><span class="line">// 第二次输出</span><br><span class="line">total:1</span><br><span class="line">total:2</span><br><span class="line">total:3</span><br><span class="line">total:2</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br></pre></td></tr></table></figure><p>加锁：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSLock</span> *lock = [<span class="built_in">NSLock</span> new];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        total += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"total:%@"</span>, @(total));</span><br><span class="line">        total -= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"total:%@"</span>, @(total));</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第一次输出：</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br><span class="line">// 第二次输出</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br><span class="line">total:1</span><br><span class="line">total:0</span><br></pre></td></tr></table></figure><p>未加锁的第一次和第二次调用结果不一样，换句话说，不能确定代码的运行顺序和结果，是线程不安全的；加锁后的第一次和第二次调用结果一样，和预期结果也一致，可以确定执行结果，是线程安全的。</p><h4 id="锁的介绍"><a href="#锁的介绍" class="headerlink" title="锁的介绍"></a>锁的介绍</h4><p>线程不安全是由于多线程访问造成的，那么如何解决？</p><ol><li>既然线程安全是多线程造成的，那么最极端的就是不用多线程，用单线程来保证线程安全。</li><li>线程安全是由于多线程访问和修改共享资源引起不可预测的结果，因此，如果都是访问共享资源，而不去修改共享资源也可以保证线程安全，比如：设置只读属性的全局变量。</li><li>使用锁。</li></ol><p>下面对几种常见的锁的用法和实现原理做总结和介绍<a href="https://link.jianshu.com/?t=https://bestswifter.com/ios-lock/" target="_blank" rel="noopener">深入理解 iOS 开发中的锁</a>：</p><p><strong>OSSpinLock</strong>:</p><p>自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取锁就需要等待a线程释放锁。在没有获得锁的期间，b线程一直处于忙等的状态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。</p><p>自旋锁的代码示例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import OSSpinLock lock = OS_SPINLOCK_INIT;</span></span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br><span class="line"><span class="comment">//OSSPINLOCK_DEPRECATED_REPLACE_WITH(os_unfair_lock)</span></span><br><span class="line"><span class="comment">//苹果在OSSpinLock注释表示被废弃，改用不安全的锁替代</span></span><br></pre></td></tr></table></figure><p><strong>dispatch_semaphore:</strong></p><p>dispatch_semaphore实现原理和自旋锁有点不一样。信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。</p><p>其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。</p><p>信号量主要有3个函数，分别是：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建信号量，最多可几个资源访问，参数：信号量的初值，如果小于0则会返回NULL</span></span><br><span class="line">dispatch_semaphore_create（信号量值）</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等待降低信号量:信号量-1</span></span><br><span class="line">dispatch_semaphore_wait（信号量，等待时间）</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提高信号量:信号量+1</span></span><br><span class="line">dispatch_semaphore_signal(信号量)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchSignal &#123;</span><br><span class="line">    dipatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务1</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run task 1"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"complete task 1"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务2</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run task 2"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"complete task 2"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务3</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"run task 3"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"complete task 3"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run task 1</span><br><span class="line">run task 2</span><br><span class="line">complete task 2</span><br><span class="line">complete task 1</span><br><span class="line">run task 3</span><br><span class="line">complete task 3</span><br></pre></td></tr></table></figure><p>由于设定的信号值为2，先执行两个线程，等执行完一个，才会继续执行下一个，保证同一时间执行的线程数不超过2。</p><p>假设我们设定信号值=1</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_create(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>那么结果就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run task 1</span><br><span class="line">complete task 1</span><br><span class="line">run task 2</span><br><span class="line">complete task 2</span><br><span class="line">run task 3</span><br><span class="line">complete task 3</span><br></pre></td></tr></table></figure><p>如果设定信号值=3</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_create(3);</span><br></pre></td></tr></table></figure><p>那么结果就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run task 2</span><br><span class="line">run task 3</span><br><span class="line">run task 1</span><br><span class="line">complete task 2</span><br><span class="line">complete task 1</span><br><span class="line">complete task 3</span><br></pre></td></tr></table></figure><p>设定为3，就不限制线程执行了，因为一共只有3个线程。</p><p><strong>pthread_mutex:</strong></p><p>pthread_mutex表示互斥锁，和信号量的实现原理相似，也是阻塞线程进入睡眠，需要进行上下文切换。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">pthread_mutex_t _lock;</span><br><span class="line">pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>); <span class="comment">//初始化一个互斥锁</span></span><br><span class="line">pthread_mutex_lock(&amp;_lock); <span class="comment">//加锁，线程进入临界区，其他线程在外面等待</span></span><br><span class="line">...... <span class="comment">//执行临界区代码</span></span><br><span class="line">pthread_mutex_unlock(&amp;_lock); <span class="comment">//解锁，线程离开临界区，其他线程进入临界区执行</span></span><br><span class="line">pthread_mutex_destroy(&amp;_lock); <span class="comment">//最后销毁互斥锁</span></span><br></pre></td></tr></table></figure><p><strong>NSLock:</strong></p><p>NSLock在内部封装了一个pthread_mutex，属性为PTHREAD_MUTEX_ERRORCHECK。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [<span class="built_in">NSLock</span> new];</span><br><span class="line">[lock lock];</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure><p><strong>NSCondition:</strong></p><p>NSCondition封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件变量保证执行顺序。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSCondition</span> *lock = [<span class="built_in">NSCondition</span> new];</span><br><span class="line">[lock lock];</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure><p><strong>pthread_mutex(recursive)：</strong></p><p>pthread_mutex锁的一种，属于递归锁。一般一个线程只能申请一把锁，但是，如果是递归锁，则可以申请很多把锁，只要上锁和解锁的操作数量就不会报错。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">     </span><br><span class="line">pthread_mutex_t lock;</span><br><span class="line">pthread_mutex_init(&amp;lock, &amp;attr);    <span class="comment">//设置属性</span></span><br><span class="line">     </span><br><span class="line">pthread_mutex_lock(&amp;lock);    <span class="comment">//上锁</span></span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);    <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p><strong>NSRecursiveLock:</strong></p><p>递归锁，pthread_mutex(recursive)的封装。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSRecursiveLock</span> *lock = [<span class="built_in">NSRecursiveLock</span> new];</span><br><span class="line">[lock lock];</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure><p><strong>NSConditionLock:</strong></p><p>NSConditionLock借助NSCondition来实现，本质是生产者和消费者模型。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSConditionLock</span> *lock = [<span class="built_in">NSConditionLock</span> new];</span><br><span class="line">[lock lock];</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure><p><strong>@synchronized:</strong></p><p>一个对象层面的锁，锁住了整个对象，底层使用了互斥递归锁来实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *object = [NSObject new];</span><br><span class="line">@synchronized(object) &#123;</span><br><span class="line">  //需要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程常见的一些问题："><a href="#多线程常见的一些问题：" class="headerlink" title="多线程常见的一些问题："></a>多线程常见的一些问题：</h3><h4 id="GCD死锁问题："><a href="#GCD死锁问题：" class="headerlink" title="GCD死锁问题："></a>GCD死锁问题：</h4><p>概念：</p><p>同步：会阻塞当前线程，等block(任务)执行完成后，当前线程才会继续往下执行。</p><p>异步：不会阻塞当前线程。</p><p>案例一（死锁）：同步串行</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span><br></pre></td></tr></table></figure><p>死锁原因：</p><ol><li>NSLog(@”任务1”); // 正常</li><li>dispatch_sync(dispatch_get_main_queue(),); // 同步操作阻塞主线程，需要等<code>任务2</code>执行完才算完成</li><li>NSLog(@”任务3”); // 上一步同步操作已经卡死，不会执行到这里</li><li>block(^{ NSLog(@”任务2”) }); // 等待<code>任务3</code>执行完才能执行</li></ol><blockquote><p>2等4执行完，但是4在等2和3执行完，相互等待造成死锁；</p><p>同步向串行队列添加任务的时候，需要队列任务都执行完才能添加，所以<code>任务2</code>添加在<code>任务3</code>后面;</p></blockquote><p><img src="/2016/12/23/深入浅出iOS多线程/4.png" alt="案例一"></p><p>案例二（不会死锁）：同步并行</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务1</span><br><span class="line">任务2</span><br><span class="line">任务3</span><br></pre></td></tr></table></figure><p>分析过程：</p><ol><li><p>NSLog(@”任务1”);</p></li><li><p>dispatch_sync(dispatch_get_global_queue(0, 0)) // 同步操作阻塞主线程，向global并行队列添加<code>任务2</code></p><blockquote><p>NSLog(@”任务2”); // global执行完<code>任务2</code>，同步操作就执行完毕</p></blockquote></li><li><p>NSLog(@”任务3”);</p></li></ol><p><img src="/2016/12/23/深入浅出iOS多线程/5.png" alt="案例二"></p><p>案例三(会死锁)：同步异步都有</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务1</span><br><span class="line">任务5</span><br><span class="line">任务2</span><br><span class="line">// “任务2”和“任务5”顺序不一定</span><br></pre></td></tr></table></figure><p>死锁原因：</p><ol><li><p>NSLog(@”任务1”);</p></li><li><p>dispatch_async(queue);  // 异步操作不阻塞主线程，主线程继续执行<code>任务5</code></p><blockquote><ol><li>NSLog(@”任务2”); // 正常</li><li>dispatch_sync(queue) // 同步操作阻塞子线程，等待<code>任务3</code>执行完毕才算执行完毕</li><li>NSLog(@”任务4”); // 等待同步操作(上一条)执行完毕</li><li>block(NSLog(@”任务3”)); // 等待<code>任务4</code>执行完毕</li></ol></blockquote></li><li><p>NSLog(@”任务5”); // 主线程正常执行</p></li></ol><p>案例四(不会死锁)：异步遇到同步回到主线程</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务1</span><br><span class="line">任务5</span><br><span class="line">任务2</span><br><span class="line">任务3</span><br><span class="line">任务4</span><br><span class="line">// `任务5` 和 `任务2`顺序不一定</span><br></pre></td></tr></table></figure><p>分析过程：</p><ol><li><p>NSLog(@”任务1”);</p></li><li><p>dispatch_async(dispatch_get_global_queue); // 异步操作不阻塞主线程，主线程继续执行<code>任务5</code></p><blockquote><ol><li><p>NSLog(@”任务2”);</p></li><li><p>dispatch_sync(dispatch_get_main_queue); // 同步操作阻塞子线程(global)</p><blockquote><p>NSLog(@”任务3”); // 执行完成同步操作完成</p></blockquote></li><li><p>NSLog(@”任务4”); // 执行完成异步操作执行完成</p></li></ol></blockquote></li><li><p>NSLog(@”任务5”);</p></li></ol><p>案例五：主线程死循环</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务6"</span>);</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务1</span><br><span class="line">任务5</span><br><span class="line">任务2</span><br><span class="line">// `任务5` 和 `任务2` 顺序不一定</span><br></pre></td></tr></table></figure><p>分析过程：</p><ol><li><p>NSLog(@”任务1”);</p></li><li><p>dispatch_async(dispatch_get_global_queue); // 异步操作不会阻塞主线程，主线程继续执行</p><blockquote><ol><li><p>NSLog(任务2);</p></li><li><p>dispatch_sync(dispatch_get_main_queue); // 同步阻塞子线程，<code>任务3</code>执行完毕才算完成</p><blockquote><p>NSLog(@”任务3”); // 因为是在主线程，要等主线程<code>任务6</code>执行完毕才会执行<code>任务3</code></p></blockquote></li><li><p>NSLog(@”任务4”); // 等待上一条执行完毕，才会执行</p></li></ol></blockquote></li><li><p>NSLog(@”任务5”);</p></li><li><p>while(1) {} // 主线程死循环，阻塞在这里</p></li><li><p>NSLog(@”任务6”);</p></li></ol><h4 id="GCD获取当前线程id"><a href="#GCD获取当前线程id" class="headerlink" title="GCD获取当前线程id"></a>GCD获取当前线程id</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"currentThread:%s"</span>, dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列和任务&quot;&gt;&lt;a href=&quot;#队列和任务&quot; class=&quot;headerlink&quot; title=&quot;队列和任务&quot;&gt;&lt;/a&gt;队列和任务&lt;/h3&gt;&lt;p&gt;队列分为串行队列和并行队列&lt;/p&gt;
&lt;p&gt;任务的执行分为同步和异步&lt;/p&gt;
&lt;p&gt;以上两两组合就成为了：1、串行队列
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
      <category term="多线程" scheme="http://htmlios.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS查找算法</title>
    <link href="http://htmlios.github.io/2016/09/16/iOS%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://htmlios.github.io/2016/09/16/iOS查找算法/</id>
    <published>2016-09-16T02:21:00.000Z</published>
    <updated>2018-07-16T06:28:44.553Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>算法思想：首先查找数组必须有序，用要查找键与子数组中间键作比较，若小于中间键，则在左子数组中继续查找，若大于则在右子数组中查找，否则中间键就是要找的元素。</p><p>算法实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)binarySearch:(<span class="built_in">NSMutableArray</span> *)array key:(<span class="built_in">NSInteger</span>)key &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> right = array.count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ([array[mid] integerValue] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([array[mid] integerValue] &lt; key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><p>算法思想：Objective-C中的字典NSDictionary底层就使用了哈希表，大多数语言的字典都采用了哈希表实现，对于NSDictionary来说，查找复杂度是O(1)，即效率最高。NSString中也有hash属性，如有兴趣可以深入了解。</p><p>所谓的哈希其实就是在记录的存储位置和记录的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定值的映射f(key),若查找集合中存在这个记录，则必定在f(key)的位置上。哈希技术既是一种存储方法，也是一种查找方法。</p><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p><h4 id="使用Hash，我们付出了什么？"><a href="#使用Hash，我们付出了什么？" class="headerlink" title="使用Hash，我们付出了什么？"></a>使用Hash，我们付出了什么？</h4><p>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？</p><p>　　Hash是一种典型<strong>以空间换时间</strong>的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label2" target="_blank" rel="noopener">七大查找算法</a></li><li><a href="http://ios.jobbole.com/87716/" target="_blank" rel="noopener">深入理解哈希表</a></li><li><a href="https://blog.csdn.net/chenyufeng1991/article/details/50678878" target="_blank" rel="noopener">哈希查找</a></li><li><a href="https://blog.csdn.net/yidu_blog/article/details/52805675" target="_blank" rel="noopener">iOS实现感知哈希算法</a></li></ol><p>持续更新中。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h3&gt;&lt;p&gt;算法思想：首先查找数组必须有序，用要查找键与子数组中间键作比较，若小于中间键，则在左子数组中继续查找，若大于则在右子数组中查
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
      <category term="算法" scheme="http://htmlios.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS排序算法</title>
    <link href="http://htmlios.github.io/2016/09/13/iOS%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://htmlios.github.io/2016/09/13/iOS排序算法/</id>
    <published>2016-09-13T08:31:00.000Z</published>
    <updated>2018-07-15T02:03:11.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法思想：遍历数组[0~array.count]，途中比较数组相邻两个元素的大小，小的排左边，大的排右边，第一次排序完成最后一个是最大的。再遍历[0~array.count - 1]，依次类推。</p><p>算法实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bubbleSort:(<span class="built_in">NSMutableArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; array.count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> j = <span class="number">1</span>; j &lt; array.count - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([array[j - <span class="number">1</span>] integerValue] &gt; [array[j] integerValue]) &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> temp = [array[j - <span class="number">1</span>] integerValue];</span><br><span class="line">                array[j - <span class="number">1</span>] = array[j];</span><br><span class="line">                array[j] = @(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法思想：遍历数组[0~array.count]，查找最小的一个元素与第一个元素交换。然后从剩下的[1~array.count]查找最小的与第二个元素交换。直至排序结束。</p><p>算法实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)selectSort:(<span class="built_in">NSMutableArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; array.count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> minIndex = i; <span class="comment">// 初始当次排序最小的是第一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> j = i + <span class="number">1</span>; j &lt; array.count; j++) &#123; <span class="comment">// 依次查找最小的索引</span></span><br><span class="line">            <span class="keyword">if</span> ([array[minIndex] integerValue] &gt; [array[j] integerValue])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSInteger</span> temp = [array[i] integerValue];</span><br><span class="line">        array[i] = array[minIndex];</span><br><span class="line">        array[minIndex] = @(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>算法思想：从数组第二个元素开始遍历，将它依次倒序和前面的元素比较，若该元素比前面的元素小，将它保存到临时变量中，依次将前面的元素后移，然后将它插入到合适的位置。每次排序完成后，索引左边的元素一定是有序的，但是还可以移动。</p><p>算法实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)insertSort:(<span class="built_in">NSMutableArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">1</span>; i &lt; array.count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([array[j - <span class="number">1</span>] integerValue] &gt; [array[j] integerValue]) &#123;</span><br><span class="line">             <span class="built_in">NSInteger</span> temp = [array[j] integerValue];</span><br><span class="line">                array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                array[j - <span class="number">1</span>] = @(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法思想：挖出数组第一个元素作为基准元素，倒序从数组末尾依次与第一个元素比较，若有元素小于第一个元素，则将小的元素挖出填到该位置；然后从第二个元素开始正序与比较，若有元素大于</p><p>算法实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)quickSort:(<span class="built_in">NSMutableArray</span> *)array left:(<span class="built_in">NSInteger</span>)left right:(<span class="built_in">NSInteger</span>)right &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.count &lt;= left || array.count &lt;= right || left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSInteger</span> tempLeft = left;</span><br><span class="line">    <span class="built_in">NSInteger</span> tempRight = right;</span><br><span class="line">    <span class="built_in">NSInteger</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tempRight &gt;= tempLeft) &#123;</span><br><span class="line">        temp = [array[tempLeft] integerValue];</span><br><span class="line">        <span class="keyword">while</span> (tempLeft != tempRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (tempRight &gt; tempLeft &amp;&amp; [array[tempRight] integerValue] &gt;= temp)</span><br><span class="line">                tempRight--;</span><br><span class="line">            array[tempLeft] = array[tempRight];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tempRight &gt; tempLeft &amp;&amp; temp &gt;= [array[tempLeft] integerValue])</span><br><span class="line">                tempLeft++;</span><br><span class="line">            array[tempRight] = array[tempLeft];</span><br><span class="line">        &#125;</span><br><span class="line">        array[tempLeft] = @(temp);</span><br><span class="line">        [<span class="keyword">self</span> quickSort:array left:left right:tempLeft - <span class="number">1</span>];</span><br><span class="line">        [<span class="keyword">self</span> quickSort:array left:tempRight + <span class="number">1</span> right:right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续更新中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;算法思想：遍历数组[0~array.count]，途中比较数组相邻两个元素的大小，小的排左边，大的排右边，第一次排序完成最后
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
      <category term="算法" scheme="http://htmlios.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存泄漏</title>
    <link href="http://htmlios.github.io/2016/09/11/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://htmlios.github.io/2016/09/11/iOS内存泄漏/</id>
    <published>2016-09-11T01:53:00.000Z</published>
    <updated>2018-07-11T10:16:06.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>平常我们会使用 Instruments 的 Leaks / Allocations 或其他一些开源库进行内存泄漏的排查，但是这些工具都存在各种问题和不便，我们来逐个看一下这些工具的使用和存在的问题。</p><h3 id="Leaks"><a href="#Leaks" class="headerlink" title="Leaks"></a>Leaks</h3><p>苹果的文档中，一个app的内存分为三类：</p><ol><li><strong>Leaked memory</strong>: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).</li><li><strong>Abandoned memory</strong>: Memory still referenced by your application that has no useful purpose.</li><li><strong>Cached memory</strong>: Memory still referenced by your application that might be used again for better performance.</li></ol><p>其中Leaked memory 和 Abandoned memory都是应该释放而没释放的内存，都是内存泄漏，而Leaks工具只负责检测Leaked memory，而不管Abandoned memory。在MRC时代Leaked memory很常见，因为很容易忘了调用release，但在ARC时代更常见的内存泄漏是循环引用导致的Abandoned memory，Leaks工具查不出这类内存泄漏，应用有限。</p><h3 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a>Allocations</h3><p>用这种方法来发现内存泄漏很不方便：</p><ol><li>首先，需要打开Allocations；</li><li>其次，得一个个场景去重复的操作；</li><li>无法及时得知泄漏，得专门做一遍上述操作，十分繁琐。</li></ol><h3 id="MLeaksFinder"><a href="#MLeaksFinder" class="headerlink" title="MLeaksFinder"></a>MLeaksFinder</h3><p>MLeaksFinder 提供了内存泄漏检测更好的解决方案。只需引入MLeaksFinder，就可以自动在App运行过程(debug模式下)检测到内存泄漏的对象并立即提醒，无需打开额外的工具，也无需为了检测内存泄漏而去一个个场景去重复操作，无需修改任何业务逻辑代码，只需在debug下开启，完全不影响你的release包。MLeaksFinder 目前能自动检测 UIViewController 和 UIView 对象内存泄漏，也可以扩展以检测其他类型的对象。</p><p>当发生内存泄漏的时候，控制台会有如下提示，View-ViewController stack 从上往下看，该 stack 告诉你，MyTableViewController 的 UITableView 的 subview UITableViewWrapperView 的 subview MyTableViewCell 没被释放。而且，这里我们可以肯定的是 MyTableViewController，UITableView，UITableViewWrapperView 这三个已经成功释放。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Possibly Memory Leak.</span><br><span class="line">In case that MyTableViewCell should not be dealloced, override -willDealloc in MyTableViewCell by returning NO.</span><br><span class="line">View-ViewController stack: (</span><br><span class="line">    MyTableViewController,</span><br><span class="line">    UITableView,</span><br><span class="line">    UITableViewWrapperView,</span><br><span class="line">    MyTableViewCell</span><br><span class="line">)&apos;</span><br></pre></td></tr></table></figure><p>以上可以看出，MLeaksFinder的优点如下：</p><ol><li>使用简单，不侵入业务逻辑代码，不用打开 Instruments。</li><li>不需要额外的操作，你只需要关注你的业务逻辑，在App运行时自动帮你检测。</li><li>内存泄漏发生时，更改完代码一运行即能发现（这点很重要，你马上就能意识到哪里写错了）。</li><li>精准，能精准的告诉你哪个对象没有被释放。</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MLeakFinder一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 diss 后，该 UIViewController 包括它的 view，view 的 subview 等等都很快被释放（除非你把他设计成单例，或者强引用它，但一般很少这样做）。于是，我们只需要在 UIViewController 被 pop 或 diss 一小段时间后，看看该 Controller，它的 view 和 view 的 subview 等等是否还存在。</p><p>具体方法是，为基类 NSObject 添加一个方法 - willDealloc ，该方法的作用是，先用一个弱指针指向 self，并在一小段时间（3s）后，通过这个弱指针调用 - assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line">    __weak id weakSelf = self;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [weakSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)assertNotDealloc &#123;</span><br><span class="line">     NSAssert(NO, @“”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果3秒后它被释放成功，weakSelf 就指向nil，不会调用到 -assertNotDealloc方法，也就不会中断言，如果它没有被释放（泄漏了），-assertNotDealloc 就会被调用中断言。这样，当一个 ViewController 被 pop 或 diss 时（我们认为它应该要被释放了），遍历该 ViewController 上的所有view，依次调用 -willDealloc，若3秒后没被释放，就会中断言。</p><p>这里有几个问题要解决：</p><ol><li><p>不侵入代码：</p><p>这里使用 AOP 技术，hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法，关于如何hook，请参考 <a href="https://nshipster.com/method-swizzling/" target="_blank" rel="noopener">Method Swizzling</a>。</p></li><li><p>遍历相关对象：</p><p>在实际项目中，我们发现有时候一个 ViewController 被释放了，但它的 view 没被释放，或者一个 UIView 被释放了，但它的 subview 没有被释放。这种情况很常见，因此有必要遍历基于 UIViewController 的整棵 View-ViewController 树。我们通过 UIViewController 的 presentedViewController 和 view 属性，UIView 的 subviews 属性做递归遍历。对于某些 ViewController，如 UINavigationController 和 UISplitViewController 等，我们还需要遍历它的 viewControllers 属性。</p></li><li><p>构建堆栈信息：</p><p>需要构建 View-ViewController stack 信息来告诉开发者哪个对象没被释放。在递归遍历 View-ViewController树时，子节点的 stack 信息由父节点的 stack 信息加上子节点的信息即可。</p></li><li><p>例外机制：</p><p>对于有些 ViewController，在被 push 或 pop 后不会被释放（例如单例），因此我们需要提供机制让开发者指定哪个对象不会被释放，这里可以通过重载 -willDealloc 方法，直接返回 NO 即可。</p></li><li><p>特殊情况：</p><p>对于某些特殊情况，释放时间不一样（比如系统收拾返回时，在滑到一半时hold住，虽然已经被pop，但是这时不会释放，ViewController 要等到完全 disappear 后才释放），需要做特殊处理，具体的特殊处理视具体情况而定。</p></li><li><p>系统View：</p><p>某些系统的私有View，不会被释放（可能是系统bug或者是系统出于某些原因故意这样做的，不深究），因此需要设立白名单。</p></li><li><p>手动扩展：</p><p>MLeaksFinder 目前只有检测 ViewController 跟 View 对象。为此，MLeaksFinder 提供了一个手动扩展机制，你可以从 UIViewController 跟 UIView 出发，去检测其他类型的对象的内存泄漏。如下所示，我们可以检测 UIViewController 底下的 ViewModel：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line">    if (![super willDealloc]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    MLCheck(self.viewModel);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里原理跟上面是一样的，宏 MLCheck() 做的事就是为传进来的对象建立 View-ViewController stack 信息，并对传进来的对象调用 -willDealloc 方法。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;平常我们会使用 Instruments 的 Leaks / Allocations 或其他一些开源库进行内存泄漏的排查，但是这些工具都存在各
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-RunTime原理解析</title>
    <link href="http://htmlios.github.io/2016/08/09/iOS-RunTime%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://htmlios.github.io/2016/08/09/iOS-RunTime原理解析/</id>
    <published>2016-08-09T05:42:00.000Z</published>
    <updated>2018-07-09T08:49:20.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是RunTime"><a href="#什么是RunTime" class="headerlink" title="什么是RunTime"></a>什么是RunTime</h3><ul><li><p>我们写的代码在程序运行过程中都会被转化为runtime的C代码执行，例如[target doSomething]方法会被转化为objc_msgSend(target, @selector(doSomething));</p></li><li><p>OC中的一切都被设计成对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象，在runtime中使用结构体表示；</p></li><li><p>相关定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 描述类中的一个方法</span><br><span class="line">typedef struct objc_method *method;</span><br><span class="line">// 实例变量</span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line">// 类别Category</span><br><span class="line">typedef struct objc_category *Category;</span><br><span class="line">// 类中声明的属性</span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br></pre></td></tr></table></figure></li><li><p>类在RunTime中的表示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 类在RunTime中的表示</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">// 指针，顾名思义，表示是一个什么，实例的isa指向类对象，类对象的isa指向元类</span><br><span class="line">    Class isa; </span><br><span class="line">    </span><br><span class="line">    #if !__OBJC2__</span><br><span class="line">    Class super_class;// 指向父类</span><br><span class="line">    const char *name;// 类名</span><br><span class="line">    long version;</span><br><span class="line">    long info;</span><br><span class="line">    long instance_size;</span><br><span class="line">    struct objc_ivar_list *ivars; // 成员变量列表</span><br><span class="line">    struct objc_method_list **methodLists; // 方法列表</span><br><span class="line">    struct objc_cache *cache;// 缓存，一种优化，调用过的方法存入缓存列表，下次调用先找缓存</span><br><span class="line">    struct objc_protocol_list *protocols; // 协议列表</span><br><span class="line">    #endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/** Use &apos;Class&apos; instead of &apos;struct objc_class *&apos; */</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取类中的属性方法列表等"><a href="#获取类中的属性方法列表等" class="headerlink" title="获取类中的属性方法列表等"></a>获取类中的属性方法列表等</h3><p>有时候我们有这样的需求，需要知道当前类中的每个属性的名字。我们可以通过runtime的一系列方法获取类的一些信息（包括属性列表，方法列表，成员变量列表，和遵循的协议列表）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int count;</span><br><span class="line">//获取属性列表</span><br><span class="line">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</span><br><span class="line">for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">    const char *propertyName = property_getName(propertyList[i]);</span><br><span class="line">    NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取方法列表</span><br><span class="line">Method *methodList = class_copyMethodList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Method method = methodList[i];</span><br><span class="line">    NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取成员变量列表</span><br><span class="line">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Ivar myIvar = ivarList[i];</span><br><span class="line">    const char *ivarName = ivar_getName(myIvar);</span><br><span class="line">    NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取协议列表</span><br><span class="line">__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Protocol *myProtocal = protocolList[i];</span><br><span class="line">    const char *protocolName = protocol_getName(myProtocal);</span><br><span class="line">    NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下，新建一个工程</p><p>在.h文件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController &lt;UITabBarDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *property1;</span><br><span class="line">@property (nonatomic, copy) NSString *property2;</span><br><span class="line">@property (nonatomic, copy) NSString *property3;</span><br><span class="line">@property (nonatomic, copy) NSString *property4;</span><br><span class="line"></span><br><span class="line">- (void)testGetMethods;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在.m文件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController () &lt;UINavigationBarDelegate&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @private</span><br><span class="line">    NSUinteger countTest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *property5;</span><br><span class="line">@property (nonatomic, copy) NSString *property6;</span><br><span class="line">@property (nonatomic, copy) NSString *property7;</span><br><span class="line">@property (nonatomic, copy) NSString *property8;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self getProperties];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)getProperties &#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    //获取属性列表</span><br><span class="line">    NSLog(@&quot;----------获取属性---------&quot;);</span><br><span class="line">    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</span><br><span class="line">    for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">        const char *propertyName = property_getName(propertyList[i]);</span><br><span class="line">        NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;----------获取方法---------&quot;);</span><br><span class="line">    //获取方法列表</span><br><span class="line">    Method *methodList = class_copyMethodList([self class], &amp;count);</span><br><span class="line">    for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;----------获取成员变量---------&quot;);</span><br><span class="line">    //获取成员变量列表</span><br><span class="line">    Ivar *ivarList = class_copyIvarList([self class], &amp;count);</span><br><span class="line">    for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">        Ivar myIvar = ivarList[i];</span><br><span class="line">        const char *ivarName = ivar_getName(myIvar);</span><br><span class="line">        NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;----------获取协议---------&quot;);</span><br><span class="line">    //获取协议列表</span><br><span class="line">    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</span><br><span class="line">    for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">        Protocol *myProtocal = protocolList[i];</span><br><span class="line">        const char *protocolName = protocol_getName(myProtocal);</span><br><span class="line">        NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testGetMethods &#123;&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-8-9 10:34:15.698751 iOS RunTime解析[1023:187762] ----------获取属性---------</span><br><span class="line">2016-8-9 10:34:15.698886 iOS RunTime解析[1023:187762] property----&gt;property5</span><br><span class="line">2016-8-9 10:34:15.698950 iOS RunTime解析[1023:187762] property----&gt;property6</span><br><span class="line">2016-8-9 10:34:15.698999 iOS RunTime解析[1023:187762] property----&gt;property7</span><br><span class="line">2016-8-9 10:34:15.699046 iOS RunTime解析[1023:187762] property----&gt;property8</span><br><span class="line">2016-8-9 10:34:15.699160 iOS RunTime解析[1023:187762] property----&gt;property1</span><br><span class="line">2016-8-9 10:34:15.699211 iOS RunTime解析[1023:187762] property----&gt;property2</span><br><span class="line">2016-8-9 10:34:15.699257 iOS RunTime解析[1023:187762] property----&gt;property3</span><br><span class="line">2016-8-9 10:34:15.699305 iOS RunTime解析[1023:187762] property----&gt;property4</span><br><span class="line">2016-8-9 10:34:15.699369 iOS RunTime解析[1023:187762] property----&gt;hash</span><br><span class="line">2016-8-9 10:34:15.699470 iOS RunTime解析[1023:187762] property----&gt;superclass</span><br><span class="line">2016-8-9 10:34:15.699520 iOS RunTime解析[1023:187762] property----&gt;description</span><br><span class="line">2016-8-9 10:34:15.699804 iOS RunTime解析[1023:187762] property----&gt;debugDescription</span><br><span class="line">2016-8-9 10:34:15.699872 iOS RunTime解析[1023:187762] ----------获取方法---------</span><br><span class="line">2016-8-9 10:34:15.699970 iOS RunTime解析[1023:187762] method----&gt;getProperties</span><br><span class="line">2016-8-9 10:34:15.700054 iOS RunTime解析[1023:187762] method----&gt;testGetMethods</span><br><span class="line">2016-8-9 10:34:15.700124 iOS RunTime解析[1023:187762] method----&gt;property1</span><br><span class="line">2016-8-9 10:34:15.700188 iOS RunTime解析[1023:187762] method----&gt;setProperty1:</span><br><span class="line">2016-8-9 10:34:15.700249 iOS RunTime解析[1023:187762] method----&gt;property2</span><br><span class="line">2016-8-9 10:34:15.700399 iOS RunTime解析[1023:187762] method----&gt;setProperty2:</span><br><span class="line">2016-8-9 10:34:15.700485 iOS RunTime解析[1023:187762] method----&gt;property3</span><br><span class="line">2016-8-9 10:34:15.700596 iOS RunTime解析[1023:187762] method----&gt;setProperty3:</span><br><span class="line">2016-8-9 10:34:15.700666 iOS RunTime解析[1023:187762] method----&gt;property4</span><br><span class="line">2016-8-9 10:34:15.700789 iOS RunTime解析[1023:187762] method----&gt;setProperty4:</span><br><span class="line">2016-8-9 10:34:15.700885 iOS RunTime解析[1023:187762] method----&gt;property5</span><br><span class="line">2016-8-9 10:34:15.700937 iOS RunTime解析[1023:187762] method----&gt;setProperty5:</span><br><span class="line">2016-8-9 10:34:15.700988 iOS RunTime解析[1023:187762] method----&gt;property6</span><br><span class="line">2016-8-9 10:34:15.701036 iOS RunTime解析[1023:187762] method----&gt;setProperty6:</span><br><span class="line">2016-8-9 10:34:15.701083 iOS RunTime解析[1023:187762] method----&gt;property7</span><br><span class="line">2016-8-9 10:34:15.701132 iOS RunTime解析[1023:187762] method----&gt;setProperty7:</span><br><span class="line">2016-8-9 10:34:15.701244 iOS RunTime解析[1023:187762] method----&gt;property8</span><br><span class="line">2016-8-9 10:34:15.701309 iOS RunTime解析[1023:187762] method----&gt;setProperty8:</span><br><span class="line">2016-8-9 10:34:15.701440 iOS RunTime解析[1023:187762] method----&gt;.cxx_destruct</span><br><span class="line">2016-8-9 10:34:15.701518 iOS RunTime解析[1023:187762] method----&gt;didReceiveMemoryWarning</span><br><span class="line">2016-8-9 10:34:15.701621 iOS RunTime解析[1023:187762] method----&gt;viewDidLoad</span><br><span class="line">2016-8-9 10:34:15.701671 iOS RunTime解析[1023:187762] ----------获取成员变量---------</span><br><span class="line">2016-8-9 10:34:15.701746 iOS RunTime解析[1023:187762] Ivar----&gt;countTest</span><br><span class="line">2016-8-9 10:34:15.701795 iOS RunTime解析[1023:187762] Ivar----&gt;_property1</span><br><span class="line">2016-8-9 10:34:15.701865 iOS RunTime解析[1023:187762] Ivar----&gt;_property2</span><br><span class="line">2016-8-9 10:34:15.701916 iOS RunTime解析[1023:187762] Ivar----&gt;_property3</span><br><span class="line">2016-8-9 10:34:15.701964 iOS RunTime解析[1023:187762] Ivar----&gt;_property4</span><br><span class="line">2016-8-9 10:34:15.702012 iOS RunTime解析[1023:187762] Ivar----&gt;_property5</span><br><span class="line">2016-8-9 10:34:15.702059 iOS RunTime解析[1023:187762] Ivar----&gt;_property6</span><br><span class="line">2016-8-9 10:34:15.702106 iOS RunTime解析[1023:187762] Ivar----&gt;_property7</span><br><span class="line">2016-8-9 10:34:15.702154 iOS RunTime解析[1023:187762] Ivar----&gt;_property8</span><br><span class="line">2016-8-9 10:34:15.702192 iOS RunTime解析[1023:187762] ----------获取协议---------</span><br><span class="line">2016-8-9 10:34:15.702850 iOS RunTime解析[1023:187762] protocol----&gt;UINavigationBarDelegate</span><br><span class="line">2016-8-9 10:34:15.702908 iOS RunTime解析[1023:187762] protocol----&gt;UITabBarDelegate</span><br></pre></td></tr></table></figure><p>可以看到，无论是.h还是.m中的申明，全部打印出来了；而且还有一个规律，就是.m的属性和方法，总是首先被打印出来。</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>我们看一下方法调用在运行时的过程。</p><p>如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。</p><p>如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）操作。</p><ol><li>首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应的实现并执行。</li><li>如果没有找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行。</li><li>如果没有找到，去父类指针所指向的对象中执行1和2。</li><li>以此类推，如果一直到根类还没有找到，转向拦截调用。</li><li>如果没有重写拦截调用的方法，程序报错。</li></ol><p>那么，这样，我们是不是可以这样做呢？</p><ul><li>重写父类的方法，并没有覆盖掉父类的方法，只是在当前类对象中找到了这个方法就不会再去父类中找了。</li><li>如果想调用已经重写过的方法的父类实现，只需要使用super这个编译器标识，它会运行时跳过在当前的类对象中寻找方法的过程。</li></ul><h3 id="拦截调用"><a href="#拦截调用" class="headerlink" title="拦截调用"></a>拦截调用</h3><p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。</p><p>那么什么是拦截调用呢。</p><p>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写NSObject的四个方法来处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel;</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;</span><br><span class="line">//后两个方法需要转发到其他的类处理</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure><ul><li>第一个方法是当你调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，你可以加上自己的处理然后返回YES。</li><li>第二个方法和第一个类似，只不过处理的是实例方法。</li><li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个又这个方法的target。</li><li>第四个方法是将你调用的不存在的方法打包成NSInovaction传给你。做完自己的处理后，调用invokeWithTarget:方法让某个target触发这个方法。</li></ul><h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><p>重写了拦截调用的方法并且返回了YES，我们要怎么做自己的处理呢？</p><p>有一个办法是根据传进来的SEL类型的selector动态添加一个方法。</p><p>首先从外部隐式调用一个不存在的方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 隐式调用方法</span><br><span class="line">[target performSelector:@selector(resolveAdd:) withObject:@&quot;test&quot;];</span><br></pre></td></tr></table></figure><p>然后，在target对象内部重写拦截调用的方法，动态添加方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void runAddMethod(id self, SEL _cmd, NSString *string) &#123;</span><br><span class="line">    NSLog(@&quot;add C IMP&quot;, string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    // 给本类动态添加一个方法</span><br><span class="line">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;resolveAdd:&quot;]) &#123;</span><br><span class="line">        class_addMethod(self, sel, (IMP)runAddMethod, &quot;v@:*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中class_addMethod的四个参数分别是：</p><ul><li>Class cls 给哪个类添加方法，本例中是self;</li><li>SEL name 添加的方法，本例中是重写的拦截调用传进来的selector;</li><li>IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用+(IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。</li><li>“v@:*”方法的签名，代表有一个参数的方法。</li></ul><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性，这种情况下的一般解决办法是继承。</p><p>但是，只增加一个属性，就去继承一个类，总是觉得太麻烦。</p><p>这个时候，runtime的关联属性就发挥它的作用了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 首先定义一个全局变量，用它的地址作为关联对象的key</span><br><span class="line">static char associatedObjectKey;</span><br><span class="line">// 设置关联对象</span><br><span class="line">objc_setAssociatedObject(target, &amp;associatedObjectKey, @&quot;添加的字符串属性&quot;, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">// 获取关联对象</span><br><span class="line">NSString *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);</span><br><span class="line">NSLog(@&quot;AssociatedObjec = %@&quot;, string);</span><br></pre></td></tr></table></figure><p>objc_setAssociatedObject的四个参数：</p><ul><li><p>id object给谁设置关联对象。</p></li><li><p>const void *key关联对象唯一的key，获取时会用到。</p></li><li><p>id value关联对象。</p></li><li><p>objc_AssociationPolicy 关联策略，有以下几种策略：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, </span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>objc_getAssociatedObject的两个参数：</p><ul><li>id object 获取谁的关联对象。</li><li>const void *key根据这个唯一的key获取关联对象。</li></ul><p>其实你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类别中，方便使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加关联对象</span><br><span class="line">- (void)addAssociatedObject:(id)object &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @select(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取关联对象</span><br><span class="line">- (id)getAssociatedObject &#123;</span><br><span class="line">    return objc_getAssociatedObject(slef, _cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。</p><h3 id="方法交换"><a href="#方法交换" class="headerlink" title="方法交换"></a>方法交换</h3><p>就是将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法中的代码，反之亦然。</p><p>我们来试一下，定义一个UIViewController的category</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">load方法会在类的第一次加载的时候被调用</span><br><span class="line">调用的时间比较靠前，适合在这个方法里做方法交换</span><br><span class="line">*/</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    // 方法交换应该被保证，在程序中只执行一次</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       // 获得viewController的生命周期中的一个方法的selector</span><br><span class="line">       SEL systemSel = @selector(viewWillAppear:);</span><br><span class="line">       // 自己实现的将要被交换的方法的selector</span><br><span class="line">       SEL customSel = @selector(custome_viewWillAppear:);</span><br><span class="line">       // 两个方法的Method</span><br><span class="line">       Method systemMethod = class_getInstanceMethod([self class], systemSel);</span><br><span class="line">       Method customeMethod = class_getInstanceMethod([self class], customSel);</span><br><span class="line">       </span><br><span class="line">       // 首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败</span><br><span class="line">       BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(customMethod), method_getTypeEncoding(customMehod));</span><br><span class="line">       if (isAdd) &#123;</span><br><span class="line">           // 如果成功，说明类中不存在这个方法的实现</span><br><span class="line">           // 将被交换的实现替换到这个并不存在的实现</span><br><span class="line">           class_replaceMethod(self, customSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // 否则，交换两个方法的实现</span><br><span class="line">           method_exchangeImplementation(systemMehod, customMethod);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)custom_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    // 这时候调用自己，看起来像是死循环</span><br><span class="line">    // 但是其实自己的实现已经被替换了</span><br><span class="line">    [self custom_viewWillAppear:animated]; // 这里是去执行系统的viewWillAppear:方法</span><br><span class="line">    NSLog(@&quot;custome&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他Controller中</p><p>在.m中我们重写viewWillAppear:方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会在控制台看到直接打印出custome。</p><p>其实viewWillAppear:方法已经被我们替换成我们自己的custom_viewWillAppear:</p><p>然后再我们自定义的custome_viewWillAppear:方法中又调用了custome_viewWillAppear:本身其实他已经被替换成viewWillAppear:方法，所以这样就实现了方法替换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是RunTime&quot;&gt;&lt;a href=&quot;#什么是RunTime&quot; class=&quot;headerlink&quot; title=&quot;什么是RunTime&quot;&gt;&lt;/a&gt;什么是RunTime&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们写的代码在程序运行过程中都会被转化为runtime的C
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-UI事件传递与响应者链</title>
    <link href="http://htmlios.github.io/2016/08/06/iOS-UI%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    <id>http://htmlios.github.io/2016/08/06/iOS-UI事件传递与响应者链/</id>
    <published>2016-08-06T09:12:00.000Z</published>
    <updated>2018-07-06T12:51:43.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>响应者对象：继承自UIResponder的对象称之为响应者对象。UIApplication、Window、UIViewController和所有继承UIView的UIKit类都直接或间接的继承自UIResponder。</p><p>UIResponder一般响应以下几种事件：触摸事件(touch handing)、点按事件(press handing)、加速事件和远程控制事件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 触摸事件(touch handling) */</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesEstimatedPropertiesUpdated:(NSSet *)touches NS_AVAILABLE_IOS(9_1);</span><br><span class="line">/** 点按事件(press handling) NS_AVAILABLE_IOS(9_0) */</span><br><span class="line">- (void)pressesBegan:(NSSet *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);</span><br><span class="line">- (void)pressesChanged:(NSSet *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);</span><br><span class="line">- (void)pressesEnded:(NSSet *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);</span><br><span class="line">- (void)pressesCancelled:(NSSet *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);</span><br><span class="line">/** 加速事件 */</span><br><span class="line">- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);</span><br><span class="line">- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);</span><br><span class="line">- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);</span><br><span class="line">/** 远程控制事件 */</span><br><span class="line">- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(4_0);</span><br></pre></td></tr></table></figure><p>响应者链：由多个响应者组合起来的链条，就叫做响应者链。它表示了每个响应者之间的联系，并且可以使得一个事件可选择多个对象处理。</p><p><img src="/2016/08/06/iOS-UI事件传递与响应者链/iOS1.png" alt="img"></p><p>假设触摸了initial view:</p><ol><li>第一响应者就是initial view即initial view首先响应touchesBegan:withEvent:方法，接着传递给橘黄色的view;</li><li>橘黄色的view开始响应touchesBegan:withEvent:方法，接着传递给蓝绿色view；</li><li>蓝绿色view响应touchesBegan:withEvent:方法，接着传递给控制器的view；</li><li>控制器view响应touchesBegan:withEvent:方法，控制器传递给了窗口；</li><li>窗口再传递给application；</li></ol><p>如果上述响应者都不处理该事件，那么事件被丢弃。</p><h3 id="事件的产生和传递"><a href="#事件的产生和传递" class="headerlink" title="事件的产生和传递"></a>事件的产生和传递</h3><p>当一个触摸事件产生的时候，我们的程序是如何找到第一响应者的？</p><p><img src="/2016/08/06/iOS-UI事件传递与响应者链/iOS2.png" alt="img"></p><p>当你点击了屏幕会产生一个触摸事件，消息循环(runloop)会接收到触摸事件放到消息队列里，UIApplication会从消息队列里取事件分发下去，首先传给UIWindow，UIWindow会使用hitTest:withEvent:方法找到此次触摸事件初始点所在的视图，找到这个视图之后他就会调用视图的touchesBegan:withEvent:方法来处理事件。</p><h4 id="hitTest-withEvent-查找过程"><a href="#hitTest-withEvent-查找过程" class="headerlink" title="hitTest:withEvent:查找过程"></a>hitTest:withEvent:查找过程</h4><p><img src="/2016/08/06/iOS-UI事件传递与响应者链/iOS3.png" alt="img"></p><p>图片中view的层次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ViewA addSubview:ViewB];</span><br><span class="line">[ViewA addSubview:ViewC];</span><br><span class="line">[ViewB addSubview:ViewD];</span><br><span class="line">[ViewB addSubview:ViewE];</span><br></pre></td></tr></table></figure><p>点击ViewE：</p><ol><li>A是UIWindow的根视图，首先对A进行hitTest:withEvent:。</li><li>判断A的userInteractionEnable，如果为NO，A的hitTest:withEvent返回nil。</li><li>pointInside:withEvent:方法判断用户点击是否在A的范围内，显然返回YES。</li><li>遍历A的视图B和C，由于从后向前遍历<ul><li>因此先查看C，调用C的hitTest:withEvent方法: pointInside:withEvent:方法判断用户的点击是否在C的范围内，不在返回NO，C对应的hitTest:withEvent:方法return nil。</li><li>再查看B，调用B的hitTest:withEvent方法：pointInside:withEvent:判断用户的点击是否在B视图的范围内，在则返回YES。</li></ul></li></ol><p>遍历B的子视图D和E，从后向前遍历</p><p>先查看E，调用E的hitTest:withEvent:方法：pointInside:withEvent:方法 判断用户点击是否在E范围内，在返回YES，E没有子视图，因此E对应的hitTest:withEvent方法返回E，再往前回溯，就是B的hitTest:withEvent方法放回E，因此A的hitTest:withEvent方法返回E。</p><p>至此，点击事件的第一响应者就找到了。</p><blockquote><p>如果hitTest:withEvent:找到的第一响应者view没有处理该事件，那么事件沿着响应者链向上传递-&gt;父视图-&gt;视图控制器，如果传递到最顶级视图还没处理事件，那么就传递给window处理，若window对象也不处理-&gt;交给UIApplication处理，如果UIApplication对象还不处理，就丢弃该事件。</p></blockquote><p><img src="/2016/08/06/iOS-UI事件传递与响应者链/iOS4.png" alt="img"></p><p>注意：控件不能响应的情况</p><ol><li>userInteractionEnable = NO;</li><li>hidden = YES;</li><li>透明度 alpha &lt;= 0.01f;</li><li>子视图超出父视图区域</li></ol><p>子视图超出父视图，不响应的原因：因为父视图的pointInside:withEvent:方法返回了NO，就不会遍历子视图了。可以重写pointInside:withEvent:方法解决此问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;响应者对象：继承自UIResponder的对象称之为响应者对象。UIApplication、Window、UIViewController和
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS发展</title>
    <link href="http://htmlios.github.io/2016/08/06/iOS%E5%8F%91%E5%B1%95/"/>
    <id>http://htmlios.github.io/2016/08/06/iOS发展/</id>
    <published>2016-08-06T06:32:00.000Z</published>
    <updated>2018-07-06T06:54:13.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="个人技术栈"><a href="#个人技术栈" class="headerlink" title="个人技术栈"></a>个人技术栈</h3><p><img src="/2016/08/06/iOS发展/1.png" alt="iOS技术栈"></p><h3 id="个人发展规划"><a href="#个人发展规划" class="headerlink" title="个人发展规划"></a>个人发展规划</h3><p><img src="/2016/08/06/iOS发展/2.png" alt="iOS技术栈"></p><p>更新中。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;个人技术栈&quot;&gt;&lt;a href=&quot;#个人技术栈&quot; class=&quot;headerlink&quot; title=&quot;个人技术栈&quot;&gt;&lt;/a&gt;个人技术栈&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2016/08/06/iOS发展/1.png&quot; alt=&quot;iOS技术栈&quot;&gt;&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题及解答(二)</title>
    <link href="http://htmlios.github.io/2016/07/27/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94-%E4%BA%8C/"/>
    <id>http://htmlios.github.io/2016/07/27/iOS面试题及解答-二/</id>
    <published>2016-07-27T06:33:00.000Z</published>
    <updated>2018-06-27T10:16:30.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h2><h3 id="AFNetworking底层原理分析"><a href="#AFNetworking底层原理分析" class="headerlink" title="AFNetworking底层原理分析"></a>AFNetworking底层原理分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装，其主要有以下类：</span><br><span class="line">1.AFHTTPRequestOperationManager：内部封装的是NSURLConnection，负责发送网络请求，使用最多的一个类。(3.0废弃)</span><br><span class="line">2.AFHTTPSeesionManager：内部封装的是NSURLSeesion，负责发送网络请求，使用最多的一个类。</span><br><span class="line">3.AFNetworkingReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生变化之后，这个工具类就可以检测到。</span><br><span class="line">4.AFSecurityPolicy：网络安全的工具类，主要是针对HTTPS服务。</span><br><span class="line">5.AFURLRequestSerialization：序列化工具类，基类。上传的数据转换成JSON格式，AFJSONRequestSerializer使用不多。</span><br><span class="line">6.AFURLResponseSerialization：反序列化工具类；基类，使用比较多。</span><br><span class="line">7.AFJSONResponseSerializer：JSON解析器，默认的解析器。</span><br><span class="line">8.AFHTTPResponseSerializer：万能解析器，jSON和XML之外的数据类型，直接返回二进制数据，对服务器返回的数据不做任何处理。</span><br><span class="line">9.AFXMLParserResponseSerializer：XML解析器。</span><br></pre></td></tr></table></figure><h3 id="描述下SDWebImage里面给UIImageView加载图片的逻辑"><a href="#描述下SDWebImage里面给UIImageView加载图片的逻辑" class="headerlink" title="描述下SDWebImage里面给UIImageView加载图片的逻辑"></a>描述下SDWebImage里面给UIImageView加载图片的逻辑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SDWebImage中为UIImageView提供了一个分类UIImageView+WebCache.h，这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:,会再真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。</span><br><span class="line">加载图片的过程大致如下：</span><br><span class="line">1.首先会再SDWebImageCache中寻找图片是否有对应的缓存，会以url作为数据的索引先在内存中寻找是否有对应的缓存。</span><br><span class="line">2.如果缓存中未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据，如果找到了，就会把磁盘中的数据加载到内存中，并将图片显示出来。</span><br><span class="line">3.如果内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片。</span><br><span class="line">4.下载后的图片会加入缓存中，并写入磁盘中。</span><br><span class="line">5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来。</span><br><span class="line"></span><br><span class="line">SDWebImage原理：</span><br><span class="line">调用类别的方法：</span><br><span class="line">1.从内存(字典)中找图片(当这个图片在本次使用程序的过程中已经被加载过)，找到直接使用。</span><br><span class="line">2.从沙盒中找(当这个图片在之前使用程序的过程中被加载过)，找到使用，缓存到内存中。</span><br><span class="line">3.从网络上获取，使用，缓存到内存，缓存到沙盒。</span><br></pre></td></tr></table></figure><h3 id="友盟统计接口统计的所有功能"><a href="#友盟统计接口统计的所有功能" class="headerlink" title="友盟统计接口统计的所有功能"></a>友盟统计接口统计的所有功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APP启动速度，APP停留页面时间等</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="不用中间变量，用两种方法交换A和B的值"><a href="#不用中间变量，用两种方法交换A和B的值" class="headerlink" title="不用中间变量，用两种方法交换A和B的值"></a>不用中间变量，用两种方法交换A和B的值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1.中间变量</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">// 2.加法</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = a - b;</span><br><span class="line">    a = a - b;</span><br><span class="line">&#125;</span><br><span class="line">// 3.异或(相同为0，不同为1)</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1.直接遍历法</span><br><span class="line">int maxCommonDivisor(int a, int b) &#123;</span><br><span class="line">    int max = 0;</span><br><span class="line">    for (int i = 1; i &lt; b; i++) &#123;</span><br><span class="line">        if (a % i = 0 &amp;&amp; b % i = 0) &#123;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.辗转相除法(扩展：最小公倍数 = (a * b) / 最大公约数)</span><br><span class="line">int maxCommonDivisor(int a, int b) &#123;</span><br><span class="line">    int r;</span><br><span class="line">    while (a % b &gt; 0) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择排序、冒泡排序、插入排序三种排序算法可以总结如下：</span><br><span class="line">都将数组分为已排序部分和未排序部分。</span><br><span class="line">1.选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</span><br><span class="line">2.冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</span><br><span class="line">3.插入排序将已排序部分定义在左端，将未排序部分的第一个元素插入到已排序部分合适的位置。</span><br></pre></td></tr></table></figure><h3 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h3><p>算法思想：遍历待排序的数据，每次比较临近的两个元素，如果他们的排序错误交换两个元素位置，经过一趟排序最大的就会排在最末端。重复操作，直到排序完成。</p><p>示例演示：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一趟排序</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第二趟排序</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第三趟排序</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第五趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr></tbody></table><p>其中第一趟排序过程如下：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一次比较</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第二次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">6</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第三次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">6</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第四次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">6</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第五次比较</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td><td style="text-align:right">6</td></tr></tbody></table><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array:待排序数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">array</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法思想：查找待排序数据中最小的一个元素，将它与数组的第一个元素交换位置。然后从剩下的元素中选择一个最小元素，将它与第二个位置的元素交换位置，如果最小元素就是该位置的元素，就将它和自身交换位置，依次类推，直到排序完成。</p><p>示例演示：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一趟排序</td><td style="text-align:right">1</td><td style="text-align:right">5</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第二趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第三趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第五趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr><tr><td style="text-align:right">第六趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr></tbody></table><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array:待排序数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">array</span>.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[min]) &#123;</span><br><span class="line">            min = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[min];</span><br><span class="line">    <span class="built_in">array</span>[min] = <span class="built_in">array</span>[i];</span><br><span class="line">    <span class="built_in">array</span>[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>算法思想：从数组的第二个开始遍历，将该元素依次倒序与前面元素比较，如果该元素比前面的元素小，将该元素保存进临时变量中，依次将前面元素后移，然后将该元素插入到合适的位置。每次排序完成后，索引左边的元素一定是有序的，但是还可以移动。对于倒置越少的数组，该算法排序效率越高。</p><p>示例演示：</p><table><thead><tr><th style="text-align:right">待排序数组</th><th style="text-align:right">6</th><th style="text-align:right">5</th><th style="text-align:right">4</th><th style="text-align:right">3</th><th style="text-align:right">2</th><th style="text-align:right">1</th></tr></thead><tbody><tr><td style="text-align:right">第一趟排序</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">4</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第二趟排序</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">3</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第三趟排序</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">2</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">第四趟排序</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td></tr></tbody></table><p>算法实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array:待排序数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[j];</span><br><span class="line">        <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">array</span>[j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 折半查找：优化查找时间(不用遍历全部数据)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 折半查找的原理</span></span><br><span class="line"><span class="comment">*   1.数组必须是有序的</span></span><br><span class="line"><span class="comment">* 2.必须已知min和max(知道范围)</span></span><br><span class="line"><span class="comment">*   3.动态计算mid的值，取出mid对应的值进行比较</span></span><br><span class="line"><span class="comment">*   4.如果mid对应的值大于要查找的值，那么max要变小为mid-1</span></span><br><span class="line"><span class="comment">*   5.如果mid对应的值小于要查找的值，那么min要变大为mid+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 已知一个有序数组，和一个key，要求从数组中找到key对应的索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKey</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> length, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(min &lt;= max) &#123;</span><br><span class="line">        mid = (min + max) / <span class="number">2</span>; <span class="comment">// 计算中间值</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            min = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            max = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它知识点"><a href="#其它知识点" class="headerlink" title="其它知识点"></a>其它知识点</h2><p>1.Homekit，是苹果2014年发布的智能家具平台。</p><p>2.什么是OpenGL、Quartz 2D？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Quartz 2D 是Apple提供的基本图形工具库。只适用于2D图形的绘制。</span><br><span class="line">OpenGL，是一个跨平台的图形开发库，适用于2D和3D图形的绘制。</span><br></pre></td></tr></table></figure><p>3.ffmpeg框架</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg是音视频处理工具，既有音视频编解码功能，又可以作为播放器使用。</span><br></pre></td></tr></table></figure><p>4.谈谈UITableView的优化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.正确的复用cell;</span><br><span class="line">2.设计统一规格的cell;</span><br><span class="line">3.提前计算并缓存好高度(布局)，因为heightForRowAtIndexPath:是调用最频繁的方法;</span><br><span class="line">4.异步绘制，遇到复杂的界面，遇到性能瓶颈时，可能是突破口。</span><br><span class="line">5.滑动时按需加载，这个在大量图片展示，网络加载的时候很管用。</span><br><span class="line">6.减少子视图的层级关系。</span><br><span class="line">7.尽量使所有的视图不透明化以及切圆操作。</span><br><span class="line">8.不要动态的add或者remove子控件。最好在初始化就添加完，然后通过hidden来控制是否显示。</span><br><span class="line">9.使用调试工具分析问题。</span><br></pre></td></tr></table></figure><p>5.如何实行cell的动态的行高</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果希望每条数据显示自身行高，必须设置两个属性，1.预估行高；2.自定义行高。</span><br><span class="line">设置预估行高 tableView.estimatedRowHeight = 200;</span><br><span class="line">设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension;</span><br><span class="line">如果要让自定义行高有效，必须让容器视图有一个自上而下的约束。</span><br></pre></td></tr></table></figure><p>6.什么是野指针、空指针？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">野指针：不知道指向了哪里的指针叫野指针。即指针指向不明确，指针存在的地址是一个垃圾值，未初始化。</span><br><span class="line">空指针：不指向任何位置的指针叫空指针。即指针没有指向，指针存的地址是一个空地址，NULL。</span><br></pre></td></tr></table></figure><p>7.什么是OOA/OOD/OOP？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OOA(Object Oriented Analysis)--面向对象分析</span><br><span class="line">OOD(Object Oriented Design) -- 面向对象设计</span><br><span class="line">OOP(Object Oriented Programming) -- 面向对象编程</span><br></pre></td></tr></table></figure><p>8.多线程是什么？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多线程是个复杂的概念，按字面意思是同步完成多项任务，提高了资源的使用效率，从硬件、操作系统、应用软件不同的角度去看，多线程被赋予不同的内涵；</span><br><span class="line">对于硬件，现在市面上多数的CPU都是多核的，多核的CPU运算多线程更为出色；</span><br><span class="line">从操作系统角度，是多任务，现在用的主流操作系统都是多任务的，可以一边听歌，一边写博客；</span><br><span class="line">对于应用来说，多线程可以让应用更快的回应，可以在网络下载时，同时响应用户的触摸操作。</span><br><span class="line">在iOS应用中，多线程最初的理解，就是并发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成烧水的同时去摘菜，最后去炒菜。</span><br></pre></td></tr></table></figure><p>9.iOS中的多线程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更为方便的使用多线程，做过C++的同学可能会对线程有更多的理解，比如线程的创立，信号量，共享变量有认识，Cocoa框架下会更方便，它对线程做了封装，有些封装，可以让我们创建的对象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提供程序的健壮性。</span><br></pre></td></tr></table></figure><p>10.static关键字的作用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在函数体内定义的static他的作用域就是该函数体，该变量在内存中只被分配一次内存，因此，其值在下次调用的时候仍是上次的值不变。</span><br><span class="line">2.在模块内的static全局变量可以被模块内所有函数访问，但是不能被外部模块的其他函数访问。</span><br><span class="line">3.在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝，也就是说只要是该类的对象，那么该对象中被static修饰的成员变量都指向同一地址。</span><br><span class="line">4.修饰局部变量：</span><br><span class="line">  延长局部变量的生命周期，程序结束才会销毁。</span><br><span class="line">  局部变量只会生成一份内存，只会初始化一次。</span><br><span class="line">  改变局部变量的作用域。</span><br><span class="line">5.修饰全局变量：</span><br><span class="line">  只能在本文件中访问，修改全局变量的作用域，声明周期不会改。</span><br><span class="line">  避免重复定义全局变量。</span><br><span class="line">6.在OC中static关键字使用误区</span><br><span class="line">  1.使用static修饰实例变量是不被允许的。</span><br><span class="line">  2.使用static修饰了方法，也是错误的。</span><br></pre></td></tr></table></figure><h3 id="使用Swift语言编程的优缺点"><a href="#使用Swift语言编程的优缺点" class="headerlink" title="使用Swift语言编程的优缺点"></a>使用Swift语言编程的优缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总的来说，我认为使用Swift来作为编程语言的有点还是远远大于缺点的，而且很多缺点苹果也在逐渐改善。</span><br><span class="line">优点：</span><br><span class="line">1.简洁的语法</span><br><span class="line">2.更强的类型安全</span><br><span class="line">3.函数式编程的支持</span><br><span class="line">  Swift语言本身提供了对函数式编程的支持。</span><br><span class="line">  Objc本身是不支持的，但是可以通过引入ReactiveCocoa这个库来支持函数式编程。</span><br><span class="line">4.编写OSX下的自动化脚本</span><br><span class="line">缺点：</span><br><span class="line">1.App体积变大</span><br><span class="line">  使用Swift后，App体积大概增加5-8M左右，对体积大小敏感的慎用。</span><br><span class="line">  体积变大的原因是因为Swift还在变化，所以Apple没有在iOS系统里放入Swift的运行库，反而是每个App里都要包含其对应的Swift运行库。</span><br><span class="line">2.Xcode支持不够好</span><br><span class="line">  如果你是使用Xcode经常卡住或者崩溃想必你肯定碰到过了，这个是目前使用Swift最让人头疼的事情，即使是到现在Xcode9，有时候也会偶尔遇到这种问题，所以要看你的承受力了。。。</span><br><span class="line">3.第三方库的支持不够多</span><br><span class="line">  目前确实Swift编写的第三方库不多，但可以通过桥接的方式来使用Objc的第三方库，基本上没有太大问题。现在已经改善很多了。</span><br><span class="line">4.怨言版本更新带来的编译问题</span><br><span class="line">  语言本身还在发展，所以每次版本更新后都会出现编译不过的情况(至少到目前为止还是)，但是自从4.0版本发布后，改动没有beta时候那么大了，而且根据Xcode提示基本就可以解决语法变动导致的编译问题了。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三方框架&quot;&gt;&lt;a href=&quot;#第三方框架&quot; class=&quot;headerlink&quot; title=&quot;第三方框架&quot;&gt;&lt;/a&gt;第三方框架&lt;/h2&gt;&lt;h3 id=&quot;AFNetworking底层原理分析&quot;&gt;&lt;a href=&quot;#AFNetworking底层原理分析&quot; cla
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题及解答</title>
    <link href="http://htmlios.github.io/2016/07/26/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E8%A7%A3%E7%AD%94/"/>
    <id>http://htmlios.github.io/2016/07/26/iOS面试题及解答/</id>
    <published>2016-07-25T18:17:00.000Z</published>
    <updated>2018-06-27T06:25:36.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h1><p>最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="设计模式是什么？你知道哪些设计模式，并简要叙述。"><a href="#设计模式是什么？你知道哪些设计模式，并简要叙述。" class="headerlink" title="设计模式是什么？你知道哪些设计模式，并简要叙述。"></a>设计模式是什么？你知道哪些设计模式，并简要叙述。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情，常用常见到的设计模式有以下几种。</span><br><span class="line">1.MVC：Model View Controller，模型 视图 控制器解耦合。</span><br><span class="line">2.MVVM：Model View ViewModel，模型 视图 业务逻辑 解耦合。</span><br><span class="line">3.单例：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。</span><br><span class="line">4.观察者：KVO是典型的观察者，观察某个属性的状态，状态发生变化时通知观察者。</span><br><span class="line">5.委托：代理+协议的组合。实现1对1的反向传值操作。</span><br><span class="line">6.工厂：通过一个类方法，批量的根据已有模板生产对象。</span><br></pre></td></tr></table></figure><h3 id="MVC和MVVM的区别是什么？"><a href="#MVC和MVVM的区别是什么？" class="headerlink" title="MVC和MVVM的区别是什么？"></a>MVC和MVVM的区别是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。</span><br><span class="line">MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。</span><br></pre></td></tr></table></figure><h3 id="import跟-include有什么区别，-class呢，-import-lt-gt-跟-import-quot-quot-有什么区别？"><a href="#import跟-include有什么区别，-class呢，-import-lt-gt-跟-import-quot-quot-有什么区别？" class="headerlink" title="#import跟#include有什么区别，@class呢，#import&lt;&gt;跟#import &quot;&quot;有什么区别？"></a><code>#import</code>跟<code>#include</code>有什么区别，<code>@class</code>呢，<code>#import&lt;&gt;</code>跟<code>#import &quot;&quot;</code>有什么区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.#import是Object-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。</span><br><span class="line">2.@class告诉编译器某个类的声明，当执行时，才会去查看类的实现文件，可以解决头文件的相互包含。</span><br><span class="line">3.#import&lt;&gt;用来包含系统的头文件，#import &quot;&quot;用来包含用户头文件。</span><br></pre></td></tr></table></figure><h3 id="frame和bounds有什么不同？"><a href="#frame和bounds有什么不同？" class="headerlink" title="frame和bounds有什么不同？"></a><code>frame</code>和<code>bounds</code>有什么不同？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame指的是该view在父view坐标系中的位置和大小，参考点是父view的坐标系。</span><br><span class="line">bounds指的是该view在本身坐标系统中的位置和大小，参考点是本身坐标系。</span><br></pre></td></tr></table></figure><h3 id="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？"><a href="#Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？" class="headerlink" title="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？"></a>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重新一个类的方法用继承好还是分类好？为什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</span><br></pre></td></tr></table></figure><h3 id="property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"><a href="#property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？" class="headerlink" title="@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"></a><code>@property</code>的本质是什么？<code>ivar</code>、<code>getter</code>、<code>setter</code>是如何生成并添加到这个类中的？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property = ivar + getter + setter;</span><br><span class="line">“属性”(property)有两大概念：ivar（实例变量）、getter + setter（存取方法）；</span><br><span class="line">”属性“(property)作为Objective-C的一项特性，主要的作用就在于封装对象中的数据。Objective-C对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过”存取方法“(access method)来访问。其中”获取方法“(getter)用于读取变量值，而”设置方法“(setter)用于写入变量值。</span><br></pre></td></tr></table></figure><h3 id="property中有哪些属性关键字？"><a href="#property中有哪些属性关键字？" class="headerlink" title="@property中有哪些属性关键字？"></a><code>@property</code>中有哪些属性关键字？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">属性可以拥有的特质分为四类：</span><br><span class="line">1.原子性：nonatomic特质</span><br><span class="line">2.读/写权限：readwrite（读写）、readonly（只读）</span><br><span class="line">3.内存管理语义：assign、strong、weak、unsafe_unretained、copy</span><br><span class="line">4.方法名：getter、setter</span><br><span class="line">5.不常用的：nonnull、null_resettable、nullable</span><br></pre></td></tr></table></figure><h3 id="属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？"><a href="#属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？" class="headerlink" title="属性关键字readwrite、readonly、assign、retain、copy、nonatomic各是什么作用，在哪种情况下用？"></a>属性关键字<code>readwrite</code>、<code>readonly</code>、<code>assign</code>、<code>retain</code>、<code>copy</code>、<code>nonatomic</code>各是什么作用，在哪种情况下用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.readwrite：可读可写特性。需要生成getter和setter方法。</span><br><span class="line">2.readonly：只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。</span><br><span class="line">3.assign：赋值属性。setter方法将传入参数赋值给实例变量；仅设置变量时，assign用于基本数据类型(如NSInteger、CGFloat、CGRect...)。</span><br><span class="line">4.retain(MRC)/strong(ARC)：表示持有特性。setter方法将传入值先保留，再赋值，传入参数的retaincount会+1。</span><br><span class="line">5.copy：表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。</span><br><span class="line">6.nonatomic：非原子操作。不写的话就默认是atomic。atomic和nonatomic的区别在于，系统自动生成getter/setter方法不一样。对于atomic属性，系统生成的getter/setter会保证get、set操作的完整性，而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。不过atomic可并不能保证现成安全（nonatomic是非多线程下的，atomic是多线程下的）。</span><br></pre></td></tr></table></figure><h3 id="什么情况使用weak关键字，相比assign有什么不同？"><a href="#什么情况使用weak关键字，相比assign有什么不同？" class="headerlink" title="什么情况使用weak关键字，相比assign有什么不同？"></a>什么情况使用weak关键字，相比assign有什么不同？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决，比如delegate属性。</span><br><span class="line">2.自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用weak，自定义IBOutLet控件属性一般使用weak，当然也可以使用strong。</span><br><span class="line">IBOutlet连出来的视图属性为什么可以被设置成weak？</span><br><span class="line">因为父控件的subViews数组已经对它有一个强引用。</span><br><span class="line">不同点：</span><br><span class="line">assign可以用非OC对象，而weak必须用于OC对象。</span><br><span class="line">weak表明该属性定义了一种”非拥有关系“。在属性所指的对象销毁时，属性值会自动清空(nil)。</span><br></pre></td></tr></table></figure><h3 id="怎么用copy关键字？"><a href="#怎么用copy关键字？" class="headerlink" title="怎么用copy关键字？"></a>怎么用<code>copy</code>关键字？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用途：</span><br><span class="line">1.NSString、NSArray、NSDictionary等等经常使用copy关键字，是因为他们又对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</span><br><span class="line">2.block也经常使用copy关键字。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">block使用copy是从MRC遗留下来的”传统“，在MRC中，方法内部的block实在栈区的，使用copy可以把它放到堆区；在ARC中写不写都行；</span><br></pre></td></tr></table></figure><h3 id="用-property声明的NSString-NSArray-NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？"><a href="#用-property声明的NSString-NSArray-NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？" class="headerlink" title="用@property声明的NSString/NSArray/NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？"></a>用<code>@property</code>声明的NSString/NSArray/NSDictionary经常使用copy关键字，为什么？如果改用strong可能造成什么问题？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用@Property声明NSString、NSArray、NSDictionary经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作(把可变的赋值给不可变的)，为确保对象中的字符串值不会无意间变动，应该设置新属性时拷贝一份。</span><br><span class="line">1.因为父类指针可以指向子类对象，使用copy的目的是为了让本对象的属性不受外界影响，使用copy无论给我传入是一个可变对象还是不可变对象，我本身持有的就是一个不可变的副本。</span><br><span class="line">2.如果我们使用的是strong，那么这个属性就有可能指向一个可变对象，如果这个可变对象被修改了，那么会影响该属性。</span><br><span class="line">总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发生变化会无意间篡改不可变类型对象原来的值。</span><br></pre></td></tr></table></figure><h3 id="浅拷贝和深拷贝的区别？"><a href="#浅拷贝和深拷贝的区别？" class="headerlink" title="浅拷贝和深拷贝的区别？"></a>浅拷贝和深拷贝的区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浅拷贝：只复制指向对象的指针，而不复制引用对象本身。</span><br><span class="line">深拷贝：复制引用对象本身。内存中存在了两份独立的对象本身，当修改A时，A_copy不变。</span><br></pre></td></tr></table></figure><h3 id="系统对象的copy与mutableCopy方法"><a href="#系统对象的copy与mutableCopy方法" class="headerlink" title="系统对象的copy与mutableCopy方法"></a>系统对象的<code>copy</code>与<code>mutableCopy</code>方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不管是集合类对象(NSArray、NSDictionary、NSSet...之类的对象)，还是非集合类对象(NSString、NSNumber...之类的对象)，接收到copy和mutableCopy消息时，都遵循以下准则：</span><br><span class="line">1.copy返回的是不可变对象(immuatableObject)；如果用copy返回值调用mutable对象的方法就会crash。</span><br><span class="line">2.mutableCopy返回的是可变对象(mutableObject)。</span><br><span class="line">总结一句话：只有对不可变对象进行copy操作是指针复制(浅复制)，其他情况都是内容复制(深复制)！</span><br></pre></td></tr></table></figure><h3 id="这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-array"><a href="#这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-array" class="headerlink" title="这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *array;"></a>这个写法会出什么问题：<code>@property (nonatomic, copy) NSMutableArray *array;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题：添加，删除，修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃。</span><br><span class="line">原因：是因为copy就是复制一个不可变NSArray的对象，不能对NSArray对象进行添加/修改。</span><br></pre></td></tr></table></figure><h3 id="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"><a href="#如何让自己的类用copy修饰符？如何重写带copy关键字的setter？" class="headerlink" title="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"></a>如何让自己的类用<code>copy</code>修饰符？如何重写带<code>copy</code>关键字的<code>setter</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本和不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。</span><br><span class="line">具体步骤：</span><br><span class="line">1.需声明该类遵从NSCopying协议。</span><br><span class="line">2.实现NSCopying协议的方法。</span><br><span class="line">// 该协议只有一个方法：</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone;</span><br><span class="line">// 注意：使用copy修饰符，调用的是copy方法，其实真正需要实现的是&quot;copyWithZone&quot;方法。</span><br></pre></td></tr></table></figure><h3 id="写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic-copy-NSString-name"><a href="#写一个setter方法用于完成-property-nonatomic-retain-NSString-name-写一个setter方法用于完成-property-nonatomic-copy-NSString-name" class="headerlink" title="写一个setter方法用于完成@property (nonatomic, retain) NSString *name; 写一个setter方法用于完成@property (nonatomic, copy) NSString *name;"></a>写一个setter方法用于完成<code>@property (nonatomic, retain) NSString *name;</code> 写一个setter方法用于完成<code>@property (nonatomic, copy) NSString *name;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// retain</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    [name retain];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// copy</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    id t = [name copy];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synthesize和-dynamic分别有什么作用？"><a href="#synthesize和-dynamic分别有什么作用？" class="headerlink" title="@synthesize和@dynamic分别有什么作用？"></a><code>@synthesize</code>和<code>@dynamic</code>分别有什么作用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property有两个对应的词，一个是@synthesize(合成实例变量)，一个是@dynamic。</span><br><span class="line">如果@synthesize和@dynamic都没有写，那么默认的就是@synthesize var = _var;</span><br><span class="line">// 在类的实现代码里通过@synthesize语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</span><br><span class="line">1.@synthesize的语义是如果你没有手动实现setter和getter方法，那么编译器会自动为你加上这两个方法。</span><br><span class="line">2.@dynamic告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成(如@dynamic var)。</span><br></pre></td></tr></table></figure><h3 id="常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。"><a href="#常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。" class="headerlink" title="常见的Objective-C的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。"></a>常见的<code>Objective-C</code>的数据类型有哪些，和C的基本数据类型有什么区别？如NSInteger和int。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值；NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型int或者long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定本身是int还是long。</span><br></pre></td></tr></table></figure><h3 id="id声明的对象有什么特性？"><a href="#id声明的对象有什么特性？" class="headerlink" title="id声明的对象有什么特性？"></a><code>id</code>声明的对象有什么特性？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id声明的对象具有运动时的特性，即可以指向任意类型的Objective-C的对象。</span><br></pre></td></tr></table></figure><h3 id="Objective-C如何对内存管理的，说说你的看法和解决办法？"><a href="#Objective-C如何对内存管理的，说说你的看法和解决办法？" class="headerlink" title="Objective-C如何对内存管理的，说说你的看法和解决办法？"></a><code>Objective-C</code>如何对内存管理的，说说你的看法和解决办法？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</span><br><span class="line">1.自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。</span><br><span class="line">2.手动内存计数MRC：遵循内存谁申请、谁释放；谁添加、谁释放的原则。</span><br><span class="line">3.内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</span><br></pre></td></tr></table></figure><h3 id="Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？"><a href="#Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？" class="headerlink" title="Objective-C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？"></a><code>Objective-C</code>中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延迟执行代码，方法又是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程的创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类的NSOPeration，然后将其加入NSOperationQueue；在主线程执行代码，方法是performSelectorOnMainThread，如果想延迟执行代码可以用performSelector:onThread:withObject:waitUntilDone;</span><br></pre></td></tr></table></figure><h3 id="Category-类别-、Extension-扩展-和继承的区别。"><a href="#Category-类别-、Extension-扩展-和继承的区别。" class="headerlink" title="Category(类别)、Extension(扩展)和继承的区别。"></a><code>Category</code>(类别)、<code>Extension</code>(扩展)和继承的区别。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">区别：</span><br><span class="line">1.分类有名字，类扩展没有分类名字，是一种特殊的分类。</span><br><span class="line">2.分类只能扩展方法(属性仅仅是声明，并没有真正实现)，类扩展可以扩展属性、成员变量和方法。</span><br><span class="line">3.继承可以增加，修改或者删除方法，并且可以增加属性。</span><br></pre></td></tr></table></figure><h3 id="我们说的OC是动态运行时语言是什么意思？"><a href="#我们说的OC是动态运行时语言是什么意思？" class="headerlink" title="我们说的OC是动态运行时语言是什么意思？"></a>我们说的<code>OC</code>是动态运行时语言是什么意思？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主要是讲数据类型的确定由编译时，推迟到了运行时。简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</span><br></pre></td></tr></table></figure><h3 id="为什么我们常见的delegate属性都用是weak而不是retain-strong？"><a href="#为什么我们常见的delegate属性都用是weak而不是retain-strong？" class="headerlink" title="为什么我们常见的delegate属性都用是weak而不是retain/strong？"></a>为什么我们常见的<code>delegate</code>属性都用是<code>weak</code>而不是<code>retain</code>/<code>strong</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是为了防止delegate两端产生不必要的循环引用。</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br></pre></td></tr></table></figure><h3 id="什么时候共delegate，什么时候用Notification？"><a href="#什么时候共delegate，什么时候用Notification？" class="headerlink" title="什么时候共delegate，什么时候用Notification？"></a>什么时候共<code>delegate</code>，什么时候用<code>Notification</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Delegate(委托模式)：1对1的反向消息通知功能。</span><br><span class="line">Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</span><br></pre></td></tr></table></figure><h3 id="什么是KVO和KVC？"><a href="#什么是KVO和KVC？" class="headerlink" title="什么是KVO和KVC？"></a>什么是<code>KVO</code>和<code>KVC</code>？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.KVC(Key-Value-Coding)：键值编码，是一种通过字符串间接访问对象的方式(即给属性赋值)。</span><br><span class="line">举例说明：</span><br><span class="line">stu.name = @&quot;张三&quot;;// 点语法给属性赋值</span><br><span class="line">[stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;];// 通过字符串使用KVC方式给属性赋值</span><br><span class="line">2.KVO(Key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大简化了代码。</span><br><span class="line">KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。</span><br><span class="line">// 通过下方方法为属性添加KVO观察</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line"></span><br><span class="line">// 当被观察的属性发生变化时，会自动触发下方方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</span><br><span class="line"></span><br><span class="line">KVC和KVO的keyPath可以是属性、实例变量、成员变量。</span><br></pre></td></tr></table></figure><h3 id="KVC的底层实现？"><a href="#KVC的底层实现？" class="headerlink" title="KVC的底层实现？"></a><code>KVC</code>的底层实现？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个对象调用setValue方法时，方法内部会做以下操作：</span><br><span class="line">1.检查是否存在相应的key的set方法，如果存在，就调用set方法。</span><br><span class="line">2.如果set方法不存在，就会查找与key相同名称并且带有下划线的成员变量，如果有，则直接给成员变量赋值。</span><br><span class="line">3.如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</span><br><span class="line">4.如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndeinedKey:方法。</span><br><span class="line">这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</span><br></pre></td></tr></table></figure><h3 id="KVO的底层实现？"><a href="#KVO的底层实现？" class="headerlink" title="KVO的底层实现？"></a><code>KVO</code>的底层实现？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KVO基于runtime机制实现。</span><br></pre></td></tr></table></figure><h3 id="ViewController生命周期"><a href="#ViewController生命周期" class="headerlink" title="ViewController生命周期"></a><code>ViewController</code>生命周期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按照执行顺序排列：</span><br><span class="line">1.initWithCoder: 通过nib文件初始化时触发。</span><br><span class="line">2.awakeFromNib: nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。</span><br><span class="line">3.loadView: 开始加载视图控制器自带的view。</span><br><span class="line">4.viewDidLoad: 视图控制器的view被加载完成。</span><br><span class="line">5.viewWillAppear: 视图控制器的view将要显示在window上。</span><br><span class="line">6.updateViewConstraints: 视图控制器的view开始更新AutoLayout约束。</span><br><span class="line">7.viewWillLayoutSubviews: 视图控制器的view将要更新内容视图的位置。</span><br><span class="line">8.viewDidLayoutSubviews: 视图控制器的view已经更新视图的位置。</span><br><span class="line">9.viewDidApear: 试图控制器的view已经展示到window上。</span><br><span class="line">10.viewWillDisappear: 视图控制器的view将要从window上消失。</span><br><span class="line">11.viewDidDisappear: 视图控制器的view已经从window上消失。</span><br></pre></td></tr></table></figure><h3 id="方法和选择器有何不同？"><a href="#方法和选择器有何不同？" class="headerlink" title="方法和选择器有何不同？"></a>方法和选择器有何不同？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector是一个方法的名字，方法是一个组合体，包含了名字和实现。</span><br></pre></td></tr></table></figure><h3 id="你是否接触过OC中的反射机制？简单聊一下概念和使用"><a href="#你是否接触过OC中的反射机制？简单聊一下概念和使用" class="headerlink" title="你是否接触过OC中的反射机制？简单聊一下概念和使用"></a>你是否接触过<code>OC</code>中的反射机制？简单聊一下概念和使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.class反射</span><br><span class="line">通过类名的字符串形式实例化对象。</span><br><span class="line">Class class = NSCalssFromString(@&quot;student&quot;);</span><br><span class="line">Student *stu = [[class alloc] init];</span><br><span class="line">将类名变为字符串。</span><br><span class="line">Class class = [Student class];</span><br><span class="line">NSString className = NSStringFromClass(class);</span><br><span class="line">2.SEL的反射</span><br><span class="line">通过方法的字符串形式实例化方法。</span><br><span class="line">SEL selector = NSSelectorFrom(@&quot;setName&quot;);</span><br><span class="line">[stu performSelector:selector withObject:@&quot;Mike&quot;];</span><br><span class="line">将方法变成字符串。</span><br><span class="line">NSStringFromSelector(@selector(setName:));</span><br></pre></td></tr></table></figure><h3 id="调用方法有两种方式："><a href="#调用方法有两种方式：" class="headerlink" title="调用方法有两种方式："></a>调用方法有两种方式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.直接通过方法名来调用。</span><br><span class="line">[person show];</span><br><span class="line">2.间接的通过SEL数据来调用。</span><br><span class="line">SEL aaa = @selector(show); </span><br><span class="line">[person performSelector:aaa];</span><br></pre></td></tr></table></figure><h3 id="如何对iOS设备进行性能测试？"><a href="#如何对iOS设备进行性能测试？" class="headerlink" title="如何对iOS设备进行性能测试？"></a>如何对iOS设备进行性能测试？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Profile-&gt;Instruments-&gt;Time Profiler</span><br></pre></td></tr></table></figure><h3 id="开发项目时你是怎么检查内存泄漏？"><a href="#开发项目时你是怎么检查内存泄漏？" class="headerlink" title="开发项目时你是怎么检查内存泄漏？"></a>开发项目时你是怎么检查内存泄漏？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.静态分析analyze。</span><br><span class="line">2.instruments工具里面有个leak可以动态分析。</span><br></pre></td></tr></table></figure><h3 id="什么是懒加载？"><a href="#什么是懒加载？" class="headerlink" title="什么是懒加载？"></a>什么是懒加载？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。</span><br><span class="line">我觉得最好也最简单的一个例子就是tableView中的图片的加载显示，一个延时加载，避免内存过高，一个异步加载，避免线程堵塞提高用户体验。</span><br></pre></td></tr></table></figure><h3 id="类变量的-public-protected-private-package声明各有什么含义？"><a href="#类变量的-public-protected-private-package声明各有什么含义？" class="headerlink" title="类变量的 @public,@protected,@private,@package声明各有什么含义？"></a>类变量的 <code>@public</code>,<code>@protected</code>,<code>@private</code>,<code>@package</code>声明各有什么含义？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@public 任何地方都能访问；</span><br><span class="line">@protected 该类和子类中访问，是默认的；</span><br><span class="line">@private 只能在本类中访问；</span><br><span class="line">@package 本包内使用，跨包不可以。</span><br></pre></td></tr></table></figure><h3 id="什么是谓词？"><a href="#什么是谓词？" class="headerlink" title="什么是谓词？"></a>什么是谓词？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">谓词就是通过NSPredicate给定的逻辑条件作为约束条件，完成对数据的筛选。</span><br><span class="line">// 定义谓词对象，谓词对象中包含了过滤条件(过滤条件比较多)</span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormate:@&quot;age &lt; %d&quot;, 30];</span><br><span class="line">// 使用谓词条件过滤数组中的元素，过滤之后返回查询结果</span><br><span class="line">NSArray *array = [persons filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure><h3 id="isa指针问题"><a href="#isa指针问题" class="headerlink" title="isa指针问题"></a><code>isa</code>指针问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isa：是一个Class类型的指针。每个实例对象有个isa的指针，他指向对象的类，而Class里也有个isa的指针，指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现。如果没有，元类会向他父类查找该方法。同时注意的是：元类(meteClass)也是类，它也是对象。元类也有isa指针，它的isa指针最终指向的是根元类(root meteClass)。根元类的isa指针指向本身，这样形成了一个闭环的内循环。</span><br></pre></td></tr></table></figure><h3 id="如何访问并修改一个类的私有属性？"><a href="#如何访问并修改一个类的私有属性？" class="headerlink" title="如何访问并修改一个类的私有属性？"></a>如何访问并修改一个类的私有属性？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.一种是通过KVC获取。</span><br><span class="line">2.通过runtime访问并修改私有属性。</span><br></pre></td></tr></table></figure><h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个<code>objc</code>对象的<code>isa</code>的指针指向什么？有什么作用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指向他的类对象，从而可以找到对象上的方法。</span><br></pre></td></tr></table></figure><h3 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// 解析：</span><br><span class="line">self是类的隐藏参数，指向当前调用方法的这个类的实例。</span><br><span class="line">super是一个Magic Keyword，它本质是一个编译标识符，和self是指向的同一个消息接收者。</span><br><span class="line">不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。</span><br><span class="line">上面的例子不管调用[self class]还是[super class]，接收消息的对象都是当前Son *obj这个对象。</span><br></pre></td></tr></table></figure><h3 id="写一个完整的代理，包括声明、实现"><a href="#写一个完整的代理，包括声明、实现" class="headerlink" title="写一个完整的代理，包括声明、实现"></a>写一个完整的代理，包括声明、实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建 </span><br><span class="line">@protocol MyDelegate : NSObject</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">- (void)eat:(NSString *)foodName;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 声明.h </span><br><span class="line">@interface Person : NSObject &lt;MyDelegate&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 实现.m</span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)eat:(NSString *)foodName &#123;</span><br><span class="line">    NSLog(@&quot;吃：%@&quot;, foodName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    NSLog(@&quot;run&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="isKindOfClass、isMemberOfClass、selector作用分别是什么？"><a href="#isKindOfClass、isMemberOfClass、selector作用分别是什么？" class="headerlink" title="isKindOfClass、isMemberOfClass、selector作用分别是什么？"></a><code>isKindOfClass</code>、<code>isMemberOfClass</code>、<code>selector</code>作用分别是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isKindOfClass： 作用是某个对象属于某个类型或者继承自某类。</span><br><span class="line">isMemberOfClass：某个对象确切属于某个类型。</span><br><span class="line">selector：通过方法名，获取在内存中的函数的入口地址。</span><br></pre></td></tr></table></figure><h3 id="delegate和notification的区别"><a href="#delegate和notification的区别" class="headerlink" title="delegate和notification的区别"></a><code>delegate</code>和<code>notification</code>的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.二者都用于传递消息，不同之处主要在于一个是一对一的，一个是一对多的。</span><br><span class="line">2.notification通过维护一个array，实现一对消息的转发。</span><br><span class="line">3.delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。</span><br></pre></td></tr></table></figure><h3 id="什么是block？"><a href="#什么是block？" class="headerlink" title="什么是block？"></a>什么是block？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">闭包(block)：闭包就是获取其它函数局部变量的匿名函数。</span><br></pre></td></tr></table></figure><h3 id="block反向传值"><a href="#block反向传值" class="headerlink" title="block反向传值"></a>block反向传值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在控制器间传值可以使用代理或者block，使用block相对来说简洁。</span><br><span class="line">在前一个控制器的touchesBegan:方法内实现如下代码。</span><br><span class="line">// OneViewController.m</span><br><span class="line">TwoViewController *twoVC = [[TwoViewController alloc] init];</span><br><span class="line">towVC.valueBlock = ^(NSString *str) &#123;</span><br><span class="line">    NSLog(@&quot;OneViewController:%@&quot;, str);</span><br><span class="line">&#125;;</span><br><span class="line">[self presentViewController:twoVC animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">// TwoViewController.h (在.h文件中声明一个block属性)</span><br><span class="line">@property (nonatomic, copy) void (^valueBlock)(NSString *str);</span><br><span class="line">// TwoViewController.m (在.m中实现方法)</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    // 传值：调用block</span><br><span class="line">    if (_valueBlock) &#123;</span><br><span class="line">        _valueBlock(@&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block的注意点"><a href="#block的注意点" class="headerlink" title="block的注意点"></a><code>block</code>的注意点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在block内部使用外部指针且会造成玄幻引用情况下，需要用__weak修饰外部指针：</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">2.在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。</span><br><span class="line">__strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">3.如果需要在block内部改变外部栈区变量的话，需要用__block修饰外部变量。</span><br></pre></td></tr></table></figure><h3 id="BAD-ACCESS在什么情况下出现？"><a href="#BAD-ACCESS在什么情况下出现？" class="headerlink" title="BAD_ACCESS在什么情况下出现？"></a>BAD_ACCESS在什么情况下出现？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</span><br></pre></td></tr></table></figure><h3 id="IIdb（gdb）常用的控制台调用命令？"><a href="#IIdb（gdb）常用的控制台调用命令？" class="headerlink" title="IIdb（gdb）常用的控制台调用命令？"></a>IIdb（gdb）常用的控制台调用命令？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.p输出基本类型。是打印命令，需要指定类型。是print的缩写。</span><br><span class="line">p(int)[[[self view] subviews] count]</span><br><span class="line">2.po 打印对象，会调用对象description方法。是print-object的简写。</span><br><span class="line">po [self view]</span><br><span class="line">3.expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用在调试过程中修改变量的值。</span><br><span class="line">4.bt：打印调用堆栈，是thread backrace的简写，加all可以打印所有thread的堆栈。</span><br><span class="line">5.br |：是breakpoint list的简写。</span><br></pre></td></tr></table></figure><h3 id="你一般是怎么用Instruments的？"><a href="#你一般是怎么用Instruments的？" class="headerlink" title="你一般是怎么用Instruments的？"></a>你一般是怎么用Instruments的？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Instruments里面工具很多，常用：</span><br><span class="line">1.Time Profiler：性能分析</span><br><span class="line">2.Zombies：检查是否访问了僵尸对象，但是这个工具从上往下检查，不智能。</span><br><span class="line">3.Allocations：用来检查内存，写算法的那批人也用这个来检查。</span><br><span class="line">4.Leaks：检查内存，看是否有内存泄漏。</span><br></pre></td></tr></table></figure><h3 id="iOS中常用的数据存储方式有哪些？"><a href="#iOS中常用的数据存储方式有哪些？" class="headerlink" title="iOS中常用的数据存储方式有哪些？"></a>iOS中常用的数据存储方式有哪些？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据存储方式有四种方案：NSUserDefault、KeyChain、File、DB。</span><br><span class="line">其中File有三种方式：writeToFile:atomically:、Plist、NSKeyedArchiever(归档)</span><br><span class="line">DB包含：SQLite、FMDB、CoreData</span><br></pre></td></tr></table></figure><h3 id="iOS的沙盒目录结构是怎样的？"><a href="#iOS的沙盒目录结构是怎样的？" class="headerlink" title="iOS的沙盒目录结构是怎样的？"></a>iOS的沙盒目录结构是怎样的？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">沙盒结构：</span><br><span class="line">1.AppName.app目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。</span><br><span class="line">2.Documents：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据。iCloud备份目录。(这里不能存缓存文件，否则上架不被通过)</span><br><span class="line">3.Library目录：这个目录下有两个子目录：</span><br><span class="line">Preferences目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好。</span><br><span class="line">Caches目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。</span><br><span class="line">可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除Caches以外，都会被iTunes备份。</span><br><span class="line">4.tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</span><br></pre></td></tr></table></figure><h3 id="iOS多线程技术有哪几种方式？"><a href="#iOS多线程技术有哪几种方式？" class="headerlink" title="iOS多线程技术有哪几种方式？"></a>iOS多线程技术有哪几种方式？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prhread、NSThread、GCD、NSOperation</span><br></pre></td></tr></table></figure><h3 id="GCD与NSOperation的区别"><a href="#GCD与NSOperation的区别" class="headerlink" title="GCD与NSOperation的区别"></a><code>GCD</code>与<code>NSOperation</code>的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GCD和NSOperation都是用于实现多线程：</span><br><span class="line">GCD基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。</span><br><span class="line">NSOperation属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。</span><br></pre></td></tr></table></figure><h3 id="写出使用GCD方式从子线程回到主线程的方法代码"><a href="#写出使用GCD方式从子线程回到主线程的方法代码" class="headerlink" title="写出使用GCD方式从子线程回到主线程的方法代码"></a>写出使用GCD方式从子线程回到主线程的方法代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）"><a href="#如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）" class="headerlink" title="如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）"></a>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后都下载完成后合成一整张图）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用Dispatch Group追加block到Global Group Queue，这些block如果全部执行完毕，就会执行Main DispatchQueue中的结束处理的block。</span><br><span class="line">// 创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 获取全局并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片1 **/&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片2 **/&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;/* 加载图片3 **/&#125;);</span><br><span class="line">// 当并发队列组中的任务执行完毕后才会执行这里的代码</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;/* 合并图片 **/&#125;);</span><br></pre></td></tr></table></figure><h3 id="dispatch-barrier-async-栅栏函数-的作用是什么？"><a href="#dispatch-barrier-async-栅栏函数-的作用是什么？" class="headerlink" title="dispatch_barrier_async(栅栏函数)的作用是什么？"></a>dispatch_barrier_async(栅栏函数)的作用是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class="line">作用：</span><br><span class="line">1.在它前面的任务执行结束后才执行，它后面的任务要等它执行完成后才开始执行。</span><br><span class="line">2.避免数据竞争。</span><br><span class="line">// 1.创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 2.向队列中添加任务</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">   // 1.2是并行的</span><br><span class="line">   NSLog(@&quot;任务1，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">   NSLog(@&quot;任务2，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">   NSLog(@&quot;任务 barrier，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这两个是同时执行的 </span><br><span class="line">    NSLog(@&quot;任务3，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务4，%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出结果：任务1 任务2 -&gt; 任务barrier -&gt;任务3 任务4</span><br><span class="line">// 其中任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。</span><br></pre></td></tr></table></figure><h3 id="以下代码运行结果如何？"><a href="#以下代码运行结果如何？" class="headerlink" title="以下代码运行结果如何？"></a>以下代码运行结果如何？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    dispatch_asyc(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">    // 只输出：1。主线程死锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从字面上看，就是运行循环，跑圈</span><br><span class="line">其实它内部就是do-while循环，在这个循环内部不断处理各种任务(比如Source、Timer、Observer)</span><br><span class="line">一个现成对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。</span><br><span class="line">通过RunLoop，有事运行，没事就休息，可以节省CPU资源，提高程序性能。</span><br><span class="line"></span><br><span class="line">主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        return UIApplicationMain&#123;argc, argv, nil, NSStringFromClass([AppDelegate class])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说说你对runtime的理解"><a href="#说说你对runtime的理解" class="headerlink" title="说说你对runtime的理解"></a>说说你对runtime的理解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。</span><br></pre></td></tr></table></figure><h3 id="Runtime实现机制是什么，怎么用，一般用于干嘛？"><a href="#Runtime实现机制是什么，怎么用，一般用于干嘛？" class="headerlink" title="Runtime实现机制是什么，怎么用，一般用于干嘛？"></a>Runtime实现机制是什么，怎么用，一般用于干嘛？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用时需要导入的头文件</span><br><span class="line">2.Runtime运行时机制，它是一套C语言库。</span><br><span class="line">3.实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</span><br><span class="line">比如：</span><br><span class="line">类转成了Runtime库里面的结构体等数据类型。</span><br><span class="line">方法转成了Runtime库里面的C语言函数。</span><br><span class="line">平时调方法都是转成了objc_msgSend函数(所以说OC有个消息转发机制)</span><br><span class="line">// OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</span><br><span class="line">// [stu show]; 在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));</span><br><span class="line">4.因此，可以说Runtime是OC的底层实现，是OC的幕后执行者。</span><br><span class="line"></span><br><span class="line">有了Runtime库，能做什么事情呢？</span><br><span class="line">Runtime库里面包含了跟类、成员变量、方法相关的API。</span><br><span class="line">比如：</span><br><span class="line">1.获取类里面的所有成员变量。</span><br><span class="line">2.为类动态添加成员变量。</span><br><span class="line">3.为类动态添加新的方法。</span><br><span class="line">4.动态改变类的方法实现等。(Method Swizzling)</span><br><span class="line">因此，有了Runtime，想怎么改就怎么改。</span><br></pre></td></tr></table></figure><h3 id="什么是Method-Swizzle（黑魔法），什么情况下会使用？"><a href="#什么是Method-Swizzle（黑魔法），什么情况下会使用？" class="headerlink" title="什么是Method Swizzle（黑魔法），什么情况下会使用？"></a>什么是Method Swizzle（黑魔法），什么情况下会使用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法Method Swizzle。</span><br><span class="line">2.Method Swizzle指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变类的调度表中选择器到最终函数的映射关系。</span><br><span class="line">3.在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。</span><br><span class="line">4.每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。</span><br><span class="line">5.我们可以利用method_exchangeImplementations来交换2个方法中的IMP。</span><br><span class="line">6.我们可以利用class_replaceMethod来修改类。</span><br><span class="line">7.我们可以利用method_setImplementation来直接设置某个方法的IMP。</span><br><span class="line">8.归根结底，都是偷换了selector的IMP。</span><br></pre></td></tr></table></figure><h3 id="objc-msgForward函数是做什么的，直接调用它将会发生什么？"><a href="#objc-msgForward函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="_objc_msgForward函数是做什么的，直接调用它将会发生什么？"></a><code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</span><br></pre></td></tr></table></figure><h3 id="什么是TCP-UDP？"><a href="#什么是TCP-UDP？" class="headerlink" title="什么是TCP/UDP？"></a>什么是TCP/UDP？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP：传输控制协议。</span><br><span class="line">UDP：用户数据协议。</span><br><span class="line"></span><br><span class="line">TCP是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。</span><br><span class="line">UDP是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。</span><br><span class="line">简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。</span><br></pre></td></tr></table></figure><h3 id="通信底层原理（OSI七层模型）"><a href="#通信底层原理（OSI七层模型）" class="headerlink" title="通信底层原理（OSI七层模型）"></a>通信底层原理（OSI七层模型）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OSI采用了分层的结构化技术，共分七层：</span><br><span class="line">物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</span><br></pre></td></tr></table></figure><h3 id="OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？"><a href="#OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？" class="headerlink" title="OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？"></a>OC中创建现成的方法是什么？如果在主线程中执行代码，方法是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建线程的方法</span><br><span class="line">- [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil];</span><br><span class="line">- [self performSelectorInBackground:nil withObject:nil];</span><br><span class="line">- [[NSThread alloc] initWithTarget:nil selector:nil object:nil];</span><br><span class="line">- dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;&#125;);</span><br><span class="line">- [[NSOperationQueue new] addOperation:nil];</span><br><span class="line">// 主线程中执行代码的方法</span><br><span class="line">- [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES];</span><br><span class="line">- dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</span><br><span class="line">- [[NSOperationQueue mainQueue] addOperation:nil];</span><br></pre></td></tr></table></figure><h3 id="tableView的重用机制？"><a href="#tableView的重用机制？" class="headerlink" title="tableView的重用机制？"></a>tableView的重用机制？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UITableView通过重用单元格达到节省内存的目的；通过为每个单元格指定一个重用的标识符，即指定了单元格的种类，当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新的单元格从屏幕外滑入屏幕时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</span><br></pre></td></tr></table></figure><h3 id="用伪代码写一个现成安全的单例模式"><a href="#用伪代码写一个现成安全的单例模式" class="headerlink" title="用伪代码写一个现成安全的单例模式"></a>用伪代码写一个现成安全的单例模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static id _instance;</span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareData &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何实现视图的变形？"><a href="#如何实现视图的变形？" class="headerlink" title="如何实现视图的变形？"></a>如何实现视图的变形？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过修改view的transform属性即可。</span><br></pre></td></tr></table></figure><h3 id="在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？"><a href="#在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？" class="headerlink" title="在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？"></a>在手势对象基础类<code>UIGestureRecognizer</code>的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UITapGestureRecognizer、UISwipeGestureRecognizer是一次性手势，手势发生后，响应只会执行一次。</span><br></pre></td></tr></table></figure><h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *str = @&quot;abc123&quot;;</span><br><span class="line">NSArray *arr = [str componentsSeperatedByString:@&quot;&quot;];</span><br></pre></td></tr></table></figure><h3 id="如何高性能的给UIImageView加个圆角？"><a href="#如何高性能的给UIImageView加个圆角？" class="headerlink" title="如何高性能的给UIImageView加个圆角？"></a>如何高性能的给UIImageView加个圆角？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制，而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。</span><br><span class="line">self.view.layer.cornerRadius = 5.0f;</span><br><span class="line">self.view.layer.masksToBounds = YES;</span><br><span class="line"></span><br><span class="line">正确的解决方案：使用绘图技术</span><br><span class="line">- (UIImage *)circleImage &#123;</span><br><span class="line">// NO代表透明 </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">    // 获得上下文</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">    // 添加一个圆</span><br><span class="line">    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">    CGContextAddEllipseInRect(ctx, rect);</span><br><span class="line">    // 裁剪</span><br><span class="line">    CGContextClip(ctx);</span><br><span class="line">    // 将图片画上去</span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    // 关闭上下文</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有一种方案：使用贝塞尔曲线“切割”这个图片，给UIImageView添加的圆角，其实也是通过绘图技术来实现的。</span><br><span class="line">UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">imageView.center = CGPointMake(200, 300);</span><br><span class="line">UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1);</span><br><span class="line">[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:50] addClip];</span><br><span class="line">[anotherImage drawInRct:imageView.bounds];</span><br><span class="line">imageView.image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">[self.view addSubview:imageView];</span><br></pre></td></tr></table></figure><h3 id="你是怎么封装一个view的"><a href="#你是怎么封装一个view的" class="headerlink" title="你是怎么封装一个view的"></a>你是怎么封装一个view的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.可以通过纯代码或者xib的方式来封装子控件。</span><br><span class="line">2.建立一个跟view相关的模型，然后将模型数据给view，通过模型上的数据给view的子控件赋值。</span><br><span class="line">/** 纯代码初始化控件时一定会走这个方法 */</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 通过xib初始化控件时一定会走这个方法 */</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</span><br><span class="line">        [self setupUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupUI &#123;// 初始化代码 &#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP协议中POST方法和GET方法有哪些区别？"><a href="#HTTP协议中POST方法和GET方法有哪些区别？" class="headerlink" title="HTTP协议中POST方法和GET方法有哪些区别？"></a>HTTP协议中POST方法和GET方法有哪些区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.GET用于向服务器请求数据，POST用于提交数据。</span><br><span class="line">2.GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作。</span><br><span class="line">3.GET请求的URL有长度限制，POST请求不会有长度限制。</span><br></pre></td></tr></table></figure><h3 id="请简单的介绍下APNS发送系统消息的机制"><a href="#请简单的介绍下APNS发送系统消息的机制" class="headerlink" title="请简单的介绍下APNS发送系统消息的机制"></a>请简单的介绍下APNS发送系统消息的机制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。</span><br><span class="line">APNS的原理：</span><br><span class="line">1.应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)；</span><br><span class="line">2.应用程序接收到设备令牌并发送给自己的后台服务器；</span><br><span class="line">3.服务器把要推送的内容和设备发送给APNS；</span><br><span class="line">4.APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示。</span><br></pre></td></tr></table></figure><h3 id="iOS开发逆向传值的集中方法整理"><a href="#iOS开发逆向传值的集中方法整理" class="headerlink" title="iOS开发逆向传值的集中方法整理"></a>iOS开发逆向传值的集中方法整理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.代理传值</span><br><span class="line">2.通知传值</span><br><span class="line">3.单例传值</span><br><span class="line">4.block传值</span><br><span class="line">5.extern传值(全局变量)</span><br><span class="line">6.KVO传值</span><br></pre></td></tr></table></figure><h3 id="你使用过Objective-C的运行时编程-Runtime-Programming-么-如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"><a href="#你使用过Objective-C的运行时编程-Runtime-Programming-么-如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？" class="headerlink" title="你使用过Objective-C的运行时编程(Runtime Programming)么?如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"></a>你使用过Objective-C的运行时编程(Runtime Programming)么?如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C的重要特性是Runtime(运行时)，在#import下能看到相关的方法，用objc_getClass()和class_copyMethodList()获取过私有API；使用</span><br><span class="line">Method method1 = class_getInstanceMethod(cls, sel1);</span><br><span class="line">Method method2 = class_getInstanceMethod(cls, sel2);</span><br><span class="line">method_exchangeImplementations(method1, method2);</span><br><span class="line"></span><br><span class="line">代码交换两个方法，在写unit test时使用到。</span><br></pre></td></tr></table></figure><h3 id="Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）"><a href="#Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）" class="headerlink" title="Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）"></a>Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics？UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UI框架的底层有CoreAnimation，CoreAnimation的底层有CoreGraphics。</span><br><span class="line">UIKit|</span><br><span class="line">--------|</span><br><span class="line">Core Animation|</span><br><span class="line">Core Graphics|</span><br><span class="line">Graphics Hardware|</span><br><span class="line">使用CA做过menu菜单的展开收起</span><br></pre></td></tr></table></figure><h3 id="是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。"><a href="#是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。" class="headerlink" title="是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。"></a>是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CoreText可以解决复杂文字内容排版问题。CoreImage可以处理图片，为其添加各种效果。体验是很强大，挺复杂的。</span><br></pre></td></tr></table></figure><h3 id="自动释放池是什么，如何工作"><a href="#自动释放池是什么，如何工作" class="headerlink" title="自动释放池是什么，如何工作"></a>自动释放池是什么，如何工作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放，它仍然是个OC的对象，因此自动释放池定义的作用域内的其它对象可以向他发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。</span><br></pre></td></tr></table></figure><h3 id="NSNotification和KVO的区别和用法是什么-什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate-或者delegate的Array-来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么-虽然protocol和delegate这种东西面试已经面烂了"><a href="#NSNotification和KVO的区别和用法是什么-什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate-或者delegate的Array-来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么-虽然protocol和delegate这种东西面试已经面烂了" class="headerlink" title="NSNotification和KVO的区别和用法是什么?什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate(或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么?(虽然protocol和delegate这种东西面试已经面烂了)"></a>NSNotification和KVO的区别和用法是什么?什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果使用protocol和delegate(或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么?(虽然protocol和delegate这种东西面试已经面烂了)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSNotification是通知模式在iOS的实现，KVO的全称是键值观察(Key-value observing)，其是基于KVC(key-value coding)的，KVC是一个通过属性名访问属性变量的机制。例如Module层的变化，通知到多个Controller对象时，可以使用NSNotification；如果是只需要观察某个对象的某个属性，可以使用KVO。</span><br><span class="line">对于委托模式，在设计模式中是对象适配器模式，其是delegate是指向某个对象，这是一对一的关系，而在通知模式中，往往是一对多的关系。委托模式，从技术上可以实现改变delegate指向的对象，但不建议这样做，会让人迷惑，如果一个delegate对象不断改变，指向不同的对象。</span><br></pre></td></tr></table></figure><h3 id="你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）"><a href="#你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）" class="headerlink" title="你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）"></a>你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用NSOperationQueue用来管理子类化的NSOperation对象，控制其线程并发数目。GCD和NSOperation都可以实现对线程的管理，区别是NSOperation和NSOperationQueue是多线程的面向对象抽象。项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的有点(复用、封装)，使得实现多线程支持，而接口简单，建议在复杂项目中使用。</span><br><span class="line">项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会使代码更为易读，建议在简单项目中使用。</span><br></pre></td></tr></table></figure><h3 id="既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么"><a href="#既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么" class="headerlink" title="既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?"></a>既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用block时要注意，若将block做函数参数时，需要把它放到最后，GCD是Grand Central Dispatch，是一个对线程开源类库，而Block是闭包，是能够读取其它函数内部变量的函数。</span><br></pre></td></tr></table></figure><h3 id="对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？"><a href="#对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？" class="headerlink" title="对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？"></a>对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体如何做？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用link命令及flag解决冲突。</span><br></pre></td></tr></table></figure><h3 id="你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。"><a href="#你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。" class="headerlink" title="你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。"></a>你实现过一个框架或者库以供别人使用么？如果有，清谈一谈构建框架或者库的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一个文件解压压缩框架，从使用者角度出发，只需要关注发送给框架一个解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给使用者，如解压完成、解压出错等。在框架内部去构建对象的关系，通过抽象让其更为健壮、便于更改。其次是API的说明文档。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闲谈&quot;&gt;&lt;a href=&quot;#闲谈&quot; class=&quot;headerlink&quot; title=&quot;闲谈&quot;&gt;&lt;/a&gt;闲谈&lt;/h1&gt;&lt;p&gt;最近正好公司招聘，闲暇之余整理一份iOS面试问题，以备不时之需。会时常更新，谢谢大家批评指正。&lt;/p&gt;
&lt;h1 id=&quot;基础&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-Runloop浅谈</title>
    <link href="http://htmlios.github.io/2016/07/02/iOS-Runloop%E6%B5%85%E8%B0%88/"/>
    <id>http://htmlios.github.io/2016/07/02/iOS-Runloop浅谈/</id>
    <published>2016-07-02T01:52:00.000Z</published>
    <updated>2018-07-05T03:49:30.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Runloop概述"><a href="#Runloop概述" class="headerlink" title="Runloop概述"></a>Runloop概述</h3><p>学习操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initLoop();</span><br><span class="line">    do &#123;</span><br><span class="line">        if (message_hasTask()) &#123;</span><br><span class="line">            message_execute(get_current_message());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while(message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型事件被唤醒之后，如何快速的进行相应；当模型处于等待状态时，如何减少资源消耗等等。</p><p>这种模型，在iOS中被称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。</p><p>在iOS中，提供了两种有关的对象，一种是<code>NSRunLoop</code>，另外一种是<code>CFRunLoopRef</code>。</p><p><code>CFRunLoopRef</code>是基于<code>CoreFundation</code>框架的，提供了纯C函数的API，所以这些API都是线程安全的。我们一般听到的<code>NSRunLoop</code>，是对<code>CFRunLoopRef</code>的封装，加上了面向对象的东西，所以这些API不是安全的。</p><p>所以，一般讲解<code>Runloop</code>的文章，其实都是在分析<code>CFRunLoopRef</code>这个东西。<code>CFRunLoopRef</code>的具体实现，苹果将它开源了出来，可以在引用里看到其链接。</p><h3 id="Runloop和线程"><a href="#Runloop和线程" class="headerlink" title="Runloop和线程"></a>Runloop和线程</h3><p>上面可以看出，需要实现一个Runloop模型，是基于线程之上的。所以，Runloop和线程是息息相关的，在iOS系统中，Runloop属于线程的基础架构部分。每个线程，包括程序的主线程，都有与之相关的Runloop模型。</p><p>其实，Runloop和线程的绑定，是保存在一个全局的Dictionary中，线程和Runloop之间是一一对应的。当线程创建后，默认并不启动Runloop，只有主动获取的时候，Runloop才会被创建，当线程结束后，对应的Runloop也会随之销毁。但是有个例外，就是主线程对应的Runloop默认是启动的。当程序启动的时候，会执行下面的函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，在<code>UIApplicationMain</code>内部棒我们开启了主线程的Runloop，相当于说，主线程是默认启动的。这样我们才可以监听触摸事件、页面刷新等等功能。</p><h3 id="Runloop结构"><a href="#Runloop结构" class="headerlink" title="Runloop结构"></a>Runloop结构</h3><p>Runloop主要由5个类组成。如下所示：</p><ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><p>其关系如下图：</p><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop6.png" alt="Runloop关系图"></p><p>一个Runloop包含多个Mode，每个Mode里面又包含多个Source/Time/Observer。但是，需要注意的是，每次开启Runloop的时候，只会使用其中一个Mode，一般叫做CurrentMode。有时候场景中需要切换Mode，切换的时候，只能先退出当前Mode，然后再添加上新的Mode。</p><h4 id="Source0-和-Source1"><a href="#Source0-和-Source1" class="headerlink" title="Source0 和 Source1"></a>Source0 和 Source1</h4><p>CFRunLoopSourceRef有两个版本：Source0和Source1，Source的作用是给线程发送异步事件。其中Source0是接收App内部的事件，比如用户点击滑动等等事件，App自己负责处理，需要手动唤醒Runloop，来处理这个事件；Source1是通过内核和其他线程发送消息用的，可以自动唤醒Runloop的线程。</p><h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>顾名思义，CFRunLoopTimerRef是基于事件来出发的，和NSTimer的底层一样。当其加入到Runloop时，Runloop会注册对应的时间点，当事件点到时，Runloop会唤醒执行那个回调。常见的使用场比如：延迟执行某个方法、CADisplayLink的使用等等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)performSelector:(SEL)selector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</span><br><span class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</span><br></pre></td></tr></table></figure><h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p>CFRunLoopObserverRef是基于观察者模式，和<code>CFRunLoopTimerRef</code>类似，每个Observer都会包含一个回调，用于监听Runloop的状态变化。可以监听到的状态变化有如下几个：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面所介绍的Source、Timer和Observer都可以添加到多个Model当中，但是如果在一个Mode当中添加多个，是不会起效果的，有一种特殊情况，就是当一个Mode里什么都没有，则这个Runloop就会直接退出。</p><h4 id="Runloop-Mode"><a href="#Runloop-Mode" class="headerlink" title="Runloop Mode"></a>Runloop Mode</h4><p>上面已经说过，Runloop的运行是基于特定的Mode，其数据结构如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里需要注意一下，有一个很关键的属性叫<code>CommonModes</code>，每当Runloop的内容发生变化时，Runloop都会自动将_commonModelItems里的Source/Observer/Timer同步到具有”Common”标记的所有Mode里。</p><p>在iOS系统中包含了两个Mode，一个是<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>。这两个Mode都已经被注册成了CommonMode，一般App主线程的Runloop默认是<code>NSDefaultRunLoopMode</code>，当UIScrollView滑动的时候，Runloop就会退出，然后切换到<code>UITrackingRunLoopMode</code>。这两个是苹果公开的Mode，当然，还会有一些私有Mode，这里就不说了。</p><p>除了上面这些，苹果还提供了一个操作<code>CommonModes</code>的字符串，可以对所有的CommonMode进行操作，叫做<code>kCFRunLoopCommonModes</code>，有些人容易将这个东西和上面的Mode混淆，其实概念还是不一样的，<code>kCFRunLoopCommonMode</code>并不是一个新的Mode，在App主线程的Runloop中，是一个<code>CommonModes</code>组合，包含<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>两种Mode。这里的话在下面NSTimer的应用场景中详细讲解。</p><h4 id="Runloop常见应用场景"><a href="#Runloop常见应用场景" class="headerlink" title="Runloop常见应用场景"></a>Runloop常见应用场景</h4><h5 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h5><p>AutoreleasePool其实和Runloop是有关系的，有一个经典的面试题是问<code>AutoreleasePool对象是什么时候释放的？</code>，什么答案都有，标准答案应该是AutoreleasePool对象应该是在当前Runloop迭代结束之后释放的。</p><p>当App启动之后，iOS会在主线程注册两个Observer，第一个Observer是监听即将进入Runloop的状态，监听到后，来创建AutoreleasePool对象，其优先级也是最高的，要保证创建AutoreleasePool发生在其他所有回调之前；第二个Observer是监听Runloop准备休眠状态，来释放旧的AutoreleasePool对象，并且创建新的AutoreleasePool对象以供使用，另外还需要监听即将退出Runloop的状态，优先级是最低的，以此来保证释放操作在其他所有回调之后。</p><p>所以，如果以后有人再问你<code>AutoreleasePool对象是什么时候释放的？</code>，一定要说这和Runloop有关系，当Runloop准备休眠的时候，会释放旧的AutoreleasePool对象，创建新的AutoreleasePool对象，当Runloop即将退出的时候，会释放掉相关所有的AutoreleasePool对象。</p><h5 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h5><p>NSTimer在时间点的触发，是基于Runloop运行的，使用NSTimer之前，都需要注册到Runloop上。其实NSTimer就是CFRunLoopTimerRef，一个NSTimer注册好之后，Runloop会自动在时间节点注册好事件。但是Runloop为了节省资源，并不会在非常准确的时间节点调用定时器。为此，NSTimer专门提供了一个tolerance属性，来设置宽容度，标记当时间节点到来之后，容许有多少误差可以出发回调。如果错过了某个时间节点，就只能等下一个时间节点的到来。</p><p>回到之前Mode的话题，当UIScrollView进行滚动的时候，NSTimer就无法正常工作，停止滑动又恢复正常。这个原因是，添加到Runloop的NSTimer默认是以<code>NSDefaultRunLoopMode</code>模式在工作，当UIScrollView进行滑动的时候，Runloop会退出，然后切换到<code>UITrackingRunLoopMode</code>模式。由于NSTimer不是在这个模式下运行的，所以不会触发定时任务，无法工作。</p><p>要解决这个问题，我们让需要将NSTimer在<code>NSDefaultRunLoopMode</code>和<code>NSTrackingRunLoopMode</code>两个模式下工作，在UIScrollView滑动的时候也可以进行触发定时任务。所以，我们需要使用到<code>kCFRunLoopCommonModes</code>来完成任务。一般使用如下语句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[NSRunloop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><h5 id="事件响应和手势识别"><a href="#事件响应和手势识别" class="headerlink" title="事件响应和手势识别"></a>事件响应和手势识别</h5><p>事件响应其实和Runloop也是有关系的，为此，苹果专门注册了一个Source1用来接收系统事件。当手机的硬件发生感应，比如触摸、锁屏和摇晃，苹果注册的这个Source1都会收到回调，然后会将事件进行应用内部分发。</p><p>然后，App内主线程的Runloop会出发Source0事件，Source0收到回到进行下一步操作。</p><p>不同于事件响应，对于手势识别，收到苹果Source1对应用内部分发事件后，首先先将所有的手势回调打断，将所对应的UIGestureRecognizer事件标记为待处理，然后苹果会注册一个Observer来监听Runloop即将进入休眠的状态，然后在Observer回调里执行GestureRecognizer的回调。</p><h5 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h5><p>UI更新也和Runloop有关，当在操作Ui时，改变了UI的大小、层次等，这个UIView/CALayer就被标记为待处理，并被提交到一个全局的容器中。</p><p>苹果注册了一个Observer来监听Runloop即将进入休眠和即将退出的状态，然后在其Observer会调里遍历所有待处理的UIView/CALayer以执行实际的绘制和调整，并更新UI界面。</p><h5 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h5><p>GCD底层也和Runloop有关，当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会向主线程的Runloop发送消息，Runloop会被唤醒，并从消息中取得这个block，并在回调里执行这个block。但这个逻辑仅限于dispatch到主线程，disaptch到其他线程仍然是由libDispatch处理的。</p><h5 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h5><p>performSelector其实是创建了一个Timer，然后添加到当前线程中。如果当前线程没有Runloop，这个方法则走不通。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br></pre></td></tr></table></figure><p>另外，还有AFNetorking2.0、NSURLConnection的使用其实都和Runloop有关，AFNetorking2.0希望能在后台线程接收到Delegate回调，单独创建了一条线程，并在这条线程中启动了Runloop。但是AFNetorking换成基于NSURLSession之后，并没有看到相关Runloop代码。</p><h3 id="苹果官方文档中有下图："><a href="#苹果官方文档中有下图：" class="headerlink" title="苹果官方文档中有下图："></a><a href="https://link.jianshu.com/?t=https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">苹果官方文档</a>中有下图：</h3><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop.jpg" alt="Structure of a run loop and its sources"></p><h3 id="Runloop内部的逻辑基本如下："><a href="#Runloop内部的逻辑基本如下：" class="headerlink" title="Runloop内部的逻辑基本如下："></a>Runloop内部的逻辑基本如下：</h3><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop2.jpg" alt="1829339-d378878ffdf4c6ae.jpg"></p><h3 id="其内部代码整理如下："><a href="#其内部代码整理如下：" class="headerlink" title="其内部代码整理如下："></a>其内部代码整理如下：</h3><p>可以看到，实际上Runloop是一个这样的函数，其内部是一个do-while循环。当你调用<code>CFRunloopRun()</code>时，线程就会一直停留在这个循环里，直到手动停止或者超时，该函数才会返回。</p><h3 id="Runloop的底层实现："><a href="#Runloop的底层实现：" class="headerlink" title="Runloop的底层实现："></a>Runloop的底层实现：</h3><p>Runloop的核心是基于mach port的，其进入休眠时调用的函数是mach_msg()。解释这个逻辑，下面稍微介绍一下OSX/iOS的系统架构。</p><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop3.png" alt="1829339-be19d014752b22c0.png"></p><p>苹果官方将整个系统大致分为上述4个层次：</p><p>应用层包括用户能够接触到的图形应用，例如Spotlight、Aqua、SpringBoard等；</p><p>应用框架层即开发人员所接触到的Cocoa等框架；</p><p>核心架构层包括各种核心架构、OpenGL等内容；</p><p>Darwin即操作系统核心，包括系统内核、驱动、Shell等内容，是开源的，其所有源码都可以在opensource.apple.com里找到；</p><p>深入看Darwin这个核心架构：</p><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop4.png" alt="1829339-a9bd8e6efe4245a6.png"></p><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit（还包括上面一些标注内容），共同组成了XNU内核。</p><p>XNU内核的内环被称作为Mach，其作为一个内核，仅提供诸如处理器调度、IPC(进程间调度)等非常少量的基础服务。</p><p>BSD层可以看做是围绕Mach层的一个外环，其提供诸如进程管理、文件系统和网络等功能。</p><p>IOKit层为设置驱动提供了一个面向对象(C++)的架构。</p><p>Mach</p><p>本身提供的API非常有限，而且苹果也不鼓励使用Mach的API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在Mach中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为“对象”。和其他架构不同，Mach的对象间不能直接通信，只能通过消息传递的方式实现对象间的通信。“消息”是Mach中最基础的概念，消息在两个端口（port）之间传递，这就是Mach的IPC(进程间通信)的核心。</p><p>Mach的消息定义是在头文件的，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line"><span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">mach_msg_bits_t</span> msgh_bits;</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> msgh_size;</span><br><span class="line"><span class="keyword">mach_port_t</span> msgh_remote_port;</span><br><span class="line"><span class="keyword">mach_port_t</span> msgh_local_port;</span><br><span class="line"><span class="keyword">mach_port_name_t</span> msgh_voucher_port;</span><br><span class="line"><span class="keyword">mach_msg_id_t</span> msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure><p>一条Mach的消息实际上是一个二进制数据包（BLOB），其头部定了当前端口local_port和目标端口remote_port，发送和接收消息是通过同一个API进行的，其option标记了消息传递的方向。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span> mach_msg(</span><br><span class="line"><span class="keyword">mach_msg_header_t</span> *msg,</span><br><span class="line"><span class="keyword">mach_msg_option_t</span> option,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> send_size,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> rcv_size,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> rcv_name,</span><br><span class="line"><span class="keyword">mach_msg_timeout_t</span> timeout,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> notify);</span><br></pre></td></tr></table></figure><p>为了实现消息的发送和接收，mach_msg()函数实际上调用了一个Mach陷阱(trap)，即函数mach_msg_trap()，陷阱这个概念在Mach中等同于系统调用。当你在用户态调用mach_msg_map()时会出发陷阱机制，切换到内核态：内核态中内核实现的mach_msg()函数会完成实际工作，如下图：</p><p><img src="/2016/07/02/iOS-Runloop浅谈/runloop5.png" alt="1829339-7d244424ee5a8ef8.png"></p><p>这些概念参考维基百科：System_call、Trap_(computing)</p><p>RunLoop的核心就是一个mach_msg()（见上面代码第七部），RunLoop调用这个函数去接收实际消息，如果没有别人发送port，消息过来，内核会将线程闲置等待状态。例如你在模拟器里跑一个iOS App，然后在App静止时点击暂停，你会看到主线程调用栈是停留在<code>mach_msg_trap()</code>这个地方。</p><h3 id="苹果用Runloop实现的功能"><a href="#苹果用Runloop实现的功能" class="headerlink" title="苹果用Runloop实现的功能"></a>苹果用Runloop实现的功能</h3><p>首先我们可以看一下App启动后Runloop的状态：</p><p>可以看到，系统默认注册了5个Mode:</p><p>1.KCFRunLoopDefaultMode:App的默认Mode，通常主线程是在这个Mode下运行的。</p><p>2.UITrackingRunLoopMode:界面跟踪Mode，用于ScrollView跟踪触摸滑动，保证界面滑动时不受其他Mode影响。</p><p>3.UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode，启动完成后就不再使用。</p><p>4.GSEventReceiveRunLoopMode:接受系统事件的内部Mode，通常用不到。</p><p>5.kCFRunLoopCommonModes:这是一个占位的Mode，没有实际作用。</p><p>可以看到很多苹果内部的Mode，但那些Mode在开发中很难遇到。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有关Runloop的东西其实还有很多，这里只是站在大神的肩膀上，总结下基本的Runloop知识，希望能帮到需要的同学。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Runloop概述&quot;&gt;&lt;a href=&quot;#Runloop概述&quot; class=&quot;headerlink&quot; title=&quot;Runloop概述&quot;&gt;&lt;/a&gt;Runloop概述&lt;/h3&gt;&lt;p&gt;学习操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会
      
    
    </summary>
    
      <category term="工作" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="iOS" scheme="http://htmlios.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建博客</title>
    <link href="http://htmlios.github.io/2016/06/25/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://htmlios.github.io/2016/06/25/Hexo-Github搭建博客/</id>
    <published>2016-06-25T12:05:15.000Z</published>
    <updated>2018-06-23T18:01:37.407Z</updated>
    
    <content type="html"><![CDATA[<p>1.安装和配置Node.js环境，打开终端，成功界面如下</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog1.png" alt="img"></p><p>2.安装和配置Git环境，安装成功的象征是鼠标右键出现选择如下</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog2.png" alt="img"></p><p>3.Github账户注册和新建项目，勾选Initialize this repository with a README</p><p>4.创建博客文件夹，在该文件夹下安装Hexo，输入如下命令开始安装，成功如下图</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog3.png" alt="img"></p><p>输入hexo -v，检查hexo是否安装成功</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog4.png" alt="img"></p><p>输入hexo init，初始化该文件夹，需要一段时间</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog5.png" alt="img"></p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog6.png" alt="img"></p><p>输入npm install，安装所需要的组件</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog7.png" alt="img"></p><p>输入hexo g，首次体验Hexo</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog8.png" alt="img"></p><p>输入hexo s，开启服务器，访问该网址，正式体验Hexo</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog9.png" alt="img"></p><p>假如页面一直无法跳转，那么可能端口被占用了，输入命令ctrl+c停止服务器，输入hexo server -p来修改端口号</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog10.png" alt="img"></p><p>打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 如下图就成功了</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog11.png" alt="img"></p><p>5.将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次）</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog12.png" alt="img"></p><p>上图是在其文件夹里鼠标右键，点击Git Base Here。这里feng可以替换成自己的用户名，邮箱可以替换成自己的邮箱</p><p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog13.png" alt="img"></p><p>输入ls，列出该文件夹下的内容。下图说明存在</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog14.png" alt="img"></p><p>输入ssh-keygen -t rsa -C”邮箱地址”，连续三个回车，生成密钥，最后得到了两个文件夹:id_rsa和id_rsa.pub（默认存储路径是：C:/Users/Administrator/.ssh）。</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog15.png" alt="img"></p><p>输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog16.png" alt="img"></p><p>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog17.png" alt="img"></p><p>登录Github，点击头向下的settings，添加ssh</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog18.png" alt="img"></p><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog19.png" alt="img"></p><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加的ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog20.png" alt="img"></p><p>问题：加入ssh-key配置失败，那么只要以下步骤就能完全解决</p><p>首先，清楚所有的key-pair</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -D</span><br><span class="line">rm -r ~/.ssh</span><br></pre></td></tr></table></figure><p>删除你在github中的public-key</p><p>重新生成ssh密钥对</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure><p>接下来正常操作</p><p>在github上添加公钥public-key:</p><p>1.首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪贴板</p><p>2.在github上添加公钥时，直接复制即可</p><p>3.保存</p><p>测试：</p><p>在终端 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>6.配置Deployment，在其文件夹中，找到_config.yml文件夹，修改repo值（在末尾）</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog21.png" alt="img"></p><p>repo值是你在github项目里ssh (右下角)</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog22.png" alt="img"></p><p>7.新建一篇博客，在cmd执行命令：hexo new post”博客名”</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog23.png" alt="img"></p><p>这时候在文件夹_posts目录下将会看到已经创建好的文件</p><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog24.png" alt="img"></p><p>在生成以及波束文章之前，需要安装一个扩展: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog25.png" alt="img"></p><p>使用编辑器编辑好文章，那么就可以使用命令生成以及部署了</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p><img src="/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog26.png" alt="img"></p><p>部署成功后访问你的地址:http://用户名.github.io。将看到生成的文章</p><p>到此为止，最基本的也是最全面的Hexo+github搭建博客完结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.安装和配置Node.js环境，打开终端，成功界面如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/06/25/Hexo-Github搭建博客/Hexo-Github-Blog1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.安装和配置Git环境，安装成功的象征是鼠
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个性化配置</title>
    <link href="http://htmlios.github.io/2016/06/24/Hexo%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://htmlios.github.io/2016/06/24/Hexo个性化配置/</id>
    <published>2016-06-24T11:37:00.000Z</published>
    <updated>2018-07-05T04:01:47.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-next-categories和tags页面"><a href="#Hexo-next-categories和tags页面" class="headerlink" title="Hexo-next categories和tags页面"></a>Hexo-next categories和tags页面</h2><p>hexo默认是没有categories和tags的，创建步骤：</p><p>在hexo目录分别执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line"></span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>编辑<code>/tags/index.md</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: &quot;tags&quot;</span><br><span class="line"></span><br><span class="line">layout: &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>编辑<code>/categories/index.md</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: &quot;categories&quot;</span><br><span class="line"></span><br><span class="line">layout: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>取消next的<code>_config.yml</code>的<code>tags</code>、<code>categories</code>的注释。</p><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">hexo指令</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hexo-next-categories和tags页面&quot;&gt;&lt;a href=&quot;#Hexo-next-categories和tags页面&quot; class=&quot;headerlink&quot; title=&quot;Hexo-next categories和tags页面&quot;&gt;&lt;/a&gt;Hexo-
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-plugin</title>
    <link href="http://htmlios.github.io/2016/06/24/Hexo-plugin/"/>
    <id>http://htmlios.github.io/2016/06/24/Hexo-plugin/</id>
    <published>2016-06-24T09:53:00.000Z</published>
    <updated>2018-07-05T02:10:40.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-admin"><a href="#Hexo-admin" class="headerlink" title="Hexo-admin"></a>Hexo-admin</h2><p>老方式<code>hexo new post &quot;title&quot;</code>来新建博客，写完后，生成，发布<code>hexo d -g</code>，过程麻烦，不能可视化接受不了。</p><p>Hexo-admin可以比较好的解决这个问题，简单介绍一下：</p><p>官网：<code>https://jaredforsyth.com/hexo-admin/</code></p><p>安装hexo-admin插件（基于你已经搭建好<a href="https://htmlios.github.io/2016/06/25/Hexo-Github搭建博客/">Hexo</a>），并且启动hexo服务，打开浏览器访问能看到基本的界面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br><span class="line">hexo server -d</span><br><span class="line">open http://localhost:4000/admin/</span><br></pre></td></tr></table></figure><p>在hexo的_config.yml配置hexo-admin</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-admin authentification</span><br><span class="line"></span><br><span class="line">admin:</span><br><span class="line">  username: xxx # 账号</span><br><span class="line">  password_hash: xxx # 密码</span><br><span class="line">  secret: xxx</span><br><span class="line">  deployCommand: &apos;./hexo-deploy.sh&apos;</span><br></pre></td></tr></table></figure><p>密码生成方式，在<code>http://localhost:4000/admin/</code>-&gt;<code>Settings</code>-&gt;<code>Setup authentification here.</code>按照界面指示输入<code>Username</code>、<code>Password</code>、<code>Secret</code>后，在底部会看到生成的相应配置，将其拷贝到Hexo目录下的_config.yml里，重启hexo，访问<code>http://localhost:4000/admin/</code>输入你生成好的账号密码。</p><p>deployCommand需要配置，在Hexo目录下新建<code>hexo-deploy.sh</code>输入以下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>保存退出，并且赋予执行权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x hexo-deploy.sh</span><br></pre></td></tr></table></figure><p>完成，后续写完博客只需要点击Deploy即可生成发布</p><p><img src="/2016/06/24/Hexo-plugin/image-20180624184646419.png" alt="image-20180624184646419"></p><ul><li>Post：博客文章列表，包括已经发布的和还在草稿箱等待宠幸的；</li><li>Pages：就是诸如标签云之类的页面管理；</li><li>About：关于admin插件的说明</li><li>hexo-gen：这个原来是Deploy，被我修改了，关键节点；</li><li>Settings:配置</li></ul><h2 id="Hexo插入图片"><a href="#Hexo插入图片" class="headerlink" title="Hexo插入图片"></a>Hexo插入图片</h2><p>1.修改配置：修改hexo配置文件_config.yml，post_asset_folder: true；</p><p>2.安装插件：终端切换到在hexo目录，安装hexo-asset-image插件，命令及成功如下；成功后新生成md博文时，/source/_posts文件夹内会同时生成xxxx.md、xxxx文件夹；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p><img src="/2016/06/24/Hexo-plugin/image-20180622142939294.jpg" alt="安装hexo-asset-image plugin"></p><p>3.使用方式：在xxxx.md中想引入图片时，将图片存在xxxx文件夹内，后只需在xxxx.md中按照markdown的格式引入图片；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片hover提示](xxxx/图片名.图片格式)</span><br></pre></td></tr></table></figure><p>4.检验结果：hexo g生成页面后，进入public/年/月/日/xxxx/index.html找到生成的相关字段，html标签内的语句应如下；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;年/月/日/xxxx/图片名.图片格式&quot;&gt;</span><br></pre></td></tr></table></figure><p>慈不带兵，义不行贾。</p><h2 id="Hexo-next博客图片浏览器"><a href="#Hexo-next博客图片浏览器" class="headerlink" title="Hexo-next博客图片浏览器"></a>Hexo-next博客图片浏览器</h2><p>修改<code>next的</code> <code>_config.yml</code>配置里的<code>fancybox: true</code>，配置上方的注释有插件安装地址（包含安装教程）。</p><h2 id="Hexo博客安装RSS插件"><a href="#Hexo博客安装RSS插件" class="headerlink" title="Hexo博客安装RSS插件"></a>Hexo博客安装RSS插件</h2><p>安装插件，在本地hexo目录，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p>添加配置。在本地hexo根目录下的_config.yml文件中，添加以下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">#RSS订阅</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure><p>添加主题配置，在主题目录下的_config.yml目录下，添加如下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure><p>更新中。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hexo-admin&quot;&gt;&lt;a href=&quot;#Hexo-admin&quot; class=&quot;headerlink&quot; title=&quot;Hexo-admin&quot;&gt;&lt;/a&gt;Hexo-admin&lt;/h2&gt;&lt;p&gt;老方式&lt;code&gt;hexo new post &amp;quot;title&amp;quo
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="http://htmlios.github.io/2016/06/21/Hexo/"/>
    <id>http://htmlios.github.io/2016/06/21/Hexo/</id>
    <published>2016-06-20T18:07:00.000Z</published>
    <updated>2018-06-23T18:11:17.743Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="工具" scheme="http://htmlios.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://htmlios.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
